diff --git a/Molap/Molap-Aggregation/src/main/java/com/huawei/datasight/molap/autoagg/util/CommonUtil.java b/Molap/Molap-Aggregation/src/main/java/com/huawei/datasight/molap/autoagg/util/CommonUtil.java
index ad3f917..bfd2bc9 100644
--- a/Molap/Molap-Aggregation/src/main/java/com/huawei/datasight/molap/autoagg/util/CommonUtil.java
+++ b/Molap/Molap-Aggregation/src/main/java/com/huawei/datasight/molap/autoagg/util/CommonUtil.java
@@ -22,8 +22,6 @@ import com.huawei.datasight.molap.datastats.model.LoadModel;
 import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
-import com.huawei.unibi.molap.datastorage.store.fileperations.AtomicFileOperations;
-import com.huawei.unibi.molap.datastorage.store.fileperations.AtomicFileOperationsImpl;
 import com.huawei.unibi.molap.datastorage.store.filesystem.MolapFile;
 import com.huawei.unibi.molap.datastorage.store.impl.FileFactory;
 import com.huawei.unibi.molap.datastorage.store.impl.FileFactory.FileType;
@@ -53,21 +51,16 @@ public final class CommonUtil
 		List<String> listOfValidSlices = new ArrayList<String>(10);
 		DataInputStream dataInputStream = null;
 		Gson gsonObjectToRead = new Gson();
-		
-		AtomicFileOperations fileOperation = new AtomicFileOperationsImpl(loadMetaPath, FileFactory.getFileType(loadMetaPath));
-		
 		try
 		{
 			if (FileFactory.isFileExist(loadMetaPath,
 					FileFactory.getFileType(loadMetaPath)))
 			{
-			    
-			    dataInputStream = fileOperation.openForRead();
-			    
-				/*dataInputStream = FileFactory.getDataInputStream(
+
+				dataInputStream = FileFactory.getDataInputStream(
 						loadMetaPath,
 						FileFactory.getFileType(loadMetaPath));
-*/
+
 				BufferedReader buffReader = new BufferedReader(
 						new InputStreamReader(dataInputStream, "UTF-8"));
 
diff --git a/Molap/Molap-Aggregation/src/main/java/com/huawei/datasight/molap/datastats/analysis/AggDataSuggestScanner.java b/Molap/Molap-Aggregation/src/main/java/com/huawei/datasight/molap/datastats/analysis/AggDataSuggestScanner.java
index 927dac3..f21fc7c 100644
--- a/Molap/Molap-Aggregation/src/main/java/com/huawei/datasight/molap/datastats/analysis/AggDataSuggestScanner.java
+++ b/Molap/Molap-Aggregation/src/main/java/com/huawei/datasight/molap/datastats/analysis/AggDataSuggestScanner.java
@@ -1,17 +1,12 @@
 package com.huawei.datasight.molap.datastats.analysis;
 
-import java.io.DataOutputStream;
-import java.io.IOException;
+import java.math.BigDecimal;
 import java.nio.ByteBuffer;
 import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
 
 import com.huawei.unibi.molap.datastorage.store.columnar.ColumnarKeyStoreDataHolder;
 import com.huawei.unibi.molap.engine.columnar.keyvalue.AbstractColumnarScanResult;
-import com.huawei.unibi.molap.engine.complex.querytypes.GenericQueryType;
-import com.huawei.unibi.molap.engine.wrappers.ByteArrayWrapper;
-import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
+import com.huawei.unibi.molap.olap.SqlStatement;
 
 /**
  * This is store scanner, it returns given no of rows of records
@@ -103,9 +98,17 @@ public class AggDataSuggestScanner extends AbstractColumnarScanResult
 	 * } return columnsData; }
 	 */
 
-	public double getNormalMeasureValue(int measureOrdinal)
+	public Object getNormalMeasureValue(int measureOrdinal, SqlStatement.Type dataType)
 	{
-		return 0.0;
+		switch(dataType)
+		{
+			case BIGINT:
+				return (long)(0);
+			case DECIMAL:
+				return new BigDecimal(0);
+			default:
+				return 0.0;
+		}
 	}
 
 	public byte[] getCustomMeasureValue(int measureOrdinal)
@@ -117,10 +120,6 @@ public class AggDataSuggestScanner extends AbstractColumnarScanResult
 	{
 		return null;
 	}
-	public List<byte[]> getKeyArrayWithComplexTypes(Map<Integer, GenericQueryType> complexQueryDims)
-	{
-		return null;
-	}
 
 	@Override
 	public int getDimDataForAgg(int dimOrdinal)
@@ -129,24 +128,4 @@ public class AggDataSuggestScanner extends AbstractColumnarScanResult
 		return 0;
 	}
 
-	@Override
-	public void getComplexDimDataForAgg(GenericQueryType complexType,
-			DataOutputStream dataOutputStream) throws IOException {
-		// TODO Auto-generated method stub
-		
-	}
-
-	@Override
-	public byte[] getKeyArray(ByteArrayWrapper key) {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-    @Override
-    public byte[] getHighCardinalityDimDataForAgg(Dimension dimension)
-    {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
 }
diff --git a/Molap/Molap-Core/src/com/huawei/datasight/molap/core/load/LoadMetadataDetails.java b/Molap/Molap-Core/src/com/huawei/datasight/molap/core/load/LoadMetadataDetails.java
index 2a75f66..82c8fd7 100644
--- a/Molap/Molap-Core/src/com/huawei/datasight/molap/core/load/LoadMetadataDetails.java
+++ b/Molap/Molap-Core/src/com/huawei/datasight/molap/core/load/LoadMetadataDetails.java
@@ -15,11 +15,11 @@ public class LoadMetadataDetails implements Serializable {
 	private String loadStatus;
 	private String loadName;
 	private String partitionCount;
+//	private String deletionStatus;
 	private String deletionTimestamp;
     public final String  versionNumber= MolapVersion.getDataVersion();
     private String loadStartTime;
     
-    private String mergedLoadName;
     /**
      * visibility is used to determine whether to the load is visible or not.
      */
@@ -57,7 +57,23 @@ public class LoadMetadataDetails implements Serializable {
 		this.loadName = loadName;
 	}
 	
+	
+
 	/**
+	 * @return the deletionStatus
+	 *//*
+	public String getDeletionStatus() {
+		return deletionStatus;
+	}
+
+	*//**
+	 * @param deletionStatus the deletionStatus to set
+	 *//*
+	public void setDeletionStatus(String deletionStatus) {
+		this.deletionStatus = deletionStatus;
+	}
+*/
+    /**
      * @return the deletionTimestamp
      */
     public String getDeletionTimestamp()
@@ -135,21 +151,6 @@ public class LoadMetadataDetails implements Serializable {
     }
 
     /**
-     * @return the mergedLoadName
-     */
-    public String getMergedLoadName()
-    {
-        return mergedLoadName;
-    }
-
-    /**
-     * @param mergedLoadName the mergedLoadName to set
-     */
-    public void setMergedLoadName(String mergedLoadName)
-    {
-        this.mergedLoadName = mergedLoadName;
-    }
-    /**
      * @return the visibility
      */
     public String getVisibility()
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/constants/IgnoreDictionary.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/constants/IgnoreDictionary.java
deleted file mode 100644
index eea5422..0000000
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/constants/IgnoreDictionary.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/**
- * 
- */
-package com.huawei.unibi.molap.constants;
-
-/**
- * This enum is used for determining the indexes of the
- * dimension,ignoreDictionary,measure columns.
- * 
- * @author R00903928
- * 
- */
-public enum IgnoreDictionary {
-    /**
-     * POSITION WHERE DIMENSIONS R STORED IN OBJECT ARRAY.
-     */
-   DIMENSION_INDEX_IN_ROW (0),
-    
-   /**
-    * POSITION WHERE BYTE[] (high cardinality) IS STORED IN OBJECT ARRAY.
-    */
-   BYTE_ARRAY_INDEX_IN_ROW(1),
-   
-    /**
-     * POSITION WHERE MEASURES R STORED IN OBJECT ARRAY.
-     */
-    MEASURES_INDEX_IN_ROW (2);
-    
-   
-   private final int index;
-
-   IgnoreDictionary(int index) {
-       this.index = index;
-   }
-   
-   public int getIndex() {
-       return this.index;
-   }
-
-}
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/constants/MolapCommonConstants.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/constants/MolapCommonConstants.java
index 6ca8adc..f3337dc 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/constants/MolapCommonConstants.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/constants/MolapCommonConstants.java
@@ -724,7 +724,7 @@ public final class MolapCommonConstants
      * GRAPH_ROWSET_SIZE_DEFAULT
      */
     public static final String GRAPH_ROWSET_SIZE_DEFAULT="500";
-       /**
+    /**
      * 
      * Comment for <code>TYPE_MYSQL</code>
      * 
@@ -777,6 +777,11 @@ public final class MolapCommonConstants
     public static final String SORT_FILE_BUFFER_SIZE_DEFAULT_VALUE="10";
  
     /**
+     * DATA_LOAD_LOG_COUNTER
+     */
+    public static final String DATA_LOAD_LOG_COUNTER="molap.data.load.log.counter";
+    
+    /**
      * DATA_LOAD_LOG_COUNTER_DEFAULT_COUNTER
      */
     public static final String DATA_LOAD_LOG_COUNTER_DEFAULT_COUNTER="500000";
@@ -812,6 +817,11 @@ public final class MolapCommonConstants
     public static final String NUMBER_OF_THERADS_FOR_INTERMEDIATE_MERGING_DEFAULT_VALUE="1";
     
     /**
+     * WRITE_ALL_NODE_IN_SINGLE_TIME
+     */
+    public static final String  WRITE_ALL_NODE_IN_SINGLE_TIME="molap.datawriter.write.all.node";
+    
+    /**
      * WRITE_ALL_NODE_IN_SINGLE_TIME_DEFAULT_VALUE
      */
     public static final String  WRITE_ALL_NODE_IN_SINGLE_TIME_DEFAULT_VALUE="true";
@@ -834,7 +844,12 @@ public final class MolapCommonConstants
     /**
      * CSV_READ_COPIES
      */
-    public static final String DEFAULT_NUMBER_CORES = "2";
+    public static final String CSV_READ_COPIES = "molap.csv.read.copies";
+    
+    /**
+     * CSV_READ_COPIES
+     */
+    public static final String CSV_READ_COPIES_DEFAULT = "1";
 
     /**
      * CSV_FILE_EXTENSION
@@ -1155,7 +1170,7 @@ public final class MolapCommonConstants
      * MOLAP_DATALOAD_VALID_CSVFILE_SIZE_DEFAULTVALUE
      */
     public static final String MOLAP_DATALOAD_VALID_NUMBAER_OF_CSVFILE_DEFAULTVALUE = "100";
-    
+       
     /**
      * MOLAP_IS_GROUPBY_IN_SORT_DEFAULTVALUE
      */
@@ -1460,10 +1475,6 @@ public final class MolapCommonConstants
     
     public static final String TIMESTAMP_TYPE = "TimestampType";
     
-    public static final String ARRAY_TYPE = "ArrayType";
-    
-    public static final String STRUCT_TYPE = "StructType";
-    
     public static final String BYTE_TYPE = "ByteType";
     
     public static final String SHORT_TYPE = "ShortType";
@@ -1482,10 +1493,6 @@ public final class MolapCommonConstants
     
     public static final String TIMESTAMP = "Timestamp";
     
-    public static final String ARRAY = "Array";
-    
-    public static final String STRUCT = "Struct";
-    
     public static final String INCLUDE = "include";
     
     public static final String FROM = "from";
@@ -1612,27 +1619,25 @@ public final class MolapCommonConstants
     public static final char BYTE_VALUE_MEASURE='c';
     
     /**
-     * MEASURE_NOT_NULL_VALUE
+     * BIG_DECIMAL_MEASURE
      */
-    
-    public static final byte MEASURE_NOT_NULL_VALUE=1;
+    public static final char BIG_DECIMAL_MEASURE='b';
     
     /**
-     * MEASURE_NULL_VALUE
+     * BIG_INT_MEASURE
      */
-    public static final byte MEASURE_NULL_VALUE=0;
-
+    public static final char BIG_INT_MEASURE='l';
+    
     /**
-     * short required to store the length of following byte array(high card dim)
+     * MEASURE_NOT_NULL_VALUE
      */
-    public static final int BYTESREQTOSTORELENGTH = 2;
+    
+    public static final byte MEASURE_NOT_NULL_VALUE=1;
     
     /**
-     * This determines the size of array to be processed in data load steps. one
-     * for dimensions , one of ignore dictionary dimensions , one for measures.
+     * MEASURE_NULL_VALUE
      */
-    public static final int ARRAYSIZE = 3;
-
+    public static final byte MEASURE_NULL_VALUE=0;
     
     public static final String CARBON_UNIFIED_STORE_PATH = "carbon.unified.store.path";
     
@@ -1656,56 +1661,6 @@ public final class MolapCommonConstants
     public static final boolean  MOLAP_PREFETCH_IN_MERGE_VALUE = false;
     
     
-	
-	/**
-	 * TEMPWRITEFILEEXTENSION
-	 */
-    public static final String TEMPWRITEFILEEXTENSION = ".write";
-
-	 /**
-      * MERGE_THRESHOLD_VALUE
-      */
-     public static final String MERGE_THRESHOLD_VALUE = "molap.merge.threshold";
-
-     /**
-      * MERGE_THRESHOLD_DEFAULT_VAL
-      */
-     public static final String MERGE_THRESHOLD_DEFAULT_VAL = "10";
-
-     /**
-      * MERGE_FACTSIZE_THRESHOLD_VALUE
-      */
-    public static final String MERGE_FACTSIZE_THRESHOLD_VALUE = "molap.merge.factsize.threshold";
-
-    /**
-     * MERGE_FACTSIZE_THRESHOLD_DEFAULT_VAL
-     */
-    public static final String MERGE_FACTSIZE_THRESHOLD_DEFAULT_VAL = "10";
-    
-    /**
-     * MARKED_FOR_MERGE
-     */
-    public static final String MARKED_FOR_MERGE = "Marked For Merge";
-
-    /**
-     * TO_LOAD_MERGE_MAX_SIZE
-     */
-    public static final String TO_LOAD_MERGE_MAX_SIZE = "to.merge.load.max.size";
-
-    /**
-     * TO_LOAD_MERGE_MAX_SIZE_DEFAULT
-     */
-    public static final String TO_LOAD_MERGE_MAX_SIZE_DEFAULT = "1";
-    
-    /**
-     * ENABLE_LOAD_MERGE
-     */
-    public static final String ENABLE_LOAD_MERGE="molap.enable.load.merge";
-    
-    /**
-     * DEFAULT_ENABLE_LOAD_MERGE
-     */
-    public static final String DEFAULT_ENABLE_LOAD_MERGE="false";
 }
 
 
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/NodeMeasureDataStore.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/NodeMeasureDataStore.java
index 09b269b..6127576 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/NodeMeasureDataStore.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/NodeMeasureDataStore.java
@@ -11,6 +11,7 @@
  */
 package com.huawei.unibi.molap.datastorage.store;
 
+import com.huawei.unibi.molap.datastorage.store.dataholder.AbstractWriteDataHolder;
 import com.huawei.unibi.molap.datastorage.store.dataholder.MolapWriteDataHolder;
 
 /**
@@ -59,7 +60,7 @@ public interface NodeMeasureDataStore //<T>
      * @return writable array (compressed or normal)
      *
      */
-     byte[][] getWritableMeasureDataArray(MolapWriteDataHolder[] dataHolderArray);
+     byte[][] getWritableMeasureDataArray(AbstractWriteDataHolder[] dataHolderArray);
 
     /**
      * 
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/columnar/BlockIndexerStorageForInt.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/columnar/BlockIndexerStorageForInt.java
index 12d95f9..ebd7d94 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/columnar/BlockIndexerStorageForInt.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/columnar/BlockIndexerStorageForInt.java
@@ -23,30 +23,13 @@ public class BlockIndexerStorageForInt implements IndexStorage<int[]>
 
     public BlockIndexerStorageForInt(byte[][] keyBlock)
     {
-        this(keyBlock, false, false, true);
+        this(keyBlock, false);
     }
-    
-    public BlockIndexerStorageForInt(byte[][] keyBlock, boolean compressData, boolean isSortRequired)
-    {
-        ColumnWithIntIndex[] columnWithIndexs = createColumnWithIndexArray(keyBlock,false);
-        if(isSortRequired)
-        {
-            Arrays.sort(columnWithIndexs);
-        }
-        compressMyOwnWay(extractDataAndReturnIndexes(columnWithIndexs, keyBlock));
-        if(compressData)
-        {
-            compressDataMyOwnWay(columnWithIndexs);
-        }
-    }
-    
-    public BlockIndexerStorageForInt(byte[][] keyBlock, boolean compressData, boolean isHighCardinality, boolean isSortRequired)
+
+    public BlockIndexerStorageForInt(byte[][] keyBlock, boolean compressData)
     {
-        ColumnWithIntIndex[] columnWithIndexs = createColumnWithIndexArray(keyBlock,isHighCardinality);
-        if(isSortRequired)
-        {
-            Arrays.sort(columnWithIndexs);
-        }
+        ColumnWithIntIndex[] columnWithIndexs = createColumnWithIndexArray(keyBlock);
+        Arrays.sort(columnWithIndexs);
         compressMyOwnWay(extractDataAndReturnIndexes(columnWithIndexs, keyBlock));
         if(compressData)
         {
@@ -60,27 +43,13 @@ public class BlockIndexerStorageForInt implements IndexStorage<int[]>
      * @param cols
      * @return
      */
-    private ColumnWithIntIndex[] createColumnWithIndexArray(byte[][] keyBlock,boolean isHighCardinality)
+    private ColumnWithIntIndex[] createColumnWithIndexArray(byte[][] keyBlock)
     {
-        ColumnWithIntIndex[] columnWithIndexs ;
-        if(isHighCardinality)
-        {
-             columnWithIndexs = new  ColumnWithIntIndexForHighCard[keyBlock.length];
-             for(int i = 0;i < columnWithIndexs.length;i++)
-             {
-                 columnWithIndexs[i] = new ColumnWithIntIndexForHighCard(keyBlock[i], i);
-             }
-
-        }
-        else
+        ColumnWithIntIndex[] columnWithIndexs = new ColumnWithIntIndex[keyBlock.length];
+        for(int i = 0;i < columnWithIndexs.length;i++)
         {
-         columnWithIndexs = new ColumnWithIntIndex[keyBlock.length];
-         for(int i = 0;i < columnWithIndexs.length;i++)
-         {
-             columnWithIndexs[i] = new ColumnWithIntIndex(keyBlock[i], i);
-         }
+            columnWithIndexs[i] = new ColumnWithIntIndex(keyBlock[i], i);
         }
-        
         return columnWithIndexs;
     }
 
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/columnar/ColumnWithIntIndex.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/columnar/ColumnWithIntIndex.java
index 59b315d..01a5f73 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/columnar/ColumnWithIntIndex.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/columnar/ColumnWithIntIndex.java
@@ -4,7 +4,7 @@ import com.huawei.unibi.molap.util.ByteUtil.UnsafeComparer;
 
 public class ColumnWithIntIndex implements Comparable<ColumnWithIntIndex>
 {
-    protected byte[] column;
+    private byte[] column;
     
     private int index;
 
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/columnar/ColumnWithIntIndexForHighCard.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/columnar/ColumnWithIntIndexForHighCard.java
deleted file mode 100644
index b98044e..0000000
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/columnar/ColumnWithIntIndexForHighCard.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package com.huawei.unibi.molap.datastorage.store.columnar;
-
-import com.huawei.unibi.molap.util.ByteUtil.UnsafeComparer;
-
-public class ColumnWithIntIndexForHighCard extends ColumnWithIntIndex implements Comparable<ColumnWithIntIndex>
-{
-
-    public ColumnWithIntIndexForHighCard(byte[] column, int index)
-    {
-        super(column, index);
-    }
-
-    @Override
-    public int compareTo(ColumnWithIntIndex o)
-    {
-        return UnsafeComparer.INSTANCE.compareTo(column, 2, column.length-2, o.column, 2, o.column.length-2);
-    }
-
-}
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/columnar/ColumnarKeyStoreMetadata.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/columnar/ColumnarKeyStoreMetadata.java
index 2820eb4..8f0a27f 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/columnar/ColumnarKeyStoreMetadata.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/columnar/ColumnarKeyStoreMetadata.java
@@ -1,7 +1,5 @@
 package com.huawei.unibi.molap.datastorage.store.columnar;
 
-import java.util.Map;
-
 import com.huawei.unibi.molap.keygenerator.KeyGenerator;
 import com.huawei.unibi.molap.keygenerator.factory.KeyGeneratorFactory;
 
@@ -20,21 +18,7 @@ public class ColumnarKeyStoreMetadata
     private boolean isUnCompressed;
 
     private KeyGenerator keyGenerator;
-
-    /**
-     * isDirectSurrogateColumn.
-     */
-    private boolean isDirectSurrogateColumn;
-
-
-
-    /**
-     * mapOfColumnarKeyBlockData
-     */
-    private Map<Integer, byte[]> mapOfColumnarKeyBlockData;
     
-
-
     public ColumnarKeyStoreMetadata(int eachRowSize)
     {
         this.eachRowSize=eachRowSize;
@@ -127,41 +111,4 @@ public class ColumnarKeyStoreMetadata
     {
         return keyGenerator;
     }
-
-    /**
-     * 
-     * @param isDirectSurrogateColumn
-     */
-    public void setDirectSurrogateColumn(boolean isDirectSurrogateColumn)
-    {
-       this.isDirectSurrogateColumn=isDirectSurrogateColumn;
-        
-    }
-    /**
-     * 
-     * @return
-     */
-    public boolean isDirectSurrogateColumn()
-    {
-        return isDirectSurrogateColumn;
-    }
-
-    /**
-     * setDirectSurrogateKeyMembers.
-     * @param mapOfColumnarKeyBlockData
-     */
-    public void setDirectSurrogateKeyMembers(Map<Integer, byte[]> mapOfColumnarKeyBlockData)
-    {
-        this.mapOfColumnarKeyBlockData=mapOfColumnarKeyBlockData;
-        
-    }
-    
-    /**
-     * getMapOfColumnarKeyBlockDataForDirectSurroagtes.
-     * @return
-     */
-    public Map<Integer, byte[]> getMapOfColumnarKeyBlockDataForDirectSurroagtes()
-    {
-        return mapOfColumnarKeyBlockData;
-    }
 }
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/MeasureMetaDataModel.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/MeasureMetaDataModel.java
index f77be51..49d5e35 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/MeasureMetaDataModel.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/MeasureMetaDataModel.java
@@ -12,6 +12,8 @@
 
 package com.huawei.unibi.molap.datastorage.store.compression;
 
+import java.util.Objects;
+
 /**
  * Project Name NSE V3R8C10 
  * Module Name : MOLAP Data Processor
@@ -26,12 +28,12 @@ public class MeasureMetaDataModel
     /**
      * maxValue
      */
-    private double[] maxValue;
+    private Object[] maxValue;
 
     /**
      * minValue
      */
-    private double[] minValue;
+    private Object[] minValue;
 
     /**
      * decimal
@@ -46,7 +48,7 @@ public class MeasureMetaDataModel
     /**
      * uniqueValue
      */
-    private double[] uniqueValue;
+    private Object[] uniqueValue;
 
     /**
      * type
@@ -58,7 +60,7 @@ public class MeasureMetaDataModel
      */
     private byte[] dataTypeSelected;
     
-    private double[] minValueFactForAgg;
+    private Object[] minValueFactForAgg;
     
     public MeasureMetaDataModel()
     {
@@ -73,8 +75,8 @@ public class MeasureMetaDataModel
      * @param uniqueValue
      * @param type
      */
-    public MeasureMetaDataModel(double[] minValue, double[] maxValue, int[] decimal, int measureCount,
-            double[] uniqueValue, char[] type,byte[] dataTypeSelected)
+    public MeasureMetaDataModel(Object[] minValue, Object[] maxValue, int[] decimal, int measureCount,
+            Object[] uniqueValue, char[] type,byte[] dataTypeSelected)
     {
         this.minValue = minValue;
         this.maxValue = maxValue;
@@ -90,7 +92,7 @@ public class MeasureMetaDataModel
      * 
      * @return
      */
-    public double[] getMaxValue()
+    public Object[] getMaxValue()
     {
         return maxValue;
     }
@@ -100,7 +102,7 @@ public class MeasureMetaDataModel
      * 
      * @param maxValue
      */
-    public void setMaxValue(double[] maxValue)
+    public void setMaxValue(Object[] maxValue)
     {
         this.maxValue = maxValue;
     }
@@ -111,7 +113,7 @@ public class MeasureMetaDataModel
      * 
      * @return
      */
-    public double[] getMinValue()
+    public Object[] getMinValue()
     {
         return minValue;
     }
@@ -121,7 +123,7 @@ public class MeasureMetaDataModel
      * 
      * @param minValue
      */
-    public void setMinValue(double[] minValue)
+    public void setMinValue(Object[] minValue)
     {
         this.minValue = minValue;
     }
@@ -171,7 +173,7 @@ public class MeasureMetaDataModel
      * 
      * @return
      */
-    public double[] getUniqueValue()
+    public Object[] getUniqueValue()
     {
         return uniqueValue;
     }
@@ -181,7 +183,7 @@ public class MeasureMetaDataModel
      * 
      * @param uniqueValue
      */
-    public void setUniqueValue(double[] uniqueValue)
+    public void setUniqueValue(Object[] uniqueValue)
     {
         this.uniqueValue = uniqueValue;
     }
@@ -220,14 +222,14 @@ public class MeasureMetaDataModel
     /**
      * @return the minValueFactForAgg
      */
-    public double[] getMinValueFactForAgg()
+    public Object[] getMinValueFactForAgg()
     {
         return minValueFactForAgg;
     }
     /**
      * @param minValueFactForAgg the minValueFactForAgg to set
      */
-    public void setMinValueFactForAgg(double[] minValueFactForAgg)
+    public void setMinValueFactForAgg(Object[] minValueFactForAgg)
     {
         this.minValueFactForAgg = minValueFactForAgg;
     }
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/ValueCompressionModel.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/ValueCompressionModel.java
index 65d6107..c6c181d 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/ValueCompressionModel.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/ValueCompressionModel.java
@@ -22,21 +22,27 @@ public class ValueCompressionModel
      *  DataType[]  variable.
      */
     private DataType[] changedDataType;
+
+    /**
+     *  DataType[]  variable.
+     */
+    private DataType[] actualDataType;
+
     /**
      * maxValue
      */
-    private double[] maxValue;
+    private Object[] maxValue;
     /**
      *minValue.
      */
-    private double[] minValue;
+    private Object[] minValue;
     
-    private double[] minValueFactForAgg;
+    private Object[] minValueFactForAgg;
     
     /**
      * uniqueValue
      */
-    private double[] uniqueValue;
+    private Object[] uniqueValue;
     /**
      * decimal.
      */
@@ -82,6 +88,14 @@ public class ValueCompressionModel
     }
 
     /**
+     * @return the actualDataType
+     */
+    public DataType[] getActualDataType()
+    {
+        return actualDataType;
+    }
+
+    /**
      * @param changedDataType
      *            the changedDataType to set
      */
@@ -91,9 +105,17 @@ public class ValueCompressionModel
     }
 
     /**
+     * @param actualDataType
+     */
+    public void setActualDataType(DataType[] actualDataType)
+    {
+        this.actualDataType = actualDataType;
+    }
+
+    /**
      * @return the maxValue
      */
-    public double[] getMaxValue()
+    public Object[] getMaxValue()
     {
         return maxValue;
     }
@@ -102,7 +124,7 @@ public class ValueCompressionModel
      * @param maxValue
      *            the maxValue to set
      */
-    public void setMaxValue(double[] maxValue)
+    public void setMaxValue(Object[] maxValue)
     {
         this.maxValue = maxValue;
     }
@@ -146,7 +168,7 @@ public class ValueCompressionModel
      * getMinValue
      * @return
      */
-    public double[] getMinValue()
+    public Object[] getMinValue()
     {
         return minValue;
     }
@@ -155,7 +177,7 @@ public class ValueCompressionModel
      * setMinValue.
      * @param minValue
      */
-    public void setMinValue(double[] minValue)
+    public void setMinValue(Object[] minValue)
     {
         this.minValue = minValue;
     }
@@ -189,7 +211,7 @@ public class ValueCompressionModel
      * getUniqueValue
      * @return
      */
-    public double[] getUniqueValue()
+    public Object[] getUniqueValue()
     {
         return uniqueValue;
     }
@@ -198,7 +220,7 @@ public class ValueCompressionModel
      * setUniqueValue
      * @param uniqueValue
      */
-    public void setUniqueValue(double[] uniqueValue)
+    public void setUniqueValue(Object[] uniqueValue)
     {
         this.uniqueValue = uniqueValue;
     }
@@ -215,7 +237,7 @@ public class ValueCompressionModel
     /**
      * @return the minValueFactForAgg
      */
-    public double[] getMinValueFactForAgg()
+    public Object[] getMinValueFactForAgg()
     {
         return minValueFactForAgg;
     }
@@ -223,7 +245,7 @@ public class ValueCompressionModel
     /**
      * @param minValueFactForAgg the minValueFactForAgg to set
      */
-    public void setMinValueFactForAgg(double[] minValueFactForAgg)
+    public void setMinValueFactForAgg(Object[] minValueFactForAgg)
     {
         this.minValueFactForAgg = minValueFactForAgg;
     }
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/ValueCompressonHolder.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/ValueCompressonHolder.java
index 43e745e..58693d1 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/ValueCompressonHolder.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/ValueCompressonHolder.java
@@ -72,7 +72,7 @@ public final class ValueCompressonHolder
         
         UnCompressValue getCompressorObject();
         
-        MolapReadDataHolder getValues(int decimal, double maxValue);
+        MolapReadDataHolder getValues(int decimal, Object maxValueObject);
 
     }
 
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressByteArray.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressByteArray.java
index caa208e..6dbcda0 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressByteArray.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressByteArray.java
@@ -11,6 +11,7 @@
  */
 package com.huawei.unibi.molap.datastorage.store.compression.type;
 
+import java.math.BigDecimal;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.List;
@@ -22,9 +23,12 @@ import com.huawei.unibi.molap.datastorage.store.compression.Compressor;
 import com.huawei.unibi.molap.datastorage.store.compression.SnappyCompression;
 import com.huawei.unibi.molap.datastorage.store.compression.ValueCompressonHolder.UnCompressValue;
 import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+import com.huawei.unibi.molap.util.DataTypeUtil;
 import com.huawei.unibi.molap.util.MolapCoreLogEvent;
 import com.huawei.unibi.molap.util.ValueCompressionUtil.DataType;
 
+import javax.print.DocFlavor;
+
 /**
  * Project Name NSE V3R8C10 
  * Module Name : MOLAP Data Processor
@@ -36,6 +40,27 @@ import com.huawei.unibi.molap.util.ValueCompressionUtil.DataType;
  */
 public class UnCompressByteArray implements UnCompressValue<byte[]>
 {
+    public UnCompressByteArray(byteArrayType type)
+    {
+        if (type == byteArrayType.BYTE_ARRAY)
+        {
+            arrayType = byteArrayType.BYTE_ARRAY;
+        }
+        else
+        {
+            arrayType = byteArrayType.BIG_DECIMAL;
+        }
+
+    }
+
+    public static enum byteArrayType
+    {
+        BYTE_ARRAY,
+        BIG_DECIMAL
+    }
+
+    private byteArrayType arrayType;
+
     /**
      * byteCompressor.
      */
@@ -81,7 +106,7 @@ public class UnCompressByteArray implements UnCompressValue<byte[]>
     @Override
     public UnCompressValue compress()
     {
-        UnCompressByteArray byte1 = new UnCompressByteArray();
+        UnCompressByteArray byte1 = new UnCompressByteArray(arrayType);
         byte1.setValue(byteCompressor.compress(value));
         return byte1;
     }
@@ -89,7 +114,7 @@ public class UnCompressByteArray implements UnCompressValue<byte[]>
     @Override
     public UnCompressValue uncompress(DataType dataType)
     {
-        UnCompressValue byte1 = new UnCompressByteArray();
+        UnCompressValue byte1 = new UnCompressByteArray(arrayType);
         byte1.setValue(byteCompressor.unCompress(value));
         return byte1;
     }
@@ -103,11 +128,11 @@ public class UnCompressByteArray implements UnCompressValue<byte[]>
     @Override
     public UnCompressValue getCompressorObject()
     {
-        return new UnCompressByteArray();
+        return new UnCompressByteArray(arrayType);
     }
 
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
         List<byte[]> valsList = new ArrayList<byte[]>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
         ByteBuffer buffer = ByteBuffer.wrap(value);
@@ -121,10 +146,21 @@ public class UnCompressByteArray implements UnCompressValue<byte[]>
             actualValue = new byte[length];
             buffer.get(actualValue);
             valsList.add(actualValue);
-            
         }
         MolapReadDataHolder holder = new MolapReadDataHolder();
-        holder.setReadableByteValues(valsList.toArray(new byte[valsList.size()][]));
+        byte[][] value = new byte[valsList.size()][];
+        valsList.toArray(value);
+        if(arrayType == byteArrayType.BIG_DECIMAL)
+        {
+            BigDecimal[] bigDecimalValues = new BigDecimal[value.length];
+            for (int i = 0; i< value.length;i++)
+            {
+                bigDecimalValues[i] = DataTypeUtil.byteToBigDecimal(value[i]);
+            }
+            holder.setReadableBigDecimalValues(bigDecimalValues);
+            return holder;
+        }
+        holder.setReadableByteValues(value);
         return holder;
     }
 
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressDefaultLong.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressDefaultLong.java
new file mode 100644
index 0000000..5efc608
--- /dev/null
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressDefaultLong.java
@@ -0,0 +1,125 @@
+/**
+ *
+ * Copyright Notice
+ * =====================================
+ * This file contains proprietary information of
+ * Huawei Technologies India Pvt Ltd.
+ * Copying or reproduction without prior written approval is prohibited.
+ * Copyright (c) 2013
+ * =====================================
+ *
+ */
+package com.huawei.unibi.molap.datastorage.store.compression.type;
+
+import java.nio.ByteBuffer;
+
+import com.huawei.iweb.platform.logging.LogService;
+import com.huawei.iweb.platform.logging.LogServiceFactory;
+import com.huawei.unibi.molap.datastorage.store.compression.Compressor;
+import com.huawei.unibi.molap.datastorage.store.compression.SnappyCompression;
+import com.huawei.unibi.molap.datastorage.store.compression.ValueCompressonHolder.UnCompressValue;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+import com.huawei.unibi.molap.util.MolapCoreLogEvent;
+import com.huawei.unibi.molap.util.ValueCompressionUtil;
+import com.huawei.unibi.molap.util.ValueCompressionUtil.DataType;
+
+/**
+ * @author l00357089
+ */
+public class UnCompressDefaultLong implements UnCompressValue<long[]>
+{
+    /**
+     * longCompressor.
+     */
+    private static Compressor<long[]> longCompressor = SnappyCompression.SnappyLongCompression.INSTANCE;
+
+    /**
+     * Attribute for Molap LOGGER
+     */
+    private static final LogService LOGGER = LogServiceFactory.getLogService(UnCompressDefaultLong.class.getName());
+
+    /**
+     * value.
+     */
+    private long[] value;
+
+    @Override
+    public void setValue(long[] value)
+    {
+        this.value = value;
+    }
+//
+//    @Override
+//    public double getValue(int index, int decimal, double maxValue)
+//    {
+//        return value[index];
+//    }
+
+    //TODO SIMIAN
+    @Override
+    public UnCompressValue getNew()
+    {
+        try
+        {
+            return (UnCompressValue)clone();
+        }
+        catch(CloneNotSupportedException clnNotSupportedExc)
+        {
+            LOGGER.error(MolapCoreLogEvent.UNIBI_MOLAPCORE_MSG, clnNotSupportedExc, clnNotSupportedExc.getMessage());
+        }
+        return null;
+    }
+
+    @Override
+    public UnCompressValue compress()
+    {
+        UnCompressNoneByte byte1 = new UnCompressNoneByte();
+        byte1.setValue(longCompressor.compress(value));
+        return byte1;
+    }
+
+    @Override
+    public UnCompressValue uncompress(DataType dType)
+    {
+        return null;
+    }
+
+    @Override
+    public byte[] getBackArrayData()
+    {
+        return ValueCompressionUtil.convertToBytes(value);
+    }
+
+    @Override
+    public void setValueInBytes(byte[] byteValue)
+    {
+        ByteBuffer buffer = ByteBuffer.wrap(byteValue);
+        this.value = ValueCompressionUtil.convertToLongArray(buffer, byteValue.length);
+    }
+
+    /**
+     *
+     * @see com.huawei.unibi.molap.datastorage.store.compression.ValueCompressonHolder.UnCompressValue#getCompressorObject()
+     *
+     */
+    @Override
+    public UnCompressValue getCompressorObject()
+    {
+        return new UnCompressNoneByte();
+    }
+
+    @Override
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
+    {
+        MolapReadDataHolder dataHolder = new MolapReadDataHolder();
+        long[] vals = new long[value.length];
+//        System.arraycopy(value, 0, vals, 0, value.length);
+        for(int i = 0;i < vals.length;i++)
+        {
+            vals[i] = value[i];
+        }
+        dataHolder.setReadableLongValues(vals);
+        return dataHolder;
+    }
+
+}
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinByte.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinByte.java
index 80c6e99..c16ab12 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinByte.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinByte.java
@@ -118,8 +118,9 @@ public class UnCompressMaxMinByte implements UnCompressValue<byte[]>
     }
 
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
+        double maxValue = (double)maxValueObject;
         double[] vals = new double[value.length];
         MolapReadDataHolder dataHolder = new MolapReadDataHolder();
         for(int i = 0;i < vals.length;i++)
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinByteForLong.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinByteForLong.java
new file mode 100644
index 0000000..d023ee0
--- /dev/null
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinByteForLong.java
@@ -0,0 +1,140 @@
+/**
+ *
+ * Copyright Notice
+ * =====================================
+ * This file contains proprietary information of
+ * Huawei Technologies India Pvt Ltd.
+ * Copying or reproduction without prior written approval is prohibited.
+ * Copyright (c) 2013
+ * =====================================
+ *
+ */
+package com.huawei.unibi.molap.datastorage.store.compression.type;
+
+import com.huawei.iweb.platform.logging.LogService;
+import com.huawei.iweb.platform.logging.LogServiceFactory;
+import com.huawei.unibi.molap.datastorage.store.compression.Compressor;
+import com.huawei.unibi.molap.datastorage.store.compression.SnappyCompression;
+import com.huawei.unibi.molap.datastorage.store.compression.ValueCompressonHolder;
+import com.huawei.unibi.molap.datastorage.store.compression.ValueCompressonHolder.UnCompressValue;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+import com.huawei.unibi.molap.util.MolapCoreLogEvent;
+import com.huawei.unibi.molap.util.ValueCompressionUtil;
+import com.huawei.unibi.molap.util.ValueCompressionUtil.DataType;
+
+/**
+ * @author l00357089
+ */
+public class UnCompressMaxMinByteForLong implements UnCompressValue<byte[]>
+{
+
+    /**
+     * byteCompressor.
+     */
+    private static Compressor<byte[]> byteCompressor = SnappyCompression.SnappyByteCompression.INSTANCE;
+
+    /**
+     * Attribute for Molap LOGGER
+     */
+    private static final LogService LOGGER = LogServiceFactory.getLogService(UnCompressMaxMinByteForLong.class.getName());
+
+    @Override
+    public void setValue(byte[] value)
+    {
+        this.value = value;
+
+    }
+
+    //TODO SIMIAN
+
+    /**
+     * value.
+     */
+    private byte[] value;
+
+
+//    @Override
+//    public double getValue(int index, int decimal, double maxValue)
+//    {
+//        if(value[index] == 0)
+//        {
+//            return maxValue;
+//        }
+//        return maxValue - value[index];
+//    }
+
+    @Override
+    public UnCompressValue getNew()
+    {
+        try
+        {
+            return (UnCompressValue)clone();
+        }
+        catch(CloneNotSupportedException e)
+        {
+            LOGGER.error(MolapCoreLogEvent.UNIBI_MOLAPCORE_MSG, e, e.getMessage());
+        }
+        return null;
+    }
+
+    @Override
+    public UnCompressValue compress()
+    {
+
+        UnCompressMaxMinByteForLong byte1 = new UnCompressMaxMinByteForLong();
+        byte1.setValue(byteCompressor.compress(value));
+        return byte1;
+    }
+
+    @Override
+    public UnCompressValue uncompress(DataType dataType)
+    {
+        UnCompressValue byte1 = ValueCompressionUtil.unCompressMaxMin(dataType, dataType);
+        ValueCompressonHolder.unCompress(dataType, byte1, value);
+        return byte1;
+    }
+
+    @Override
+    public byte[] getBackArrayData()
+    {
+        return value;
+    }
+
+    @Override
+    public void setValueInBytes(byte[] value)
+    {
+        this.value = value;
+    }
+
+    /**
+     *
+     * @see com.huawei.unibi.molap.datastorage.store.compression.ValueCompressonHolder.UnCompressValue#getCompressorObject()
+     *
+     */
+    @Override
+    public UnCompressValue getCompressorObject()
+    {
+        return new UnCompressMaxMinByteForLong();
+    }
+
+    @Override
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
+    {
+        long maxValue = (long)maxValueObject;
+        long[] vals = new long[value.length];
+        MolapReadDataHolder dataHolder = new MolapReadDataHolder();
+        for(int i = 0;i < vals.length;i++)
+        {
+            if(value[i] == 0)
+            {
+                vals[i] = maxValue;
+            }
+            else
+            {
+                vals[i] = maxValue - value[i];
+            }
+        }
+        dataHolder.setReadableLongValues(vals);
+        return dataHolder;
+    }
+}
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinDefault.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinDefault.java
index d21007a..c7b6fea 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinDefault.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinDefault.java
@@ -118,8 +118,9 @@ public class UnCompressMaxMinDefault implements UnCompressValue<double[]>
  
     //TODO SIMIAN
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
+        double maxValue = (double)maxValueObject;
         double[] vals = new double[value.length];
         MolapReadDataHolder dataHolderInfoObj = new MolapReadDataHolder();
         for(int i = 0;i < vals.length;i++)
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinDefaultLong.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinDefaultLong.java
new file mode 100644
index 0000000..3c44fc2
--- /dev/null
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinDefaultLong.java
@@ -0,0 +1,142 @@
+/**
+ *
+ * Copyright Notice
+ * =====================================
+ * This file contains proprietary information of
+ * Huawei Technologies India Pvt Ltd.
+ * Copying or reproduction without prior written approval is prohibited.
+ * Copyright (c) 2013
+ * =====================================
+ *
+ */
+package com.huawei.unibi.molap.datastorage.store.compression.type;
+
+import java.nio.ByteBuffer;
+
+import com.huawei.iweb.platform.logging.LogService;
+import com.huawei.iweb.platform.logging.LogServiceFactory;
+import com.huawei.unibi.molap.datastorage.store.compression.Compressor;
+import com.huawei.unibi.molap.datastorage.store.compression.SnappyCompression;
+import com.huawei.unibi.molap.datastorage.store.compression.ValueCompressonHolder.UnCompressValue;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+import com.huawei.unibi.molap.util.MolapCoreLogEvent;
+import com.huawei.unibi.molap.util.ValueCompressionUtil;
+import com.huawei.unibi.molap.util.ValueCompressionUtil.DataType;
+
+/**
+ * @author 00357089
+ */
+public class UnCompressMaxMinDefaultLong implements UnCompressValue<long[]>
+{
+
+    /**
+     * Attribute for Molap LOGGER
+     */
+    private static final LogService LOGGER = LogServiceFactory.getLogService(UnCompressMaxMinDefaultLong.class.getName());
+
+    /**
+     * longCompressor.
+     */
+    private static Compressor<long[]> longCompressor = SnappyCompression.SnappyLongCompression.INSTANCE;
+
+
+
+//    @Override
+//    public double getValue(int index, int decimal, double maxValue)
+//    {
+//        if(value[index] == 0)
+//        {
+//            return maxValue;
+//        }
+//        return maxValue - value[index];
+//    }
+
+    @Override
+    public void setValue(long[] value)
+    {
+        this.value = value;
+
+    }
+    //TODO SIMIAN
+    /**
+     * value.
+     */
+    private long[] value;
+
+    //TODO SIMIAN
+    @Override
+    public UnCompressValue getNew()
+    {
+        try
+        {
+            return (UnCompressValue)clone();
+        }
+        catch(CloneNotSupportedException ex5)
+        {
+            LOGGER.error(MolapCoreLogEvent.UNIBI_MOLAPCORE_MSG, ex5, ex5.getMessage());
+        }
+        return null;
+    }
+
+    @Override
+    public UnCompressValue compress()
+    {
+        UnCompressMaxMinByteForLong byte1 = new UnCompressMaxMinByteForLong();
+        byte1.setValue(longCompressor.compress(value));
+        return byte1;
+    }
+
+    @Override
+    public UnCompressValue uncompress(DataType dataType)
+    {
+        return null;
+    }
+
+    @Override
+    public byte[] getBackArrayData()
+    {
+        return ValueCompressionUtil.convertToBytes(value);
+    }
+
+    @Override
+    public void setValueInBytes(byte[] value)
+    {
+        ByteBuffer buffer = ByteBuffer.wrap(value);
+        this.value = ValueCompressionUtil.convertToLongArray(buffer, value.length);
+    }
+
+    /**
+     *
+     * @see com.huawei.unibi.molap.datastorage.store.compression.ValueCompressonHolder.UnCompressValue#getCompressorObject()
+     *
+     */
+    @Override
+    public UnCompressValue getCompressorObject()
+    {
+        return new UnCompressMaxMinByteForLong();
+    }
+
+    //TODO SIMIAN
+    @Override
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
+    {
+        long maxValue = (long)maxValueObject;
+        long[] vals = new long[value.length];
+        MolapReadDataHolder dataHolderInfoObj = new MolapReadDataHolder();
+        for(int i = 0;i < vals.length;i++)
+        {
+            if(value[i] == 0)
+            {
+                vals[i] = maxValue;
+            }
+            else
+            {
+                vals[i] =  maxValue - value[i];
+            }
+
+        }
+        dataHolderInfoObj.setReadableLongValues(vals);
+        return dataHolderInfoObj;
+    }
+
+}
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinFloat.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinFloat.java
index 80181d5..87fdf05 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinFloat.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinFloat.java
@@ -118,8 +118,9 @@ public class UnCompressMaxMinFloat implements UnCompressValue<float[]>
     
     //TODO SIMIAN
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
+        double maxValue = (double)maxValueObject;
         double[] vals = new double[value.length];
         MolapReadDataHolder dataHolderVal = new MolapReadDataHolder();
         for(int i = 0;i < vals.length;i++)
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinInt.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinInt.java
index 4e9452a..b61d6bd 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinInt.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinInt.java
@@ -117,8 +117,9 @@ public class UnCompressMaxMinInt implements UnCompressValue<int[]>
     
     //TODO SIMIAN
     @Override
-    public MolapReadDataHolder getValues(int decVal, double maxValue)
+    public MolapReadDataHolder getValues(int decVal, Object maxValueObject)
     {
+        double maxValue = (double)maxValueObject;
         double[] vals = new double[value.length];
         MolapReadDataHolder dataHolder = new MolapReadDataHolder();
         for(int i = 0;i < vals.length;i++)
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinLong.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinLong.java
index 1fd7472..e7b8887 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinLong.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinLong.java
@@ -119,8 +119,9 @@ public class UnCompressMaxMinLong implements UnCompressValue<long[]>
     
    //TODO SIMIAN
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
+        double maxValue = (double)maxValueObject;
         double[] vals = new double[value.length];
         MolapReadDataHolder data = new MolapReadDataHolder();
         for(int i = 0;i < vals.length;i++)
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinShort.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinShort.java
index 4d3531a..564e81c 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinShort.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressMaxMinShort.java
@@ -118,8 +118,9 @@ public class UnCompressMaxMinShort implements UnCompressValue<short[]>
 
     //TODO SIMIAN
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
+        double maxValue = (double)maxValueObject;
         double[] vals = new double[value.length];
         MolapReadDataHolder molapDataHolderObj = new MolapReadDataHolder();
         for(int i = 0;i < vals.length;i++)
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalByte.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalByte.java
index 76d986c..04d1b6b 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalByte.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalByte.java
@@ -108,7 +108,7 @@ public class UnCompressNonDecimalByte implements UnCompressValue<byte[]>
     }
     
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
         double[] vals = new double[value.length];
         MolapReadDataHolder dataHolder = new MolapReadDataHolder();
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalDefault.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalDefault.java
index 30a9e52..06d2596 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalDefault.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalDefault.java
@@ -112,7 +112,7 @@ public class UnCompressNonDecimalDefault implements UnCompressValue<double[]>
     }
     
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
         double[] dblVals = new double[value.length]; 
         for(int i = 0;i < dblVals.length;i++)
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalFloat.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalFloat.java
index 04e0207..5dc06b1 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalFloat.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalFloat.java
@@ -113,7 +113,7 @@ public class UnCompressNonDecimalFloat implements UnCompressValue<float[]>
     }
     //TODO SIMIAN
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
         double[] vals = new double[value.length];
         for(int m = 0;m < vals.length;m++)  
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalInt.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalInt.java
index 2451328..e263743 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalInt.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalInt.java
@@ -105,7 +105,7 @@ public class UnCompressNonDecimalInt implements UnCompressValue<int[]>
     }
     
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
         double[] vals = new double[value.length];
         for(int k = 0;k < vals.length;k++)  
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalLong.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalLong.java
index 4bc8b2f..4a71664 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalLong.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalLong.java
@@ -112,7 +112,7 @@ public class UnCompressNonDecimalLong implements UnCompressValue<long[]>
     }
     
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
         double[] vals = new double[value.length];
         for(int i = 0;i < vals.length;i++)
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinByte.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinByte.java
index 52fa922..def3fd6 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinByte.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinByte.java
@@ -108,8 +108,9 @@ public class UnCompressNonDecimalMaxMinByte implements UnCompressValue<byte[]>
 
     
     @Override
-    public MolapReadDataHolder getValues(int decimalVal, double maxValue)
+    public MolapReadDataHolder getValues(int decimalVal, Object maxValueObject)
     {
+        double maxValue = (double)maxValueObject;
         double[] vals = new double[value.length];
         MolapReadDataHolder dataHolder = new MolapReadDataHolder();
         for(int i = 0;i < vals.length;i++)
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinDefault.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinDefault.java
index 986f339..1b16b86 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinDefault.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinDefault.java
@@ -117,8 +117,9 @@ public class UnCompressNonDecimalMaxMinDefault implements UnCompressValue<double
 
     
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxVal)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
+        double maxVal = (double)maxValueObject;
         double[] vals = new double[value.length];
         MolapReadDataHolder holder = new MolapReadDataHolder();
         for(int i = 0;i < vals.length;i++)
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinFloat.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinFloat.java
index 0565d87..16a9cfb 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinFloat.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinFloat.java
@@ -120,8 +120,9 @@ public class UnCompressNonDecimalMaxMinFloat implements UnCompressValue<float[]>
     }
     
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
+        double maxValue = (double)maxValueObject;
         double[] vals = new double[value.length];
         MolapReadDataHolder holder = new MolapReadDataHolder();
         for(int i = 0;i < vals.length;i++)
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinInt.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinInt.java
index 4812599..3cb1ca0 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinInt.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinInt.java
@@ -112,8 +112,9 @@ public class UnCompressNonDecimalMaxMinInt implements UnCompressValue<int[]>
     }
     
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
+        double maxValue = (double)maxValueObject;
         double[] vals = new double[value.length];
         MolapReadDataHolder dataHolderInfo= new MolapReadDataHolder();
         for(int i = 0;i < vals.length;i++)
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinLong.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinLong.java
index b8e21c1..a4562ac 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinLong.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinLong.java
@@ -119,8 +119,9 @@ public class UnCompressNonDecimalMaxMinLong implements UnCompressValue<long[]>
     }
     
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
+        double maxValue = (double)maxValueObject;
         double[] vals = new double[value.length];
         MolapReadDataHolder molapDataHolder= new MolapReadDataHolder();
         for(int i = 0;i < vals.length;i++)
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinShort.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinShort.java
index 3683ece..9f86163 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinShort.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalMaxMinShort.java
@@ -116,8 +116,9 @@ public class UnCompressNonDecimalMaxMinShort implements UnCompressValue<short[]>
     }
     
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
+        double maxValue = (double)maxValueObject;
         double[] vals = new double[value.length];
         MolapReadDataHolder dataHolder= new MolapReadDataHolder();
         for(int i = 0;i < vals.length;i++)
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalShort.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalShort.java
index de6efc2..86a5e29 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalShort.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNonDecimalShort.java
@@ -115,7 +115,7 @@ public class UnCompressNonDecimalShort implements UnCompressValue<short[]>
     }
     
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
         MolapReadDataHolder dataHolder = new MolapReadDataHolder();
         double[] vals = new double[value.length];
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneByte.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneByte.java
index 5b890f6..d4e5db2 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneByte.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneByte.java
@@ -113,7 +113,7 @@ public class UnCompressNoneByte implements UnCompressValue<byte[]>
     
     //TODO SIMIAN
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
         MolapReadDataHolder dataHldr = new MolapReadDataHolder();   
         double[] vals = new double[value.length];
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneDefault.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneDefault.java
index 99a3197..cb42caa 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneDefault.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneDefault.java
@@ -113,7 +113,7 @@ public class UnCompressNoneDefault implements UnCompressValue<double[]>
     }
     
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
         MolapReadDataHolder dataHolder = new MolapReadDataHolder();
         dataHolder.setReadableDoubleValues(value);
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneFloat.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneFloat.java
index 0cdc8bc..c815795 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneFloat.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneFloat.java
@@ -100,7 +100,7 @@ public class UnCompressNoneFloat implements UnCompressValue<float[]>
     }
     
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
         double[] vals = new double[value.length];
 //        System.arraycopy(value, 0, vals, 0, vals.length);
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneInt.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneInt.java
index dd2d79e..095b320 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneInt.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneInt.java
@@ -113,7 +113,7 @@ public class UnCompressNoneInt implements UnCompressValue<int[]>
     
     //TODO SIMIAN
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
         MolapReadDataHolder dataHolderInfoObj = new MolapReadDataHolder();  
         double[] vals = new double[value.length];
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneLong.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneLong.java
index b51d2ac..be41775 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneLong.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneLong.java
@@ -111,7 +111,7 @@ public class UnCompressNoneLong implements UnCompressValue<long[]>
     }
     
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
         MolapReadDataHolder dataHolder = new MolapReadDataHolder();
         double[] vals = new double[value.length];
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneShort.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneShort.java
index 39c5717..57420b8 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneShort.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/compression/type/UnCompressNoneShort.java
@@ -113,7 +113,7 @@ public class UnCompressNoneShort implements UnCompressValue<short[]>
     }
     
     @Override
-    public MolapReadDataHolder getValues(int decimal, double maxValue)
+    public MolapReadDataHolder getValues(int decimal, Object maxValueObject)
     {
         MolapReadDataHolder dataHolder= new MolapReadDataHolder();
         double[] vals = new double[shortValue.length];
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/dataholder/AbstractWriteDataHolder.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/dataholder/AbstractWriteDataHolder.java
new file mode 100644
index 0000000..e44ab84
--- /dev/null
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/dataholder/AbstractWriteDataHolder.java
@@ -0,0 +1,110 @@
+/**
+ * 
+ */
+package com.huawei.unibi.molap.datastorage.store.dataholder;
+
+/**
+ * @author m00258959
+ *
+ */
+public abstract class AbstractWriteDataHolder
+{
+
+    /**
+     * byteValues
+     */
+    protected byte[][] byteValues;
+    
+    /**
+     * size
+     */
+    protected int size;
+    
+    /**
+     * totalSize
+     */
+    protected int totalSize;
+    
+    /**
+     * method to initialise byte array
+     * @param size
+     */
+    public void initialiseByteArrayValues(int size)
+    {
+        if(size<1)
+        {
+            throw new IllegalArgumentException("Invalid array size");
+        }
+        
+        byteValues= new byte[size][];
+    }
+    
+    /**
+     * set byte array value by index
+     * @param index
+     * @param value
+     */
+    public void setWritableByteArrayValueByIndex(int index, byte[] value)
+    {
+        byteValues[index]=value;
+        size++;
+        totalSize+=value.length;
+    }
+    
+    public byte[][] getByteArrayValues()
+    {
+        if(size<byteValues.length)
+        {
+            byte[][] temp = new byte[size][];
+            System.arraycopy(byteValues, 0, temp, 0, size);
+            byteValues=temp;
+        }
+        return byteValues;
+    }
+    
+    public void reset()
+    {
+        size=0;
+        totalSize=0;
+    }
+    
+    /**
+     * Get writable byte array values
+     * @return
+     */
+    public byte[] getWritableByteArrayValues()
+    {
+        byte[] temp = new byte[totalSize];
+        int startIndexToCopy=0;
+        for(int i = 0;i < size;i++)
+        {
+            System.arraycopy(byteValues[i], 0, temp, startIndexToCopy, byteValues[i].length);
+            startIndexToCopy+=byteValues[i].length;
+        }
+        return temp;
+    }
+    
+    /**
+     * Method to initialise double array
+     * @param size
+     */
+    public abstract void initialiseValues(int size);
+    
+    /**
+     * set double value by index
+     * @param index
+     * @param value
+     */
+    public abstract void setWritableValueByIndex(int index,Object value);
+    
+    /**
+     * @return
+     */
+    public abstract double[] getWritableDoubleValues();
+    
+    /**
+     * @return
+     */
+    public abstract long[] getWritableLongValues();
+    
+}
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/dataholder/MolapReadDataHolder.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/dataholder/MolapReadDataHolder.java
index 7f9273d..7cf2043 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/dataholder/MolapReadDataHolder.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/dataholder/MolapReadDataHolder.java
@@ -11,6 +11,8 @@
  */
 package com.huawei.unibi.molap.datastorage.store.dataholder;
 
+import java.math.BigDecimal;
+
 /**
  * Project Name NSE V3R8C10 
  * Module Name : MOLAP Data Processor
@@ -27,6 +29,16 @@ public class MolapReadDataHolder
      * doubleValues
      */
     private double[] doubleValues;
+
+    /**
+     * longValues
+     */
+    private long[] longValues;
+
+    /**
+     * bigDecimalValues
+     */
+    private BigDecimal[] bigDecimalValues;
     
     /**
      * byteValues
@@ -58,6 +70,22 @@ public class MolapReadDataHolder
     }
 
     /**
+     * @param longValues the longValues to set
+     */
+    public void setReadableLongValues(long[] longValues)
+    {
+        this.longValues = longValues;
+    }
+
+    /**
+     * @param longValues the bigDecimalValues to set
+     */
+    public void setReadableBigDecimalValues(BigDecimal[] bigDecimalValues)
+    {
+        this.bigDecimalValues = bigDecimalValues;
+    }
+
+    /**
      * @param byteValues the byteValues to set
      */
     public void setReadableByteValues(byte[][] byteValues)
@@ -74,7 +102,16 @@ public class MolapReadDataHolder
     {
         return this.doubleValues[index];
     }
-    
+
+    public long getReadableLongValueByIndex(int index)
+    {
+        return this.longValues[index];
+    }
+
+    public BigDecimal getReadableBigDecimalValueByIndex(int index)
+    {
+        return this.bigDecimalValues[index];
+    }
     /**
      * below method will be used to get the readable byte array value by index
      * @param index
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/dataholder/MolapWriteDataHolder.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/dataholder/MolapWriteDataHolder.java
index b87e446..ddf78e0 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/dataholder/MolapWriteDataHolder.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/dataholder/MolapWriteDataHolder.java
@@ -20,7 +20,7 @@ package com.huawei.unibi.molap.datastorage.store.dataholder;
  * Class Description : data holder which will be used by all the classes when they want to write the data 
  * Class Version 1.0
  */
-public class MolapWriteDataHolder
+public class MolapWriteDataHolder extends AbstractWriteDataHolder
 {
     /**
      * doubleValues
@@ -28,30 +28,11 @@ public class MolapWriteDataHolder
     private double[] doubleValues;
     
     /**
-     * byteValues
-     */
-    private byte[][] byteValues;
-
-    /**
-     * byteValues
-     */
-    private byte[][][] columnByteValues;
-    
-    /**
-     * size
-     */
-    private int size;
-    
-    /**
-     * totalSize
-     */
-    private int totalSize;
-    
-    /**
      * Method to initialise double array
      * @param size
      */
-    public void initialiseDoubleValues(int size)
+    @Override
+    public void initialiseValues(int size)
     {
         if(size<1)
         {
@@ -61,62 +42,22 @@ public class MolapWriteDataHolder
     }
     
     /**
-     * method to initialise byte array
-     * @param size
-     */
-    public void initialiseByteArrayValues(int size)
-    {
-        if(size<1)
-        {
-            throw new IllegalArgumentException("Invalid array size");
-        }
-        
-        byteValues= new byte[size][];
-        columnByteValues= new byte[size][][];
-    }
-    /**
      * set double value by index
      * @param index
      * @param value
      */
-    public void setWritableDoubleValueByIndex(int index,double value)
+    @Override
+    public void setWritableValueByIndex(int index,Object value)
     {
-        doubleValues[index]=value;
+        doubleValues[index]=(Double)value;
         size++;
     }
     
     /**
-     * set byte array value by index
-     * @param index
-     * @param value
-     */
-    public void setWritableByteArrayValueByIndex(int index, byte[] value)
-    {
-        byteValues[index]=value;
-        size++;
-        if(null != value)
-        totalSize+=value.length;
-    }
-
-    /**
-     * set byte array value by index
-     * @param index
-     * @param value
-     */
-    public void setWritableByteArrayValueByIndex(int index, int mdKeyIndex, Object[] columnData)
-    {
-        int l=0;
-        columnByteValues[index] = new byte[columnData.length - (mdKeyIndex+1)][];
-        for(int i=mdKeyIndex+1;i<columnData.length;i++)
-        {
-            columnByteValues[index][l++]=(byte[])columnData[i];
-        }
-    }
-    
-    /**
      * Get Writable Double Values
      * @return
      */
+    @Override
     public double[] getWritableDoubleValues()
     {
         if(size<doubleValues.length)
@@ -127,48 +68,12 @@ public class MolapWriteDataHolder
         }
         return doubleValues;
     }
-    
-    /**
-     * Get writable byte array values
-     * @return
-     */
-    public byte[] getWritableByteArrayValues()
-    {
-        byte[] temp = new byte[totalSize];
-        int startIndexToCopy=0;
-        for(int i = 0;i < size;i++)
-        {
-            System.arraycopy(byteValues[i], 0, temp, startIndexToCopy, byteValues[i].length);
-            startIndexToCopy+=byteValues[i].length;
-        }
-        return temp;
-    }
-    
-    public byte[][] getByteArrayValues()
-    {
-        if(size<byteValues.length)
-        {
-            byte[][] temp = new byte[size][];
-            System.arraycopy(byteValues, 0, temp, 0, size);
-            byteValues=temp;
-        }
-        return byteValues;
-    }
-    
-    public byte[][][] getColumnByteArrayValues()
+
+    @Override
+    public long[] getWritableLongValues()
     {
-        if(size<columnByteValues.length)
-        {
-            byte[][][] temp = new byte[size][][];
-            System.arraycopy(columnByteValues, 0, temp, 0, size);
-            columnByteValues=temp;
-        }
-        return columnByteValues;
+        // TODO Auto-generated method stub
+        return null;
     }
     
-    public void reset()
-    {
-        size=0;
-        totalSize=0;
-    }
 }
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/dataholder/MolapWriteLongDataHolder.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/dataholder/MolapWriteLongDataHolder.java
new file mode 100644
index 0000000..bab59cc
--- /dev/null
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/dataholder/MolapWriteLongDataHolder.java
@@ -0,0 +1,67 @@
+/**
+ * 
+ */
+package com.huawei.unibi.molap.datastorage.store.dataholder;
+
+/**
+ * @author m00258959
+ *
+ */
+public class MolapWriteLongDataHolder extends AbstractWriteDataHolder
+{
+
+    /**
+     * doubleValues
+     */
+    private long[] longValues;
+    
+    /**
+     * Method to initialise double array
+     * @param size
+     */
+    @Override
+    public void initialiseValues(int size)
+    {
+        if(size<1)
+        {
+            throw new IllegalArgumentException("Invalid array size");
+        }
+        longValues= new long[size];
+    }
+    
+    /**
+     * set double value by index
+     * @param index
+     * @param value
+     */
+    @Override
+    public void setWritableValueByIndex(int index,Object value)
+    {
+        longValues[index]=(Long)value;
+        size++;
+    }
+    
+    @Override
+    public double[] getWritableDoubleValues()
+    {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    /**
+     * Get Writable Double Values
+     * @return
+     */
+    @Override
+    public long[] getWritableLongValues()
+    {
+        if(size<longValues.length)
+        {
+            long[]temp = new long[size];
+            System.arraycopy(longValues, 0, temp, 0, size);
+            longValues=temp;
+        }
+        return longValues;
+    }
+    
+}
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/fileperations/AtomicFileOperations.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/fileperations/AtomicFileOperations.java
deleted file mode 100644
index 205cc70..0000000
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/fileperations/AtomicFileOperations.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/**
- * 
- */
-package com.huawei.unibi.molap.datastorage.store.fileperations;
-
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-
-/**
- * @author R00903928
- *
- */
-public interface AtomicFileOperations
-{
-
-    /**
-     * 
-     * @return
-     * @throws IOException
-     */
-    DataInputStream openForRead() throws IOException;
-    
-    /**
-     * @throws IOException 
-     * 
-     */
-    void close() throws IOException;
-
-    /**
-     * 
-     * @param operation
-     * @return
-     * @throws IOException
-     */
-    DataOutputStream openForWrite(FileWriteOperation operation) throws IOException;
-}
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/fileperations/AtomicFileOperationsImpl.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/fileperations/AtomicFileOperationsImpl.java
deleted file mode 100644
index eab0d05..0000000
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/fileperations/AtomicFileOperationsImpl.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/**
- * 
- */
-package com.huawei.unibi.molap.datastorage.store.fileperations;
-
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-
-import com.huawei.unibi.molap.constants.MolapCommonConstants;
-import com.huawei.unibi.molap.datastorage.store.filesystem.MolapFile;
-import com.huawei.unibi.molap.datastorage.store.impl.FileFactory;
-import com.huawei.unibi.molap.datastorage.store.impl.FileFactory.FileType;
-import com.huawei.unibi.molap.util.MolapUtil;
-
-/**
- * @author R00903928
- *
- */
-public class AtomicFileOperationsImpl implements AtomicFileOperations
-{
-    
-    private String filePath;
-    
-    private FileType fileType;
-    
-    private String tempWriteFilePath;
-    
-    private DataOutputStream dataOutStream;
-    
-    /**
-     * 
-     * @param filePath
-     * @param fileType
-     */
-    public AtomicFileOperationsImpl(String filePath , FileType fileType)
-    {
-        this.filePath = filePath;
-        
-        this.fileType = fileType;
-    }
-    
-
-    /**
-     * 
-     * @return DataInputStream
-     * @throws IOException
-     */
-    @Override
-    public DataInputStream openForRead() throws IOException
-    {
-        return FileFactory.getDataInputStream(filePath, fileType);
-    }
-
-    /**
-     * 
-     * @param operation
-     * @return DataOutputStream
-     * @throws IOException
-     */
-    @Override
-    public DataOutputStream openForWrite(FileWriteOperation operation) throws IOException
-    {
-
-        filePath = filePath.replace("\\", "/");
-
-        tempWriteFilePath = filePath + MolapCommonConstants.TEMPWRITEFILEEXTENSION;
-
-        if(FileFactory.isFileExist(tempWriteFilePath, fileType))
-        {
-            FileFactory.getMolapFile(tempWriteFilePath, fileType).delete();
-        }
-
-        FileFactory.createNewFile(tempWriteFilePath, fileType);
-
-        dataOutStream =  FileFactory.getDataOutputStream(tempWriteFilePath, fileType);
-        
-        return dataOutStream;
-
-    }
-
-    /* (non-Javadoc)
-     * @see com.huawei.unibi.molap.datastorage.store.fileperations.AtomicFileOperations#close()
-     */
-    @Override
-    public void close() throws IOException
-    {
-     
-        if(null != dataOutStream)
-        {
-            dataOutStream.close();
-
-            MolapFile tempFile = FileFactory.getMolapFile(tempWriteFilePath, fileType);
-
-            if(!tempFile.renameForce(filePath))
-            {
-                throw new IOException("temporary file renaming failed");
-            }
-        }
-                
-    }
-
-}
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/fileperations/FileWriteOperation.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/fileperations/FileWriteOperation.java
deleted file mode 100644
index dc21768..0000000
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/fileperations/FileWriteOperation.java
+++ /dev/null
@@ -1,13 +0,0 @@
-/**
- * 
- */
-package com.huawei.unibi.molap.datastorage.store.fileperations;
-
-/**
- * @author R00903928
- *
- */
-public enum FileWriteOperation {
-    
-    APPEND,OVERWRITE
-}
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/impl/data/compressed/AbstractHeavyCompressedDoubleArrayDataStore.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/impl/data/compressed/AbstractHeavyCompressedDoubleArrayDataStore.java
index 5cb55e8..3b816a9 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/impl/data/compressed/AbstractHeavyCompressedDoubleArrayDataStore.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/impl/data/compressed/AbstractHeavyCompressedDoubleArrayDataStore.java
@@ -12,9 +12,11 @@
 
 package com.huawei.unibi.molap.datastorage.store.impl.data.compressed;
 
+import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.datastorage.store.NodeMeasureDataStore;
 import com.huawei.unibi.molap.datastorage.store.compression.ValueCompressionModel;
 import com.huawei.unibi.molap.datastorage.store.compression.ValueCompressonHolder.UnCompressValue;
+import com.huawei.unibi.molap.datastorage.store.dataholder.AbstractWriteDataHolder;
 import com.huawei.unibi.molap.datastorage.store.dataholder.MolapWriteDataHolder;
 import com.huawei.unibi.molap.util.ValueCompressionUtil;
 
@@ -163,16 +165,25 @@ public abstract class AbstractHeavyCompressedDoubleArrayDataStore implements Nod
 //    }
     
     @Override
-    public byte[][] getWritableMeasureDataArray(MolapWriteDataHolder[] dataHolder)
+    public byte[][] getWritableMeasureDataArray(AbstractWriteDataHolder[] dataHolder)
     {
         for(int i = 0;i < compressionModel.getUnCompressValues().length;i++)
         {
             values[i] = compressionModel.getUnCompressValues()[i].getNew();
-            if(type[i]!='c')
+            if(type[i]!=MolapCommonConstants.BYTE_VALUE_MEASURE && type[i] != MolapCommonConstants.BIG_DECIMAL_MEASURE)
             {
-                values[i].setValue(ValueCompressionUtil.getCompressedValues(compressionModel.getCompType()[i],
-                        dataHolder[i].getWritableDoubleValues(), compressionModel.getChangedDataType()[i],
-                        compressionModel.getMaxValue()[i], compressionModel.getDecimal()[i]));
+                if(type[i] == MolapCommonConstants.BIG_INT_MEASURE)
+                {
+                    values[i].setValue(ValueCompressionUtil.getCompressedValues(compressionModel.getCompType()[i],
+                            dataHolder[i].getWritableLongValues(), compressionModel.getChangedDataType()[i],
+                            (long)compressionModel.getMaxValue()[i], compressionModel.getDecimal()[i]));
+                }
+                else
+                {
+                    values[i].setValue(ValueCompressionUtil.getCompressedValues(compressionModel.getCompType()[i],
+                            dataHolder[i].getWritableDoubleValues(), compressionModel.getChangedDataType()[i],
+                            (double)compressionModel.getMaxValue()[i], compressionModel.getDecimal()[i]));
+                }
             }
             else
             {
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/impl/data/uncompressed/AbstractDoubleArrayDataStore.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/impl/data/uncompressed/AbstractDoubleArrayDataStore.java
index 95d2c7c..8d6a6e8 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/impl/data/uncompressed/AbstractDoubleArrayDataStore.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/impl/data/uncompressed/AbstractDoubleArrayDataStore.java
@@ -1,8 +1,10 @@
 package com.huawei.unibi.molap.datastorage.store.impl.data.uncompressed;
 
+import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.datastorage.store.NodeMeasureDataStore;
 import com.huawei.unibi.molap.datastorage.store.compression.ValueCompressionModel;
 import com.huawei.unibi.molap.datastorage.store.compression.ValueCompressonHolder.UnCompressValue;
+import com.huawei.unibi.molap.datastorage.store.dataholder.AbstractWriteDataHolder;
 import com.huawei.unibi.molap.datastorage.store.dataholder.MolapWriteDataHolder;
 import com.huawei.unibi.molap.util.ValueCompressionUtil;
 
@@ -91,17 +93,26 @@ public abstract class  AbstractDoubleArrayDataStore implements NodeMeasureDataSt
 //    }
 
     @Override
-    public byte[][]getWritableMeasureDataArray(MolapWriteDataHolder[] dataHolder)
+    public byte[][]getWritableMeasureDataArray(AbstractWriteDataHolder[] dataHolder)
     {
         values = new UnCompressValue[compressionModel.getUnCompressValues().length];
         for(int i = 0;i < compressionModel.getUnCompressValues().length;i++)
         {
             values[i] = compressionModel.getUnCompressValues()[i].getNew();
-            if(type[i]!='c')
+            if(type[i]!=MolapCommonConstants.BYTE_VALUE_MEASURE && type[i] != MolapCommonConstants.BIG_DECIMAL_MEASURE)
             {
-                values[i].setValue(ValueCompressionUtil.getCompressedValues(compressionModel.getCompType()[i],
-                        dataHolder[i].getWritableDoubleValues(), compressionModel.getChangedDataType()[i],
-                        compressionModel.getMaxValue()[i], compressionModel.getDecimal()[i]));
+                if(type[i] == MolapCommonConstants.BIG_INT_MEASURE)
+                {
+                    values[i].setValue(ValueCompressionUtil.getCompressedValues(compressionModel.getCompType()[i],
+                            dataHolder[i].getWritableLongValues(), compressionModel.getChangedDataType()[i],
+                            (long)compressionModel.getMaxValue()[i], compressionModel.getDecimal()[i]));
+                }
+                else
+                {
+                    values[i].setValue(ValueCompressionUtil.getCompressedValues(compressionModel.getCompType()[i],
+                            dataHolder[i].getWritableDoubleValues(), compressionModel.getChangedDataType()[i],
+                            (double)compressionModel.getMaxValue()[i], compressionModel.getDecimal()[i]));
+                }
             }
             else
             {
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/impl/key/columnar/compressed/CompressedColumnarFileKeyStore.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/impl/key/columnar/compressed/CompressedColumnarFileKeyStore.java
index b0ee32d..475297a 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/impl/key/columnar/compressed/CompressedColumnarFileKeyStore.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/datastorage/store/impl/key/columnar/compressed/CompressedColumnarFileKeyStore.java
@@ -1,9 +1,5 @@
 package com.huawei.unibi.molap.datastorage.store.impl.key.columnar.compressed;
 
-import java.nio.ByteBuffer;
-import java.util.HashMap;
-import java.util.Map;
-
 import com.huawei.unibi.molap.datastorage.store.FileHolder;
 import com.huawei.unibi.molap.datastorage.store.columnar.ColumnarKeyStoreDataHolder;
 import com.huawei.unibi.molap.datastorage.store.columnar.ColumnarKeyStoreInfo;
@@ -40,7 +36,7 @@ public class CompressedColumnarFileKeyStore extends AbstractColumnarKeyStore
                     columnarStoreInfo.getFilePath(),
                     columnarStoreInfo.getKeyBlockOffsets()[blockIndex[i]],
                     columnarStoreInfo.getKeyBlockLengths()[blockIndex[i]]));
-            if(blockIndex[i]<=this.columnarStoreInfo.getAggKeyBlock().length-1 && this.columnarStoreInfo.getAggKeyBlock()[blockIndex[i]])
+            if(this.columnarStoreInfo.getAggKeyBlock()[blockIndex[i]])
             {
                 dataIndex= columnarStoreInfo
                 .getNumberCompressor()
@@ -79,22 +75,6 @@ public class CompressedColumnarFileKeyStore extends AbstractColumnarKeyStore
                                         .getKeyBlockIndexLength()[columnarKeyBlockIndex]), columnarStoreInfo.getNumberCompressor());
             	columnKeyBlockReverseIndexes=getColumnIndexForNonFilter(columnKeyBlockIndex);
             }
-            //Since its anhigh cardinality dimension
-            if(blockIndex[i]>this.columnarStoreInfo.getSizeOfEachBlock().length-1)
-            {
-                columnarKeyStoreMetadata = new ColumnarKeyStoreMetadata(0);
-                columnarKeyStoreMetadata.setColumnIndex(columnKeyBlockIndex);
-                columnarKeyStoreMetadata.setColumnReverseIndex(columnKeyBlockReverseIndexes);
-                columnarKeyStoreMetadata.setDirectSurrogateColumn(true);
-                columnarKeyStoreMetadata.setSorted(columnarStoreInfo.getIsSorted()[blockIndex[i]]);
-                //System is reading the direct surrogates data from byte array which contains both length and the
-                //direct surrogates data
-                mapColumnIndexWithKeyColumnarKeyBlockData(columnarKeyBlockData,columnarKeyStoreMetadata);
-                columnarKeyStoreDataHolders[i] = new ColumnarKeyStoreDataHolder(
-                        columnarKeyBlockData,columnarKeyStoreMetadata);
-            }
-            else
-            {
             columnarKeyStoreMetadata = new ColumnarKeyStoreMetadata(columnarStoreInfo.getSizeOfEachBlock()[blockIndex[i]]);
             columnarKeyStoreMetadata.setColumnIndex(columnKeyBlockIndex);
             columnarKeyStoreMetadata.setSorted(columnarStoreInfo.getIsSorted()[blockIndex[i]]);
@@ -103,38 +83,10 @@ public class CompressedColumnarFileKeyStore extends AbstractColumnarKeyStore
             columnarKeyStoreMetadata.setUnCompressed(isUnCompressed);
             columnarKeyStoreDataHolders[i] = new ColumnarKeyStoreDataHolder(
                     columnarKeyBlockData,columnarKeyStoreMetadata);
-            }
         }
         return columnarKeyStoreDataHolders;
     }
 
-    /**
-     * The high cardinality dimensions rows will be send in byte array with its data length
-     * appended in the ColumnarKeyStoreDataHolder byte array since high cardinality dim data will not be
-     * part of MDKey/Surrogate keys. In this method the byte array will be scanned and the length which is
-     * stored in short will be removed.
-     * @param key
-     * @param colIndex
-     * @param columnarKeyStoreDataHolder
-     */
-    private void mapColumnIndexWithKeyColumnarKeyBlockData(byte[] columnarKeyBlockData, ColumnarKeyStoreMetadata columnarKeyStoreMetadata)
-    {
-        Map<Integer,byte[]> mapOfColumnarKeyBlockData =new HashMap<Integer,byte[]>(50);
-        ByteBuffer directSurrogateKeyStoreDataHolder=ByteBuffer.allocate(columnarKeyBlockData.length);
-        directSurrogateKeyStoreDataHolder.put(columnarKeyBlockData);
-        directSurrogateKeyStoreDataHolder.flip();
-        int row=-1;
-        while(directSurrogateKeyStoreDataHolder.hasRemaining())
-        {
-            short dataLength = directSurrogateKeyStoreDataHolder.getShort();
-            byte [] directSurrKeyData=new byte[dataLength];
-            directSurrogateKeyStoreDataHolder.get(directSurrKeyData);
-            mapOfColumnarKeyBlockData.put(++row, directSurrKeyData);
-        }
-        columnarKeyStoreMetadata.setDirectSurrogateKeyMembers(mapOfColumnarKeyBlockData);
-        
-    }
-
     @Override
     public ColumnarKeyStoreDataHolder getUnCompressedKeyArray(FileHolder fileHolder, int blockIndex,
             boolean needCompressedData)
@@ -150,7 +102,7 @@ public class CompressedColumnarFileKeyStore extends AbstractColumnarKeyStore
                 .unCompress(fileHolder.readByteArray(columnarStoreInfo.getFilePath(),
                         columnarStoreInfo.getKeyBlockOffsets()[blockIndex],
                         columnarStoreInfo.getKeyBlockLengths()[blockIndex]));
-        if(blockIndex<=this.columnarStoreInfo.getAggKeyBlock().length-1 && this.columnarStoreInfo.getAggKeyBlock()[blockIndex])
+        if(this.columnarStoreInfo.getAggKeyBlock()[blockIndex])
         {
             dataIndex = columnarStoreInfo.getNumberCompressor().unCompress(
                     fileHolder.readByteArray(columnarStoreInfo.getFilePath(),
@@ -178,21 +130,6 @@ public class CompressedColumnarFileKeyStore extends AbstractColumnarKeyStore
                     columnarStoreInfo.getNumberCompressor());
             columnKeyBlockReverseIndex = getColumnIndexForNonFilter(columnKeyBlockIndex);
         }
-        
-        //Since its an high cardinality dimension, For filter queries.
-        if(blockIndex>this.columnarStoreInfo.getSizeOfEachBlock().length-1)
-        {
-            columnarKeyStoreMetadata = new ColumnarKeyStoreMetadata(0);
-            columnarKeyStoreMetadata.setDirectSurrogateColumn(true);
-            columnarKeyStoreMetadata.setColumnIndex(columnKeyBlockIndex);
-            columnarKeyStoreMetadata.setColumnReverseIndex(columnKeyBlockReverseIndex);
-            columnarKeyStoreMetadata.setSorted(columnarStoreInfo.getIsSorted()[blockIndex]);
-            columnarKeyStoreMetadata.setUnCompressed(true);
-            mapColumnIndexWithKeyColumnarKeyBlockData(columnarKeyBlockData,columnarKeyStoreMetadata);
-            ColumnarKeyStoreDataHolder columnarKeyStoreDataHolders = new ColumnarKeyStoreDataHolder(
-                    columnarKeyBlockData,columnarKeyStoreMetadata);
-            return columnarKeyStoreDataHolders;
-        }
         columnarKeyStoreMetadata = new ColumnarKeyStoreMetadata(columnarStoreInfo.getSizeOfEachBlock()[blockIndex]);
         columnarKeyStoreMetadata.setColumnIndex(columnKeyBlockIndex);
         columnarKeyStoreMetadata.setSorted(columnarStoreInfo.getIsSorted()[blockIndex]);
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/keygenerator/KeyGenerator.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/keygenerator/KeyGenerator.java
index 0f053f9..ad0c3c5 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/keygenerator/KeyGenerator.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/keygenerator/KeyGenerator.java
@@ -99,8 +99,4 @@ public interface KeyGenerator extends Serializable, Comparator<byte[]>
      * @return
      */
     int getDimCount();
-    
-    void setStartAndEndKeySizeWithOnlyPrimitives(int startAndEndKeySizeWithPrimitives);
-    
-    int getStartAndEndKeySizeWithOnlyPrimitives();
 }
\ No newline at end of file
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/keygenerator/columnar/impl/MultiDimKeyVarLengthEquiSplitGenerator.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/keygenerator/columnar/impl/MultiDimKeyVarLengthEquiSplitGenerator.java
index 2a4814a..79d060b 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/keygenerator/columnar/impl/MultiDimKeyVarLengthEquiSplitGenerator.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/keygenerator/columnar/impl/MultiDimKeyVarLengthEquiSplitGenerator.java
@@ -252,13 +252,9 @@ public class MultiDimKeyVarLengthEquiSplitGenerator extends MultiDimKeyVarLength
     public int getKeySizeByBlock(int[] blockIndexes)
     {
         int size=0;
-       
         for(int i = 0;i < blockIndexes.length;i++)
         {
-            if(blockIndexes[i] < blockKeySize.length)
-            {
-                size += blockKeySize[blockIndexes[i]];
-            }
+            size+=blockKeySize[blockIndexes[i]];
         }
         return size;
     }
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/keygenerator/mdkey/AbstractKeyGenerator.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/keygenerator/mdkey/AbstractKeyGenerator.java
index 04b3a53..ff21a67 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/keygenerator/mdkey/AbstractKeyGenerator.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/keygenerator/mdkey/AbstractKeyGenerator.java
@@ -84,5 +84,4 @@ public abstract class AbstractKeyGenerator implements KeyGenerator
         // TODO Auto-generated method stub
         return 0;
     }
-   
 }
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/keygenerator/mdkey/MultiDimKeyVarLengthGenerator.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/keygenerator/mdkey/MultiDimKeyVarLengthGenerator.java
index 1dfc295..1d1dc0a 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/keygenerator/mdkey/MultiDimKeyVarLengthGenerator.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/keygenerator/mdkey/MultiDimKeyVarLengthGenerator.java
@@ -25,8 +25,6 @@ public class MultiDimKeyVarLengthGenerator extends AbstractKeyGenerator
      * bits.
      */
     private Bits bits;
-    
-    private int startAndEndKeySizeWithPrimitives;
 
     /**
      * 
@@ -148,18 +146,6 @@ public class MultiDimKeyVarLengthGenerator extends AbstractKeyGenerator
         return bits.getKeyArray(key, maskedByteRanges);
     }
 
-    @Override
-    public void setStartAndEndKeySizeWithOnlyPrimitives(int startAndEndKeySizeWithPrimitives)
-    {
-        this.startAndEndKeySizeWithPrimitives = startAndEndKeySizeWithPrimitives;
-    }
-
-    @Override
-    public int getStartAndEndKeySizeWithOnlyPrimitives()
-    {
-        return startAndEndKeySizeWithPrimitives;
-    }
-
     /**
      * @param args
      * @throws MalformedURLException
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/metadata/MolapMetadata.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/metadata/MolapMetadata.java
index 88bb6b7..e669d13 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/metadata/MolapMetadata.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/metadata/MolapMetadata.java
@@ -29,7 +29,6 @@ import com.huawei.unibi.molap.olap.MolapDef.AggMeasure;
 import com.huawei.unibi.molap.olap.MolapDef.AggName;
 import com.huawei.unibi.molap.olap.MolapDef.AggTable;
 import com.huawei.unibi.molap.olap.MolapDef.Annotation;
-import com.huawei.unibi.molap.olap.MolapDef.CubeDimension;
 import com.huawei.unibi.molap.olap.MolapDef.Level;
 import com.huawei.unibi.molap.olap.MolapDef.Property;
 import com.huawei.unibi.molap.olap.MolapDef.Schema;
@@ -69,8 +68,6 @@ public final class MolapMetadata
     
     private final Lock writeLock = lock.writeLock();
 
-    public String parent;
-
     /**
      * create the instance of MolapMetadata.
      * @return MolapMetadata.
@@ -231,7 +228,7 @@ public final class MolapMetadata
      */
     public void loadCube(MolapDef.Schema schema,String orginalSchemaName, String orginalCubeName,MolapDef.Cube cube)
     {
-        Cube locCube = new Cube(schema, cube, orginalSchemaName, orginalCubeName);
+        Cube locCube = new Cube(schema.name, cube.name, orginalSchemaName, orginalCubeName);
         locCube.setOnlyCubeName(cube.name);
         String table = MolapSchemaReader.getFactTableName(cube);
         locCube.setFactTableName(table);
@@ -242,9 +239,9 @@ public final class MolapMetadata
         Map<String, String> levelsToColMap = loadMetaToCube(table, locCube, schema);
 
         List<Measure> measures = locCube.getMeasures(table);
-        prepareComplexDimensions(locCube.getDimensions(table));
-        HashMap<String, Measure> measuresMap = new HashMap<String, MolapMetadata.Measure>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
-        
+        HashMap<String, Measure> measuresMap = new HashMap<String, MolapMetadata.Measure>(
+                MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
+
         for(Measure measure : measures)
         {
             measuresMap.put("[Measures].[" + measure.getName() + ']', measure);
@@ -457,37 +454,7 @@ public final class MolapMetadata
         metaAggTableCols.add(aggTable.factcount.column);
         }
     }
-    
-    
-    private void prepareComplexDimensions(List<Dimension> currentDimTables)
-    {
-        Map<String, ArrayList<Dimension>> complexDimensions = new HashMap<String, ArrayList<Dimension>>();
-        for(int i = 0;i < currentDimTables.size();i++)
-        {
-            ArrayList<Dimension> dimensions = complexDimensions.get(currentDimTables.get(i).getHierName());
-            if(dimensions != null)
-            {
-                dimensions.add(currentDimTables.get(i));
-            }
-            else
-            {
-                dimensions = new ArrayList<Dimension>();
-                dimensions.add(currentDimTables.get(i));
-            }
-            complexDimensions.put(currentDimTables.get(i).getHierName(), dimensions);
-        }
-        
-        for (Map.Entry<String, ArrayList<Dimension>> entry : complexDimensions.entrySet())
-        {
-            int[] blockIndexsForEachComplexType = new int[entry.getValue().size()];
-            for(int i=0;i<entry.getValue().size();i++)
-            {
-                blockIndexsForEachComplexType[i] = entry.getValue().get(i).getDataBlockIndex();
-            }
-            entry.getValue().get(0).setAllApplicableDataBlockIndexs(blockIndexsForEachComplexType);
-        }
-    }
-    
+
     /**
      * Process all the dimensions and fact table.
      * @param table
@@ -525,7 +492,6 @@ public final class MolapMetadata
         int keyOrdinal;
         // index for normalizedList
         int indexNormalized = 0;
-        int blockIndex = 0;
         List<MolapMetadata.Dimension> normalizedDimList = new ArrayList<MolapMetadata.Dimension>(MolapCommonConstants.CONSTANT_SIZE_TEN);
         for(MondrianLevelHolder levHolder : levelList)
         {
@@ -544,24 +510,20 @@ public final class MolapMetadata
 //                keyOrdinal = lev.keyOrdinal;
 //            }
             keyOrdinal = inc<0?0:inc;
-            
             Dimension dimension = new Dimension(lev.column, keyOrdinal, lev.name,cube);
             dimension.setLevelType(type);
             //dimension.setNoOfbits((byte)Long.toBinaryString(lev.levelCardinality).length());
 //            dimension.setNoOfbits(lev.levelCardinality);
             dimension.setDataType(makeSQLDataTye(lev.type));
-            dimension.setParentName(lev.parentname);
             dimension.setOrdinalCol(false);
             dimension.setTableName(levHolder.molapTableName);
             dimension.setHierName(levHolder.molapHierName);
             dimension.setActualTableName(levHolder.actualTableName);
             dimension.setDimName(levHolder.molapDimName);
-            dimension.setDataBlockIndex(blockIndex++);
             boolean hasNameColumn = hasNameColumn(lev);
             
             dimension.setNameColumnIndex(getNameColumnIndexInSchemaOrder(levHolder, levelList));
             dimension.setPropertyIndexes(getPropertyColumnIndexes(levHolder, levelList));
-            updateDimensionWithHighCardinalityVal(dimension,schema.cubes[0].dimensions);
             
             // Update properties and its data types in dimension
             Property[] properties = lev.properties;
@@ -591,20 +553,6 @@ public final class MolapMetadata
         return levelToColumnMap;
     }
 
-    private void updateDimensionWithHighCardinalityVal(Dimension dimension, CubeDimension[] dimensions)
-    {
-        for(CubeDimension cubeDimension:dimensions)
-        {
-            if(dimension.getName().equals(cubeDimension.name) && cubeDimension.highCardinality)
-            {
-                dimension.setHighCardinalityDims(cubeDimension.highCardinality);
-                break;
-            }
-            
-        }
-        
-    }
-
     private void updateMeasureAndDimensions(String table, Cube cube, MolapDef.Schema schema,
             ArrayList<MondrianLevelHolder> levelList, ArrayList<LevelNormalizedProps> levelNormalizedList,
             Map<String, String> levelToColumnMap, Set<String> metaFactTableCols, Map<String, Integer> msrCols,
@@ -1550,53 +1498,6 @@ public final class MolapMetadata
          * queryOrder
          */
         protected int queryOrder;
-        
-        /**
-         * parentName
-         */
-        private String parentName; 
-
-        private boolean highCardinalityDim;
-
-        /**
-         * dataBlockIndexs
-         */
-        private int dataBlockIndexs; 
-
-        /**
-         * dataBlockIndexs
-         */
-        private int[] allApplicableDataBlockIndexs; 
-        
-        public void setAllApplicableDataBlockIndexs(int[] allApplicableDataBlockIndexs)
-        {
-            this.allApplicableDataBlockIndexs = allApplicableDataBlockIndexs;
-        }
-        
-        public int[] getAllApplicableDataBlockIndexs()
-        {
-            return allApplicableDataBlockIndexs;
-        }
-
-        public int getDataBlockIndex()
-        {
-            return dataBlockIndexs;
-        }
-
-        public void setDataBlockIndex(int dataBlockIndexs)
-        {
-            this.dataBlockIndexs = dataBlockIndexs;
-        }
-
-        public String getParentName()
-        {
-            return parentName;
-        }
-
-        public void setParentName(String parentName)
-        {
-            this.parentName = parentName;
-        }
 
         /**
          * @return
@@ -1607,26 +1508,6 @@ public final class MolapMetadata
         }
 
         /**
-         * 
-         * @param highCardinalityDim
-         */
-        public void setHighCardinalityDims(boolean highCardinalityDim)
-        {
-            this.highCardinalityDim=highCardinalityDim;
-            
-        }
-        
-        /**
-         * isHighCardinalityDim.
-         * @return
-         */
-        public boolean isHighCardinalityDim()
-        {
-            return highCardinalityDim;
-        }
-
-
-        /**
          * @param dimName
          */
         public void setDimName(String dimName)
@@ -1724,13 +1605,11 @@ public final class MolapMetadata
             Dimension copy = new Dimension();
             copy.dataType = this.dataType;
             copy.colName = this.colName;
-            copy.parentName = this.parentName;
             copy.levelType = this.levelType;
             copy.name = this.name;
             copy.keyOrdinal = this.keyOrdinal;
             copy.schemaOrdinal = this.schemaOrdinal;
             copy.hasOrdinalCol = this.hasOrdinalCol;
-            copy.highCardinalityDim=this.highCardinalityDim;
 //            copy.noOfbits = this.noOfbits;
             copy.propertyCount = this.propertyCount;
             copy.propertyTypes = this.propertyTypes;
@@ -2204,11 +2083,7 @@ public final class MolapMetadata
             this.queryOrder = queryOrder;
         }
 
-        public void getParent()
-        {
-            // TODO Auto-generated method stub
-            
-        }
+
     }
 //CHECKSTYLE:OFF    Approval No:Approval-257
     /**
@@ -2239,11 +2114,6 @@ public final class MolapMetadata
         private Map<String, List<Dimension>> hierarchiesMapping = new LinkedHashMap<String, List<Dimension>>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
 
         /**
-         * complexTypeMapping
-         */
-//        private Map<String, HashMap<Integer, ComplexColumnMetadata>> complexTypesMap = new HashMap<String, HashMap<Integer, ComplexColumnMetadata>>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
-
-        /**
          * TableName, columns list [Meta data i.e. from original database]
          */
         private Map<String, Set<String>> metaTables = new HashMap<String, Set<String>>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
@@ -2285,17 +2155,6 @@ public final class MolapMetadata
         
         private long schemaLastUpdatedTime;
 
-
-        /**
-         * schema.
-         */
-        private Schema schema;
-
-        /**
-         * cube.
-         */
-        private com.huawei.unibi.molap.olap.MolapDef.Cube cube;
-
         /**
          * @param name
          */
@@ -2309,68 +2168,10 @@ public final class MolapMetadata
             this.metaDataFilepath = basePath + "/schemas/" + schemaName + '/' + cubeName;
         }
 
-
-
-        /**
-         * 
-         * @param schema
-         * @param cube
-         * @param orginalSchemaName
-         * @param orginalCubeName
-         */
-        public Cube(Schema schema, com.huawei.unibi.molap.olap.MolapDef.Cube cube, String orginalSchemaName,
-                String orginalCubeName)
-        {
-            this(schema.name, cube.name,orginalSchemaName,orginalCubeName);
-            this.schema = schema;
-            this.cube = cube;
-        }
-
         public String getFactCountColMapping(String tableName)
         {
             return factCountColumnMapping.get(tableName);
         }
-        
-        /**
-         * 
-         * @param schema
-         * @param cube
-         */
-        public Schema getSchema()
-        {
-            return schema;
-        }
-
-        /**
-         * 
-         * @param schema
-         * @param cube
-         */
-        public void setSchema(Schema schema)
-        {
-            this.schema = schema;
-        }
-
-        /**
-         * 
-         * @param schema
-         * @param cube
-         */
-        public com.huawei.unibi.molap.olap.MolapDef.Cube getCube()
-        {
-            return cube;
-        }
-
-        /**
-         * 
-         * @param schema
-         * @param cube
-         */
-        public void setCube(com.huawei.unibi.molap.olap.MolapDef.Cube cube)
-        {
-            this.cube = cube;
-        }
-
 
         /**
          * Find Dimension by column name
@@ -2418,21 +2219,6 @@ public final class MolapMetadata
             return null;
         }
 
-        public List<Dimension> getChildren(String dimName) {
-            List<Dimension> retList = new ArrayList<Dimension>();
-            for(List<Dimension> list : dimensions.values())
-            {
-                for(Dimension dimension : list)
-                {
-                    if(null != dimension.getParentName() && 
-                            dimension.getParentName().equalsIgnoreCase(dimName)){
-                        retList.add(dimension);
-                    }
-                }
-            }
-            return retList;
-        }
-        
         /**
          * Find Dimension by column name
          */
@@ -2834,8 +2620,9 @@ public final class MolapMetadata
         TYPESMAPPING.put("Date", SqlStatement.Type.OBJECT);
         TYPESMAPPING.put("Time", SqlStatement.Type.OBJECT);
         TYPESMAPPING.put("Timestamp", SqlStatement.Type.TIMESTAMP);
-        TYPESMAPPING.put("Array", SqlStatement.Type.ARRAY);
-        TYPESMAPPING.put("Struct", SqlStatement.Type.STRUCT);
+        TYPESMAPPING.put("BigInt", SqlStatement.Type.BIGINT);
+        TYPESMAPPING.put("Decimal", SqlStatement.Type.DECIMAL);
+
     }//CHECKSTYLE:ON
 //CHECKSTYLE:OFF    Approval No:Approval-374
     /**
@@ -2852,6 +2639,8 @@ public final class MolapMetadata
         DBTYPEMAPPING.put("Date", "DATE");
         DBTYPEMAPPING.put("Time", "TIME");
         DBTYPEMAPPING.put("Timestamp", "DATETIME");
+        DBTYPEMAPPING.put("BigInt", "BIGINT");
+        DBTYPEMAPPING.put("Decimal", "DECIMAL");
     }
 //CHECKSTYLE:ON
     public static SqlStatement.Type makeSQLDataTye(String type)
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/metadata/SliceMetaData.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/metadata/SliceMetaData.java
index 4aa0b61..330f17b 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/metadata/SliceMetaData.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/metadata/SliceMetaData.java
@@ -27,18 +27,6 @@ public class SliceMetaData implements Serializable
      */
     private String[] dimensions;
     
-    private String complexTypeString;
-    
-    public String getComplexTypeString()
-    {
-        return complexTypeString;
-    }
-
-    public void setComplexTypeString(String complexTypeString)
-    {
-        this.complexTypeString = complexTypeString;
-    }
-
     /**
      *actualDimensions 
      */
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/olap/MolapDef.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/olap/MolapDef.java
index b0f49f6..67a71c6 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/olap/MolapDef.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/olap/MolapDef.java
@@ -1343,7 +1343,6 @@ public boolean isEnabled() {
                 org.eigenbase.xom.NodeDef[] _tempArray;
                 approxRowCount = (String)_parser.getAttribute("approxRowCount", "String", null, null, false);
                 name = (String)_parser.getAttribute("name", "String", null, null, false);
-                parentname = (String)_parser.getAttribute("parentname", "String", null, null, false);
                 visible = (Boolean)_parser.getAttribute("visible", "Boolean", "true", null, false);
                 columnIndex = (Integer)_parser.getAttribute("columnIndex", "Integer", "-1", null, false);
                 keyOrdinal = (Integer)_parser.getAttribute("keyOrdinal", "Integer", "-1", null, false);
@@ -1385,7 +1384,6 @@ public boolean isEnabled() {
 
         public String approxRowCount;  // optional attribute
         public String name;  // optional attribute
-        public String parentname; // optional attribute
         public Boolean visible;  // attribute default: true
         public Integer columnIndex;  // attribute default: -1
         public Integer keyOrdinal;  // attribute default: -1
@@ -1399,7 +1397,7 @@ public boolean isEnabled() {
         public String parentColumn;  // optional attribute
         public String nullParentValue;  // optional attribute
         /** Allowable values for {@link #type}. */
-        public static final String[] _type_values = {"String", "Numeric", "Integer", "Boolean", "Date", "Time", "Timestamp", "Array", "Struct"};
+        public static final String[] _type_values = {"String", "Numeric", "Integer", "Boolean", "Date", "Time", "Timestamp", "BigInt", "Decimal"};     // mod by ggin
         public String type;  // attribute default: String
         /** Allowable values for {@link #internalType}. */
         public static final String[] _internalType_values = {"int", "long", "Object", "String"};
@@ -1461,7 +1459,6 @@ public boolean isEnabled() {
             _out.println(getName());
             displayAttribute(_out, "approxRowCount", approxRowCount, _indent+1);
             displayAttribute(_out, "name", name, _indent+1);
-            displayAttribute(_out, "parentname", parentname, _indent+1);
             displayAttribute(_out, "visible", visible, _indent+1);
             displayAttribute(_out, "columnIndex", columnIndex, _indent+1);
             displayAttribute(_out, "keyOrdinal", keyOrdinal, _indent+1);
@@ -1499,7 +1496,6 @@ public boolean isEnabled() {
             _out.beginTag("Level", new org.eigenbase.xom.XMLAttrVector()
                 .add("approxRowCount", approxRowCount)
                 .add("name", name)
-                .add("parentname", parentname)
                 .add("visible", visible)
                 .add("columnIndex", columnIndex)
                 .add("keyOrdinal", keyOrdinal)
@@ -1539,7 +1535,6 @@ public boolean isEnabled() {
             Level _cother = (Level)_other;
             boolean _diff = displayAttributeDiff("approxRowCount", approxRowCount, _cother.approxRowCount, _out, _indent+1);
             _diff = _diff && displayAttributeDiff("name", name, _cother.name, _out, _indent+1);
-            _diff = _diff && displayAttributeDiff("parentname", parentname, _cother.parentname, _out, _indent+1);
             _diff = _diff && displayAttributeDiff("visible", visible, _cother.visible, _out, _indent+1);
             _diff = _diff && displayAttributeDiff("columnIndex", columnIndex, _cother.columnIndex, _out, _indent+1);
             _diff = _diff && displayAttributeDiff("keyOrdinal", keyOrdinal, _cother.keyOrdinal, _out, _indent+1);
@@ -1732,7 +1727,8 @@ public Expression getKeyExp() {
         public String name;  // optional attribute
         public String column;  // optional attribute
         /** Allowable values for {@link #type}. */
-        public static final String[] _type_values = {"String", "Numeric", "Integer", "Boolean", "Date", "Time", "Timestamp"};
+
+        public static final String[] _type_values = {"String", "Numeric", "Integer", "Boolean", "Date", "Time", "Timestamp",  "BigInt", "Decimal"};
         public String type;  // attribute default: String
         public String formatter;  // optional attribute
         public String caption;  // optional attribute
@@ -1837,7 +1833,7 @@ public Expression getKeyExp() {
         public String name;  // required attribute
         public String column;  // optional attribute
         /** Allowable values for {@link #datatype}. */
-        public static final String[] _datatype_values = {"String", "Numeric", "Integer", "Boolean", "Date", "Time", "Timestamp", "custom"};
+        public static final String[] _datatype_values = {"String", "Numeric", "Integer", "Boolean", "Date", "Time", "Timestamp", "custom", "BigInt", "Decimal"};
         public String datatype;  // optional attribute
         public String dataTypeClass;  // optional attribute
         public String formatString;  // optional attribute
@@ -3172,7 +3168,7 @@ private java.util.Map<String,String> hintMap;
 
         public String name;  // required attribute
         /** Allowable values for {@link #type}. */
-        public static final String[] _type_values = {"String", "Numeric", "Integer", "Boolean", "Date", "Time", "Timestamp"};
+        public static final String[] _type_values = {"String", "Numeric", "Integer", "Boolean", "Date", "Time", "Timestamp", "BigInt", "Decimal"};
         public String type;  // required attribute
 
 
@@ -5358,7 +5354,7 @@ public String toString() {
         public String name;  // required attribute
         public String description;  // optional attribute
         /** Allowable values for {@link #type}. */
-        public static final String[] _type_values = {"String", "Numeric", "Integer", "Boolean", "Date", "Time", "Timestamp", "Member"};
+        public static final String[] _type_values = {"String", "Numeric", "Integer", "Boolean", "Date", "Time", "Timestamp", "Member", "BigInt", "Decimal"};
         public String type;  // attribute default: String
         public Boolean modifiable;  // attribute default: true
         public String defaultValue;  // optional attribute
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/olap/SqlStatement.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/olap/SqlStatement.java
index e79964b..f8adbc3 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/olap/SqlStatement.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/olap/SqlStatement.java
@@ -10,7 +10,7 @@ public class SqlStatement
         LONG,
         STRING,
         BOOLEAN,
-        ARRAY,
-        STRUCT
+        BIGINT,
+        DECIMAL
     }
 }
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/util/ByteUtil.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/util/ByteUtil.java
index 3b389a0..48dbcc9 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/util/ByteUtil.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/util/ByteUtil.java
@@ -344,8 +344,8 @@ public final class ByteUtil
                 }
             }
             return true;
-        }  
+        }        
+        
     }
-    
 
 }
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/util/DataTypeUtil.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/util/DataTypeUtil.java
new file mode 100644
index 0000000..3532e16
--- /dev/null
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/util/DataTypeUtil.java
@@ -0,0 +1,112 @@
+/**
+ * 
+ */
+package com.huawei.unibi.molap.util;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
+import com.huawei.unibi.molap.constants.MolapCommonConstants;
+import com.huawei.unibi.molap.olap.SqlStatement.Type;
+
+/**
+ * @author m00258959
+ *
+ */
+public class DataTypeUtil
+{
+    /**
+     * Based on data type the value will be converted and retruned
+     * 
+     * @param msrValue
+     * @param dataType
+     * @return
+     */
+    public static Object getMeasureValueBasedOnDataType(String msrValue, String dataType)
+    {
+        switch(dataType)
+        {
+        case "Decimal":
+            return new java.math.BigDecimal(msrValue);
+        case "BigInt":
+        case "LONG":
+            return Long.valueOf(msrValue);
+        default:
+            return Double.valueOf(msrValue);
+        }
+    }
+
+    /**
+     * return aggregation type based on data type of measure
+     * 
+     * @param dataType
+     * @return
+     */
+    public static char getAggType(String dataType)
+    {
+        switch(dataType)
+        {
+        case "Decimal":
+            return MolapCommonConstants.BIG_DECIMAL_MEASURE;
+        case "BigInt":
+        case "Long":
+            return MolapCommonConstants.BIG_INT_MEASURE;
+        default:
+            return 'n';
+        }
+    }
+
+    /**
+     * Return aggregation type based on sql data type
+     * 
+     * @param dataType
+     * @return
+     */
+    public static char getAggType(Type dataType)
+    {
+        switch(dataType)
+        {
+        case DECIMAL:
+            return MolapCommonConstants.BIG_DECIMAL_MEASURE;
+        case BIGINT:
+        case LONG:
+            return MolapCommonConstants.BIG_INT_MEASURE;
+        default:
+            return 'n';
+        }
+    }
+
+    /**
+     * This method will convert bigdecimal number to byte array
+     * 
+     * @param num
+     * @return
+     */
+    public static byte[] bigDecimalToByte(BigDecimal num)
+    {
+        BigInteger sig = new BigInteger(num.unscaledValue().toString());
+        int scale = num.scale();
+        byte[] bscale = new byte[]{(byte)(scale)};
+        byte[] buff = sig.toByteArray();
+        byte[] completeArr = new byte[buff.length + bscale.length];
+        System.arraycopy(bscale, 0, completeArr, 0, bscale.length);
+        System.arraycopy(buff, 0, completeArr, bscale.length, buff.length);
+        return completeArr;
+    }
+
+    /**
+     * This method will convert byte array to big decimal
+     * 
+     * @param raw
+     * @return
+     */
+    public static BigDecimal byteToBigDecimal(byte[] raw)
+    {
+        int scale = (raw[0] & 0xFF);
+        byte[] unscale = new byte[raw.length - 1];
+        System.arraycopy(raw, 1, unscale, 0, unscale.length);
+        BigInteger sig = new BigInteger(unscale);
+        return new BigDecimal(sig, scale);
+    }
+
+}
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/util/MolapMergerUtil.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/util/MolapMergerUtil.java
deleted file mode 100644
index 4ca382c..0000000
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/util/MolapMergerUtil.java
+++ /dev/null
@@ -1,157 +0,0 @@
-/**
- * 
- */
-package com.huawei.unibi.molap.util;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.lang.Math;
-
-import org.pentaho.di.core.exception.KettleException;
-
-import com.huawei.iweb.platform.logging.LogService;
-import com.huawei.iweb.platform.logging.LogServiceFactory;
-import com.huawei.unibi.molap.constants.MolapCommonConstants;
-import com.huawei.unibi.molap.datastorage.store.filesystem.MolapFile;
-import com.huawei.unibi.molap.datastorage.store.impl.FileFactory;
-import com.huawei.unibi.molap.datastorage.store.impl.FileFactory.FileType;
-
-/**
- * @author R00903928
- * Util class for merge activities of 2 loads.
- */
-public class MolapMergerUtil
-{
-
-    /**
-     * Attribute for Molap LOGGER
-     */
-    private static final LogService LOGGER = LogServiceFactory.getLogService(MolapMergerUtil.class.getName());
-
-    /**
-     * 
-     * @param storeLocation
-     * @param tableName
-     * @param fileType
-     * @param loadsToBeMerged
-     * @return
-     */
-    public static List<MolapSliceAndFiles> getSliceAndFilesList(String storeLocation, String tableName,
-            FileType fileType, List<String> loadsToBeMerged)
-    {
-        try
-        {
-            if(!FileFactory.isFileExist(storeLocation, fileType))
-            {
-                return new ArrayList<MolapSliceAndFiles>(0);
-            }
-        }
-        catch(IOException e)
-        {
-            LOGGER.error(MolapCoreLogEvent.UNIBI_MOLAPCORE_MSG, "Error occurred :: " + e.getMessage());
-        }
-        MolapFile file = FileFactory.getMolapFile(storeLocation, fileType);
-
-        MolapFile[] listFiles = MolapUtil.listFiles(file);
-        if(null == listFiles || listFiles.length < 0)
-        {
-            return new ArrayList<MolapSliceAndFiles>(0);
-        }
-        Arrays.sort(listFiles, new MolapFileFolderComparator());
-        listFiles = getMergeFilesList(loadsToBeMerged, listFiles);
-
-        return MolapUtil.getSliceAndFilesList(tableName, listFiles, fileType);
-    }
-
-    /**
-     * 
-     * @param loadsToBeMerged
-     * @param listFiles
-     * @return
-     */
-    private static MolapFile[] getMergeFilesList(List<String> loadsToBeMerged, MolapFile[] listFiles)
-    {
-        MolapFile[] molapFile = new MolapFile[loadsToBeMerged.size()];
-        int i = 0;
-        for(MolapFile listFile : listFiles)
-        {
-            String loadName = listFile.getName();
-            for(String load : loadsToBeMerged)
-            {
-                if((MolapCommonConstants.LOAD_FOLDER + load).equalsIgnoreCase(loadName))
-                {
-                    molapFile[i++] = listFile;
-                }
-            }
-        }
-        return molapFile;
-    }
-
-    /**
-     * 
-     * @param sliceLocation
-     * @param tableName
-     * @param destinationLocation
-     */
-    public static int[] mergeLevelMetadata(String[] sliceLocation, String tableName, String destinationLocation)
-    {
-        int[][] cardinalityOfLoads = new int[sliceLocation.length][];
-        int i = 0;
-        for(String loadFolderLoacation : sliceLocation)
-        {
-            try
-            {
-                cardinalityOfLoads[i++] = MolapUtil.getCardinalityFromLevelMetadataFile(loadFolderLoacation + '/'
-                        + MolapCommonConstants.LEVEL_METADATA_FILE + tableName + ".metadata");
-            }
-            catch(MolapUtilException e)
-            {
-                LOGGER.error(MolapCoreLogEvent.UNIBI_MOLAPCORE_MSG, "Error occurred :: " + e.getMessage());
-            }
-        }
-        int[] MaxCardinality = new int[cardinalityOfLoads[0].length];
-
-        for(int k = 0;k < cardinalityOfLoads[0].length;k++)
-        {
-            MaxCardinality[k] = Math.max(cardinalityOfLoads[0][k], cardinalityOfLoads[1][k]);
-        }
-
-        try
-        {
-            MolapUtil.writeLevelCardinalityFile(destinationLocation, tableName, MaxCardinality);
-        }
-        catch(KettleException e)
-        {
-            LOGGER.error(MolapCoreLogEvent.UNIBI_MOLAPCORE_MSG, "Error occurred :: " + e.getMessage());
-        }
-
-        return MaxCardinality;
-    }
-
-    /**
-     * 
-     * @param path
-     * @param tableName
-     * @return
-     */
-    public static int[] getCardinalityFromLevelMetadata(String path, String tableName)
-    {
-        int[] localCardinality = null;
-        try
-        {
-            localCardinality = MolapUtil.getCardinalityFromLevelMetadataFile(path + '/'
-                    + MolapCommonConstants.LEVEL_METADATA_FILE + tableName + ".metadata");
-        }
-        catch(MolapUtilException e)
-        {
-            LOGGER.error(
-                    MolapCoreLogEvent.UNIBI_MOLAPCORE_MSG ,
-                    "Error occurred :: " + e.getMessage());
-        }
-
-        return localCardinality;
-    }
-
-}
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/util/MolapSliceAndFiles.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/util/MolapSliceAndFiles.java
index 410ebc8..6995ced 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/util/MolapSliceAndFiles.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/util/MolapSliceAndFiles.java
@@ -1,7 +1,6 @@
 package com.huawei.unibi.molap.util;
 
 import com.huawei.unibi.molap.datastorage.store.filesystem.MolapFile;
-import com.huawei.unibi.molap.keygenerator.KeyGenerator;
 
 public class MolapSliceAndFiles
 {
@@ -15,8 +14,6 @@ public class MolapSliceAndFiles
      */
     private MolapFile[] sliceFactFilesList;
     
-    private KeyGenerator keyGen;
-    
     /**
      * This method will be used get the slice fact files 
      * 
@@ -61,21 +58,5 @@ public class MolapSliceAndFiles
         this.path = path;
     }
 
-    /**
-     * @return the keyGen
-     */
-    public KeyGenerator getKeyGen()
-    {
-        return keyGen;
-    }
-
-    /**
-     * @param keyGen the keyGen to set
-     */
-    public void setKeyGen(KeyGenerator keyGen)
-    {
-        this.keyGen = keyGen;
-    }
-
    
 }
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/util/MolapUtil.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/util/MolapUtil.java
index 24dd8a8..2449636 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/util/MolapUtil.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/util/MolapUtil.java
@@ -28,7 +28,6 @@ import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
-import java.security.PrivilegedExceptionAction;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -38,8 +37,6 @@ import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
-import org.apache.hadoop.conf.Configuration;
-import org.apache.hadoop.security.UserGroupInformation;
 import org.pentaho.di.core.exception.KettleException;
 
 import com.google.gson.Gson;
@@ -51,8 +48,6 @@ import com.huawei.unibi.molap.datastorage.store.FileHolder;
 import com.huawei.unibi.molap.datastorage.store.columnar.ColumnarKeyStoreDataHolder;
 import com.huawei.unibi.molap.datastorage.store.columnar.ColumnarKeyStoreInfo;
 import com.huawei.unibi.molap.datastorage.store.columnar.UnBlockIndexer;
-import com.huawei.unibi.molap.datastorage.store.fileperations.AtomicFileOperations;
-import com.huawei.unibi.molap.datastorage.store.fileperations.AtomicFileOperationsImpl;
 import com.huawei.unibi.molap.datastorage.store.filesystem.MolapFile;
 import com.huawei.unibi.molap.datastorage.store.filesystem.MolapFileFilter;
 import com.huawei.unibi.molap.datastorage.store.impl.FileFactory;
@@ -86,10 +81,6 @@ import com.huawei.unibi.molap.metadata.SliceMetaData;
 public final class MolapUtil
 {
     
-    private static final String HDFS_PREFIX = "hdfs://";
-
-    private static final String FS_DEFAULT_FS = "fs.defaultFS";
-
     /**
      * Attribute for Molap LOGGER
      */
@@ -111,9 +102,6 @@ public final class MolapUtil
      */
     private static final int CONST_HUNDRED = 100;
     
-    
-    private static final Configuration conf= new Configuration(true);
-    
     private MolapUtil()
     {
         
@@ -735,24 +723,16 @@ public final class MolapUtil
         // get the log bits of cardinality 
         for(int i = 0;i < dimCardinality.length;i++)
         {
-            if(dimCardinality[i] == 0)
+            int bitsLength=Long.toBinaryString(dimCardinality[i]).length();
+            int div=bitsLength/8;
+            int mod=bitsLength%8;
+            if(mod>0)
             {
-                //Array or struct type may have higher value 
-                newDimsC[i]=64;
+                newDimsC[i] = 8 * (div + 1);
             }
             else
             {
-                int bitsLength=Long.toBinaryString(dimCardinality[i]).length();
-                int div=bitsLength/8;
-                int mod=bitsLength%8;
-                if(mod>0)
-                {
-                    newDimsC[i] = 8 * (div + 1);
-                }
-                else
-                {
-                    newDimsC[i]=bitsLength;
-                }
+                newDimsC[i]=bitsLength;
             }
         }
         return newDimsC;
@@ -790,36 +770,18 @@ public final class MolapUtil
      *          exception
      *
      */
-    public static void deleteFoldersAndFiles(final String... path) throws MolapUtilException
+    public static void deleteFoldersAndFiles(String... path) throws MolapUtilException
     {
         if(path == null)
         {
             return;
         }
-        try
-        {
-            UserGroupInformation.getLoginUser().doAs(new PrivilegedExceptionAction<Void>() {
-
-                @Override
-                public Void run() throws Exception
-                {
-                    for(int i = 0;i < path.length;i++)
-                    {
-                        if(null!=path[i])
-                        {
-                            deleteRecursive(new File(path[i]));
-                        }
-                    }
-                    return null;
-                }});
-        }
-        catch(IOException e)
-        {
-            throw new MolapUtilException("Error while deleteing the folders and files");
-        }
-        catch(InterruptedException e)
+        for(int i = 0;i < path.length;i++)
         {
-            throw new MolapUtilException("Error while deleteing the folders and files");
+            if(null!=path[i])
+            {
+                deleteRecursive(new File(path[i]));
+            }
         }
     }
     
@@ -832,31 +794,12 @@ public final class MolapUtil
      *          exception
      *
      */
-    public static void deleteFoldersAndFiles(final File... path) throws MolapUtilException
+    public static void deleteFoldersAndFiles(File... path) throws MolapUtilException
     {
-        try
+        for(int i = 0;i < path.length;i++)
         {
-            UserGroupInformation.getLoginUser().doAs(new PrivilegedExceptionAction<Void>() {
-
-                @Override
-                public Void run() throws Exception
-                {
-                    for(int i = 0;i < path.length;i++)
-                    {
-                        deleteRecursive(path[i]);
-                    }
-                    return null;
-                }});
+            deleteRecursive(path[i]);
         }
-        catch(IOException e)
-        {
-            throw new MolapUtilException("Error while deleteing the folders and files");
-        }
-        catch(InterruptedException e)
-        {
-            throw new MolapUtilException("Error while deleteing the folders and files");
-        }
-       
     }
     
     
@@ -883,55 +826,19 @@ public final class MolapUtil
     }
     
     
-    public static void deleteFoldersAndFiles(final MolapFile...file) throws MolapUtilException
+    public static void deleteFoldersAndFiles(MolapFile...file) throws MolapUtilException
     {
-        try
+        for(int i = 0;i < file.length;i++)
         {
-            UserGroupInformation.getLoginUser().doAs(new PrivilegedExceptionAction<Void>() {
-
-                @Override
-                public Void run() throws Exception
-                {
-                    for(int i = 0;i < file.length;i++)
-                    {
-                        deleteRecursive(file[i]);
-                    }
-                    return null;
-                }});
-        }
-        catch(IOException e)
-        {
-            throw new MolapUtilException("Error while deleteing the folders and files");
-        }
-        catch(InterruptedException e)
-        {
-            throw new MolapUtilException("Error while deleteing the folders and files");
+            deleteRecursive(file[i]);
         }
     }
     
-    public static void deleteFoldersAndFilesSilent(final MolapFile...file) throws MolapUtilException
+    public static void deleteFoldersAndFilesSilent(MolapFile...file) throws MolapUtilException
     {
-        try
+        for(int i = 0;i < file.length;i++)
         {
-            UserGroupInformation.getLoginUser().doAs(new PrivilegedExceptionAction<Void>() {
-
-                @Override
-                public Void run() throws Exception
-                {
-                    for(int i = 0;i < file.length;i++)
-                    {
-                        deleteRecursiveSilent(file[i]);
-                    }
-                    return null;
-                }});
-        }
-        catch(IOException e)
-        {
-            throw new MolapUtilException("Error while deleteing the folders and files");
-        }
-        catch(InterruptedException e)
-        {
-            throw new MolapUtilException("Error while deleteing the folders and files");
+            deleteRecursiveSilent(file[i]);
         }
     }
     
@@ -1880,7 +1787,7 @@ private static List<LeafNodeInfo> getLeafNodeDetails(List<LeafNodeInfo> listOfNo
         return array;
     }
     
-    /*public static List<MolapSliceAndFiles> getSlicesToMergeFromHDFS(String storeLocation,String tableName, FileType fileType, String metadataPath, List<LoadMetadataDetails> mergedLoadDetails)
+    public static List<MolapSliceAndFiles> getSlicesFromHDFS(String storeLocation,String tableName, FileType fileType)
     {
         try
         {
@@ -1915,22 +1822,9 @@ private static List<LeafNodeInfo> getLeafNodeDetails(List<LeafNodeInfo> listOfNo
             return new ArrayList<MolapSliceAndFiles>(0);
         }
         Arrays.sort(listFiles,new MolapFileFolderComparator());
-        
-        LoadMetadataDetails[] loadDetails = readLoadMetadata(metadataPath);
-        
-        if(loadDetails.length == 0)
-        {
-            LOGGER.error(
-                    MolapCoreLogEvent.UNIBI_MOLAPCORE_MSG ,
-                    "load metadata details doesnt exist." );
-            return new ArrayList<MolapSliceAndFiles>(0);
-        }
-        listFiles = getMergeFilesList(loadDetails,listFiles,mergedLoadDetails);
-        
-        
         return getSliceAndFilesList(
-                tableName, listFiles,fileType,loadDetails);
-    }*/
+                tableName, listFiles,fileType);
+    }
     public static String[] getSlices(String storeLocation,String tableName, FileType fileType)
     {
         try
@@ -1974,7 +1868,7 @@ private static List<LeafNodeInfo> getLeafNodeDetails(List<LeafNodeInfo> listOfNo
         return slices;
     }
     
-    /*public static List<MolapSliceAndFiles> getSlicesFromLocal(String storeLocation,String tableName)
+    public static List<MolapSliceAndFiles> getSlicesFromLocal(String storeLocation,String tableName)
     {
         try
         {
@@ -1999,7 +1893,7 @@ private static List<LeafNodeInfo> getLeafNodeDetails(List<LeafNodeInfo> listOfNo
         Arrays.sort(listFiles,new MolapFileFolderComparator());
         return getSliceAndFilesList(
                 tableName, listFiles,FileType.LOCAL);
-    }*/
+    }
 
     /**
      * @param file
@@ -2023,19 +1917,11 @@ private static List<LeafNodeInfo> getLeafNodeDetails(List<LeafNodeInfo> listOfNo
         return listFiles;
     }
     
-    public static List<MolapSliceAndFiles> getSliceAndFilesList(String tableName,
+    private static List<MolapSliceAndFiles> getSliceAndFilesList(String tableName,
             MolapFile[] listFiles, FileType fileType)
     {
-        
-        //listFiles  = getLoadFolderToBeMerged(listFiles);
-        
         List<MolapSliceAndFiles> sliceFactFilesList = new ArrayList<MolapSliceAndFiles>(
                 listFiles.length);
-        if(listFiles.length == 0)
-        {
-            return sliceFactFilesList;
-        }
-        
 
         MolapSliceAndFiles sliceAndFiles = null;
         MolapFile[] sortedPathForFiles = null;
@@ -2116,28 +2002,8 @@ private static List<LeafNodeInfo> getLeafNodeDetails(List<LeafNodeInfo> listOfNo
     {
         MolapFile file = FileFactory.getMolapFile(sliceLocation, fileType);
         MolapFile[] files = null;
-        MolapFile[] updatedFactFiles = null;
         if(file.isDirectory())
         {
-            updatedFactFiles =  file.listFiles(new MolapFileFilter()
-            {
-                
-                @Override
-                public boolean accept(MolapFile pathname)
-                {
-                    return ((!pathname.isDirectory())
-                            && (pathname.getName().startsWith(tableName)) && pathname
-                            .getName().endsWith(
-                                    MolapCommonConstants.FACT_UPDATE_EXTENSION));
-                }
-            });
-            
-            if(updatedFactFiles.length != 0)
-            {
-                return updatedFactFiles;
-                
-            }
-            
             files = file.listFiles(new MolapFileFilter()
             {
                 public boolean accept(MolapFile pathname)
@@ -2282,17 +2148,14 @@ private static List<LeafNodeInfo> getLeafNodeDetails(List<LeafNodeInfo> listOfNo
                 + MolapCommonConstants.LOADMETADATA_FILENAME + MolapCommonConstants.MOLAP_METADATA_EXTENSION;
         LoadMetadataDetails[] listOfLoadFolderDetailsArray;
 
-        AtomicFileOperations fileOperation = new AtomicFileOperationsImpl(metadataFileName, FileFactory.getFileType(metadataFileName));
-        
         try
         {
             if(!FileFactory.isFileExist(metadataFileName, FileFactory.getFileType(metadataFileName)))
             {
                 return new LoadMetadataDetails[0];
             }
-            dataInputStream = fileOperation.openForRead();
-            /*dataInputStream = FileFactory.getDataInputStream(metadataFileName,
-                    FileFactory.getFileType(metadataFileName));*/
+            dataInputStream = FileFactory.getDataInputStream(metadataFileName,
+                    FileFactory.getFileType(metadataFileName));
             inStream = new InputStreamReader(dataInputStream, MolapCommonConstants.MOLAP_DEFAULT_STREAM_ENCODEFORMAT);
             buffReader = new BufferedReader(inStream);
             listOfLoadFolderDetailsArray = gsonObjectToRead.fromJson(buffReader, LoadMetadataDetails[].class);
@@ -2479,18 +2342,6 @@ private static List<LeafNodeInfo> getLeafNodeDetails(List<LeafNodeInfo> listOfNo
         }
     }
     
-    public static String escapeComplexDelimiterChar(String parseStr)
-    {
-        switch(parseStr)
-        {
-            case "$":
-                return "\\$";
-            case ":":
-                return "\\:";
-            default:
-                return parseStr;
-        }
-    }
     /**
      * Append HDFS Base Url for show create & load data sql
      * 
@@ -2505,11 +2356,6 @@ private static List<LeafNodeInfo> getLeafNodeDetails(List<LeafNodeInfo> listOfNo
       {
           String baseHDFSUrl = MolapProperties.getInstance().
                   getProperty(MolapCommonConstants.CARBON_DDL_BASE_HDFS_URL);
-          String hdfsUrl=conf.get(FS_DEFAULT_FS);
-          if(hdfsUrl.startsWith(HDFS_PREFIX))
-          {
-        	  baseHDFSUrl=hdfsUrl+baseHDFSUrl;
-          }
           if(null != baseHDFSUrl)
           {
             if(baseHDFSUrl.endsWith("/"))
@@ -2600,13 +2446,14 @@ private static List<LeafNodeInfo> getLeafNodeDetails(List<LeafNodeInfo> listOfNo
         }
         String basePath =prop.getProperty(MolapCommonConstants.STORE_LOCATION,
                 MolapCommonConstants.STORE_LOCATION_DEFAULT_VAL);
+    /* Commented the code to disable Access control in C10SPC100 
         String useUniquePath =  MolapProperties.getInstance().getProperty(
                 MolapCommonConstants.CARBON_UNIFIED_STORE_PATH, MolapCommonConstants.CARBON_UNIFIED_STORE_PATH_DEFAULT);
         if(null != schemaName && !schemaName.isEmpty() && null != cubeName && !cubeName.isEmpty()
                 && "true".equals(useUniquePath))
         {
             basePath = basePath + File.separator + schemaName + File.separator + cubeName;
-        }
+        }*/
         return basePath;
     }
 }
diff --git a/Molap/Molap-Core/src/com/huawei/unibi/molap/util/ValueCompressionUtil.java b/Molap/Molap-Core/src/com/huawei/unibi/molap/util/ValueCompressionUtil.java
index 33d6525..9834d29 100644
--- a/Molap/Molap-Core/src/com/huawei/unibi/molap/util/ValueCompressionUtil.java
+++ b/Molap/Molap-Core/src/com/huawei/unibi/molap/util/ValueCompressionUtil.java
@@ -6,6 +6,7 @@ package com.huawei.unibi.molap.util;
 import java.io.DataInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
+import java.math.BigDecimal;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
 
@@ -15,31 +16,7 @@ import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.datastorage.store.compression.MeasureMetaDataModel;
 import com.huawei.unibi.molap.datastorage.store.compression.ValueCompressionModel;
 import com.huawei.unibi.molap.datastorage.store.compression.ValueCompressonHolder.UnCompressValue;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressByteArray;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressMaxMinByte;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressMaxMinDefault;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressMaxMinFloat;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressMaxMinInt;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressMaxMinLong;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressMaxMinShort;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressNonDecimalByte;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressNonDecimalDefault;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressNonDecimalFloat;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressNonDecimalInt;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressNonDecimalLong;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressNonDecimalMaxMinByte;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressNonDecimalMaxMinDefault;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressNonDecimalMaxMinFloat;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressNonDecimalMaxMinInt;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressNonDecimalMaxMinLong;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressNonDecimalMaxMinShort;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressNonDecimalShort;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressNoneByte;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressNoneDefault;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressNoneFloat;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressNoneInt;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressNoneLong;
-import com.huawei.unibi.molap.datastorage.store.compression.type.UnCompressNoneShort;
+import com.huawei.unibi.molap.datastorage.store.compression.type.*;
 import com.huawei.unibi.molap.datastorage.store.impl.FileFactory;
 
 /**
@@ -100,11 +77,10 @@ public final class ValueCompressionUtil
          * 
          */
         MAX_MIN_NDC,
-        
-        /**
-         * custome
-         */
-        CUSTOM
+
+        CUSTOM,
+
+        CUSTOM_BIGDECIMAL
     }
 
     /**
@@ -257,33 +233,38 @@ public final class ValueCompressionUtil
      * @see
      * @since
      */
-    private static CompressionFinder getCompressionType(double maxValue, double minValue, int decimal, char aggregatorType, byte dataTypeSelected)
+    private static CompressionFinder getCompressionType(Object maxValue, Object minValue, int decimal, char aggregatorType, byte dataTypeSelected)
     {
-        if(aggregatorType=='c')
+        switch (aggregatorType)   // 'c' for aggregate table,'b' fo rBigdecimal, 'l' for long,'n' for double
         {
-            return new CompressionFinder(COMPRESSION_TYPE.CUSTOM, DataType.DATA_BYTE, DataType.DATA_BYTE);
+            case 'c':
+                return new CompressionFinder(COMPRESSION_TYPE.CUSTOM, DataType.DATA_BYTE, DataType.DATA_BYTE);
+            case 'b':
+                return new CompressionFinder(COMPRESSION_TYPE.CUSTOM_BIGDECIMAL, DataType.DATA_BYTE, DataType.DATA_BYTE);
+            case 'l':
+                return new CompressionFinder(COMPRESSION_TYPE.NONE, DataType.DATA_LONG, DataType.DATA_LONG);
         }
         // None Decimal
         if(decimal == 0)
         {
-            if(getSize(getDataType(maxValue, decimal,dataTypeSelected)) > getSize(getDataType(maxValue - minValue, decimal,dataTypeSelected)))
+            if(getSize(getDataType((double)maxValue, decimal,dataTypeSelected)) > getSize(getDataType((double)maxValue - (double)minValue, decimal,dataTypeSelected)))
             {
-                return new CompressionFinder(COMPRESSION_TYPE.MAX_MIN, DataType.DATA_DOUBLE, getDataType(maxValue
-                        - minValue, decimal,dataTypeSelected));
+                return new CompressionFinder(COMPRESSION_TYPE.MAX_MIN, DataType.DATA_DOUBLE, getDataType((double)maxValue
+                        - (double)minValue, decimal,dataTypeSelected));
             }
             else
             {
                 return new CompressionFinder(COMPRESSION_TYPE.NONE, DataType.DATA_DOUBLE,
-                        getDataType(maxValue, decimal,dataTypeSelected));
+                        getDataType((double)maxValue, decimal,dataTypeSelected));
             }
         }
         // decimal
         else
         {
-            DataType actualDataType = getDataType(maxValue, decimal,dataTypeSelected);
-            DataType diffDataType = getDataType(maxValue - minValue, decimal,dataTypeSelected);
-            DataType maxNonDecDataType = getDataType(Math.pow(10, decimal) * maxValue, 0,dataTypeSelected);
-            DataType diffNonDecDataType = getDataType(Math.pow(10, decimal) * (maxValue - minValue), 0,dataTypeSelected);
+            DataType actualDataType = getDataType((double)maxValue, decimal,dataTypeSelected);
+            DataType diffDataType = getDataType((double)maxValue - (double)minValue, decimal,dataTypeSelected);
+            DataType maxNonDecDataType = getDataType(Math.pow(10, decimal) * (double)maxValue, 0,dataTypeSelected);
+            DataType diffNonDecDataType = getDataType(Math.pow(10, decimal) * ((double)maxValue - (double)minValue), 0,dataTypeSelected);
 
             CompressionFinder[] finders = new CompressionFinder[]{
                     new CompressionFinder(actualDataType, actualDataType, CompressionFinder.PRIORITY.ACTUAL,
@@ -508,6 +489,50 @@ public final class ValueCompressionUtil
             return o;
         }
     }
+    
+    /**
+     * 
+     * @param compType
+     *            : compression type
+     * @param values
+     *            : the data of one measure
+     * @param changedDataType
+     *            : changed data type
+     * @param maxValue
+     *            : the max value of one measure
+     * @param decimal
+     *            : the decimal length of one measure
+     * @return: the compress data array
+     * @see
+     * @since
+     */
+    public static Object getCompressedValues(COMPRESSION_TYPE compType, long[] values, DataType changedDataType,
+            long maxValue, int decimal)
+    {
+        Object o;
+        switch(compType)
+        {
+        case NONE:
+        
+            o = compressNone(changedDataType, values);
+            return o;
+        
+        case MAX_MIN:
+        
+            o = compressMaxMin(changedDataType, values, maxValue);
+            return o;
+        
+        case NON_DECIMAL_CONVERT:
+        
+            o = compressNonDecimal(changedDataType, values, decimal);
+            return o;
+
+        
+        default:
+            o = compressNonDecimalMaxMin(changedDataType, values, decimal, maxValue);
+            return o;
+        }
+    }
 
     /**
      * 
@@ -527,7 +552,7 @@ public final class ValueCompressionUtil
      * @see
      * @since
      */
-    private static UnCompressValue[] getUncompressedValues(COMPRESSION_TYPE[] compType, DataType[] changedDataType)
+    private static UnCompressValue[] getUncompressedValues(COMPRESSION_TYPE[] compType, DataType[] actualDataType, DataType[] changedDataType)
     {
 
         UnCompressValue[] compressValue = new UnCompressValue[changedDataType.length];
@@ -537,23 +562,27 @@ public final class ValueCompressionUtil
             {
             case NONE:
             
-                compressValue[i] = unCompressNone(changedDataType[i], null);
+                compressValue[i] = unCompressNone(changedDataType[i], actualDataType[i]);
                 break;
             
             case MAX_MIN:
             
-                compressValue[i] = unCompressMaxMin(changedDataType[i], null);
+                compressValue[i] = unCompressMaxMin(changedDataType[i], actualDataType[i]);
                 break;
             
             case NON_DECIMAL_CONVERT:
             
-                compressValue[i] = unCompressNonDecimal(changedDataType[i], null);
+                compressValue[i] = unCompressNonDecimal(changedDataType[i], DataType.DATA_DOUBLE);
                 break;
             
             case CUSTOM:
-                compressValue[i]= new UnCompressByteArray();
+                compressValue[i]= new UnCompressByteArray(UnCompressByteArray.byteArrayType.BYTE_ARRAY);
                 break;
-                
+
+            case CUSTOM_BIGDECIMAL:
+                compressValue[i] = new UnCompressByteArray(UnCompressByteArray.byteArrayType.BIG_DECIMAL);
+                break;
+
             default:
                 compressValue[i] = unCompressNonDecimalMaxMin(changedDataType[i], null);
             }
@@ -630,6 +659,78 @@ public final class ValueCompressionUtil
         default:
         
             return value;
+
+        }
+    }
+    
+    /**
+     * compress data to other type for example: double -> int
+     * 
+     */
+    private static Object compressNone(DataType changedDataType, long[] value)
+    {
+        int i=0;
+        switch(changedDataType)
+        {
+       
+        case DATA_BYTE:
+        
+            byte[] result = new byte[value.length];
+          
+            for(long a : value)
+            {
+                result[i] = (byte)a;
+                i++;
+            }
+            return result;
+        
+        case DATA_SHORT:
+        
+            short[] shortResult = new short[value.length];
+          
+            for(long a : value)
+            {
+                shortResult[i] = (short)a;
+                i++;
+            }
+            return shortResult;
+        
+        case DATA_INT:
+        
+            int[] intResult = new int[value.length];
+         
+            for(long a : value)
+            {
+                intResult[i] = (int)a;
+                i++;
+            }
+            return intResult;
+        
+        case DATA_LONG:
+        
+            long[] longResult = new long[value.length];
+  
+            for(long a : value)
+            {
+                longResult[i] = (long)a;
+                i++;
+            }
+            return longResult;
+        
+        case DATA_FLOAT:
+        
+            float[] floatResult = new float[value.length];
+         
+            for(long a : value)
+            {
+                floatResult[i] = (float)a;
+                i++;
+            }
+            return floatResult;
+        
+        default:
+        
+            return value;
         
         }
     }
@@ -710,6 +811,83 @@ public final class ValueCompressionUtil
         
         }
     }
+    
+    /**
+     * compress data to other type through sub value for example: 1. subValue =
+     * maxValue - value 2. subValue: double->int
+     */
+    private static Object compressMaxMin(DataType changedDataType, long[] value, long maxValue)
+    {
+        int i=0;
+        switch(changedDataType)
+        {
+        case DATA_BYTE:
+        
+            byte[] result = new byte[value.length];
+            for(long a : value)
+            {
+                result[i] = (byte)(maxValue - a);
+                i++;
+            }
+            return result;
+        
+        case DATA_SHORT:
+        
+            short[] shortResult = new short[value.length];
+            
+            for(long a : value)
+            {
+                shortResult[i] = (short)(maxValue - a);
+                i++;
+            }
+            return shortResult;
+        
+        case DATA_INT:
+        
+            int[] intResult = new int[value.length];
+
+            for(long a : value)
+            {
+                intResult[i] = (int)(maxValue - a);
+                i++;
+            }
+            return intResult;
+        
+        case DATA_LONG:
+        
+            long[] longResult = new long[value.length];
+          
+            for(long a : value)
+            {
+                longResult[i] = (long)(maxValue - a);
+                i++;
+            }
+            return longResult;
+        
+        case DATA_FLOAT:
+        
+            float[] floatResult = new float[value.length];
+           
+            for(long a : value)
+            {
+                floatResult[i] = (float)(maxValue - a);
+                i++;
+            }
+            return floatResult;
+        
+        default:
+        
+            long[] defaultResult = new long[value.length];
+        
+            for(long a : value)
+            {
+                defaultResult[i] = (long)(maxValue - a);
+                i++;
+            }
+            return defaultResult;
+        
+        }
+    }
 
     /**
      * compress data to other type through sub value for example: 1. subValue =
@@ -782,6 +960,78 @@ public final class ValueCompressionUtil
             return defaultResult;
         }
     }
+    
+    /**
+     * compress data to other type through sub value for example: 1. subValue =
+     * value * Math.pow(10, decimal) 2. subValue: double->int
+     */
+    private static Object compressNonDecimal(DataType changedDataType, long[] value, int decimal)
+    {
+       int i=0;
+        switch(changedDataType)
+        {
+        case DATA_BYTE:
+            byte[] result = new byte[value.length];
+          
+            for(long a : value)
+            {
+                result[i] = (byte)(Math.round(Math.pow(10, decimal) * a));
+                i++;
+            }
+            return result;
+        case DATA_SHORT:
+            short[] shortResult = new short[value.length];
+     
+            for(long a : value)
+            {
+                shortResult[i] = (short)(Math.round(Math.pow(10, decimal) * a));
+                i++;
+            }
+            return shortResult;
+        case DATA_INT:
+        
+            int[] intResult = new int[value.length];
+          
+            for(long a : value)
+            {
+                intResult[i] = (int)(Math.round(Math.pow(10, decimal) * a));
+                i++;
+            }
+            return intResult;
+        
+        case DATA_LONG:
+        
+            long[] longResult = new long[value.length];
+           
+            for(long a : value)
+            {
+                longResult[i] = (long)(Math.round(Math.pow(10, decimal) * a));
+                i++;
+            }
+            return longResult;
+        
+        case DATA_FLOAT:
+        
+            float[] floatResult = new float[value.length];
+            
+            for(double a : value)
+            {
+                floatResult[i] = (float)(Math.round(Math.pow(10, decimal) * a));
+                i++;
+            }
+            return floatResult;
+        
+        default:
+            long[] defaultResult = new long[value.length];
+     
+            for(long a : value)
+            {
+                defaultResult[i] = (long)(Math.round(Math.pow(10, decimal) * a));
+                i++;
+            }
+            return defaultResult;
+        }
+    }
 
     /**
      * compress data to other type through sub value for example: 1. subValue =
@@ -861,73 +1111,174 @@ public final class ValueCompressionUtil
         
         }
     }
-
+    
     /**
-     * uncompress data for example: int -> double
-     * 
+     * compress data to other type through sub value for example: 1. subValue =
+     * maxValue - value 2. subValue = subValue * Math.pow(10, decimal) 3.
+     * subValue: double->int
      */
-    public static UnCompressValue unCompressNone(DataType compDataType, DataType actualDataType)
+    private static Object compressNonDecimalMaxMin(DataType changedDataType, long[] value, int decimal, long maxValue)
     {
-        switch(compDataType)
+        int i=0;
+        switch(changedDataType)
         {
         case DATA_BYTE:
         
-            return new UnCompressNoneByte();
+            byte[] result = new byte[value.length];
+     
+            for(long a : value)
+            {
+                result[i] = (byte)(Math.round((maxValue - a) * Math.pow(10, decimal)));
+                i++;
+            }
+            return result;
         
         case DATA_SHORT:
         
-            return new UnCompressNoneShort();
+            short[] shortResult = new short[value.length];
+           
+            for(long a : value)
+            {
+                shortResult[i] = (byte)(Math.round((maxValue - a) * Math.pow(10, decimal)));
+                i++;
+            }
+            return shortResult;
         
         case DATA_INT:
         
-            return new UnCompressNoneInt();
+            int[] intResult = new int[value.length];
+           
+            for(long a : value)
+            {
+                intResult[i] = (byte)(Math.round((maxValue - a) * Math.pow(10, decimal)));
+                i++;
+            }
+            return intResult;
         
         case DATA_LONG:
         
-            return new UnCompressNoneLong();
+            long[] longResult = new long[value.length];
+          
+            for(long a : value)
+            {
+                longResult[i] = (byte)(Math.round((maxValue - a) * Math.pow(10, decimal)));
+                i++;
+            }
+            return longResult;
         
         case DATA_FLOAT:
         
-            return new UnCompressNoneFloat();
+            float[] floatResult = new float[value.length];
+ 
+            for(double a : value)
+            {
+                floatResult[i] = (byte)(Math.round((maxValue - a) * Math.pow(10, decimal)));
+                i++;
+            }
+            return floatResult;
         
         default:
         
-            return new UnCompressNoneDefault();
+            long[] defaultResult = new long[value.length];
+           
+            for(long a : value)
+            {
+                defaultResult[i] = (byte)(Math.round((maxValue - a) * Math.pow(10, decimal)));
+                i++;
+            }
+            return defaultResult;
         
         }
     }
 
     /**
+     * uncompress data for example: int -> double
+     * 
+     */
+    public static UnCompressValue unCompressNone(DataType compDataType, DataType actualDataType)
+    {
+        if (actualDataType == DataType.DATA_LONG)
+        {
+            return new UnCompressDefaultLong();
+        }
+        else
+        {
+            switch(compDataType)
+            {
+                case DATA_BYTE:
+
+                    return new UnCompressNoneByte();
+
+                case DATA_SHORT:
+
+                    return new UnCompressNoneShort();
+
+                case DATA_INT:
+
+                    return new UnCompressNoneInt();
+
+                case DATA_LONG:
+
+                    return new UnCompressNoneLong();
+
+                case DATA_FLOAT:
+
+                    return new UnCompressNoneFloat();
+
+                default:
+
+                    return new UnCompressNoneDefault();
+
+            }
+        }
+    }
+
+    /**
      * uncompress data 1. value = maxValue - subValue 2. value: int->double
      */
     public static UnCompressValue unCompressMaxMin(DataType compDataType, DataType actualDataType)
     {
-        switch(compDataType)
+        if(actualDataType == DataType.DATA_LONG)
         {
-        case DATA_BYTE:
-        
-            return new UnCompressMaxMinByte();
-        
-        case DATA_SHORT:
-        
-            return new UnCompressMaxMinShort();
-        
-        case DATA_INT:
-        
-            return new UnCompressMaxMinInt();
-        
-        case DATA_LONG:
-        
-            return new UnCompressMaxMinLong();
-        
-        case DATA_FLOAT:
-        
-            return new UnCompressMaxMinFloat();
-            
-        default:
-        
-            return new UnCompressMaxMinDefault();
-        
+            switch (compDataType)
+            {
+                case DATA_BYTE:
+                    return  new UnCompressMaxMinByteForLong();
+                case DATA_LONG:
+                    return new UnCompressMaxMinDefaultLong();
+                default:
+                    return new UnCompressMaxMinDefaultLong();
+            }
+        }
+        else
+        {
+            switch(compDataType)
+            {
+                case DATA_BYTE:
+
+                    return new UnCompressMaxMinByte();
+
+                case DATA_SHORT:
+
+                    return new UnCompressMaxMinShort();
+
+                case DATA_INT:
+
+                    return new UnCompressMaxMinInt();
+
+                case DATA_LONG:
+
+                    return new UnCompressMaxMinLong();
+
+                case DATA_FLOAT:
+
+                    return new UnCompressMaxMinFloat();
+
+                default:
+
+                    return new UnCompressMaxMinDefault();
+
+            }
         }
     }
     
@@ -1012,13 +1363,13 @@ public final class ValueCompressionUtil
             String measureMetaDataFileLocation, int measureCount)
     {
         DataInputStream stream = null;
-        double[] maxValue = new double[measureCount];
-        double[] minValue = new double[measureCount];
-        double[] uniqueValue = new double[measureCount];
+        Object[] maxValue = new Object[measureCount];
+        Object[] minValue = new Object[measureCount];
+        Object[] uniqueValue = new Object[measureCount];
         int[] decimalLength = new int[measureCount];
         char[] aggType = new char[measureCount];
         byte[] dataTypeSelected = new byte[measureCount];
-        double[] minValueFactForAgg = new double[measureCount];
+        Object[] minValueFactForAgg = new Object[measureCount];
         Arrays.fill(dataTypeSelected, (byte)1);
         Arrays.fill(aggType, 'n');
         int currentIndex = 0;
@@ -1051,14 +1402,34 @@ public final class ValueCompressionUtil
             MolapUtil.closeStreams(stream);
         }
         allocate.rewind();
+        
+        for(int i = 0;i < aggType.length;i++)
+        {
+            aggType[currentIndex++] = allocate.getChar();
+        }
+        currentIndex = 0;
         for(int i = 0;i < maxValue.length;i++)
         {
-            maxValue[currentIndex++] = allocate.getDouble();
+            if(aggType[i] == MolapCommonConstants.BIG_INT_MEASURE)
+            {
+                maxValue[currentIndex++] = allocate.getLong();
+            }
+            else
+            {
+                maxValue[currentIndex++] = allocate.getDouble();
+            }
         }
         currentIndex = 0;
         for(int i = 0;i < minValue.length;i++)
         {
-            minValue[currentIndex++] = allocate.getDouble();
+            if(aggType[i] == MolapCommonConstants.BIG_INT_MEASURE)
+            {
+                minValue[currentIndex++] = allocate.getLong();
+            }
+            else
+            {
+                minValue[currentIndex++] = allocate.getDouble();
+            }
         }
         currentIndex = 0;
         for(int i = 0;i < decimalLength.length;i++)
@@ -1068,15 +1439,18 @@ public final class ValueCompressionUtil
         currentIndex = 0;
         for(int i = 0;i < uniqueValue.length;i++)
         {
-            uniqueValue[currentIndex++] = allocate.getDouble();
-        }
-        
-        if(allocate.hasRemaining())
-        {
-            currentIndex = 0;
-            for(int i = 0;i < aggType.length;i++)
+            if(aggType[i] == MolapCommonConstants.BIG_INT_MEASURE)
+            {
+                uniqueValue[currentIndex++] = allocate.getLong();
+            }
+//            else if(aggType[i] == 'b')
+//            {
+//                BigDecimal val = new BigDecimal(allocate.getDouble());
+//                uniqueValue[currentIndex++] = val;
+//            }
+            else
             {
-                aggType[currentIndex++] = allocate.getChar();
+                uniqueValue[currentIndex++] = allocate.getDouble();
             }
         }
         if(allocate.hasRemaining())
@@ -1144,9 +1518,9 @@ public final class ValueCompressionUtil
     private static ValueCompressionModel getValueCompressionModel(MeasureMetaDataModel measureMDMdl)
     {
         int measureCount = measureMDMdl.getMeasureCount();
-        double[] minValue = measureMDMdl.getMinValue();
-        double[] maxValue = measureMDMdl.getMaxValue();
-        double[] uniqueValue = measureMDMdl.getUniqueValue();
+        Object[] minValue = measureMDMdl.getMinValue();
+        Object[] maxValue = measureMDMdl.getMaxValue();
+        Object[] uniqueValue = measureMDMdl.getUniqueValue();
         int[] decimal = measureMDMdl.getDecimal();
         char[] type = measureMDMdl.getType();
         byte[] dataTypeSelected = measureMDMdl.getDataTypeSelected();
@@ -1154,19 +1528,8 @@ public final class ValueCompressionUtil
         DataType[] actualType = new DataType[measureCount];
         DataType[] changedType = new DataType[measureCount];
         COMPRESSION_TYPE[] compType = new COMPRESSION_TYPE[measureCount];
-        double tempValue;
         for(int i = 0;i < measureCount;i++)
         {
-            tempValue=uniqueValue[i];
-            if(maxValue[i]>0 && tempValue<0)
-            {
-                tempValue=-1*tempValue;
-            }
-            if(tempValue>maxValue[i])
-            {
-                maxValue[i]=tempValue;
-            }
-
             CompressionFinder compresssionFinder = ValueCompressionUtil
                     .getCompressionType(maxValue[i], minValue[i], decimal[i],type[i],dataTypeSelected[i]);
             actualType[i] = compresssionFinder.actualDataType;
@@ -1177,6 +1540,7 @@ public final class ValueCompressionUtil
         compressionModel.setDecimal(decimal);
         compressionModel.setChangedDataType(changedType);
         compressionModel.setCompType(compType);
+        compressionModel.setActualDataType(actualType);
         compressionModel.setMinValue(minValue);
         compressionModel.setUniqueValue(uniqueValue);
         compressionModel.setType(type);
@@ -1184,6 +1548,7 @@ public final class ValueCompressionUtil
         compressionModel.setDataTypeSelected(dataTypeSelected);
         UnCompressValue[] values = ValueCompressionUtil.getUncompressedValues(
                 compressionModel.getCompType(),
+                compressionModel.getActualDataType(),
                 compressionModel.getChangedDataType());
         compressionModel.setUnCompressValues(values);
         return compressionModel;
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/datasight/molap/datatypes/ArrayDataType.java b/Molap/Molap-Data-Processor/src/com/huawei/datasight/molap/datatypes/ArrayDataType.java
deleted file mode 100644
index bcd0870..0000000
--- a/Molap/Molap-Data-Processor/src/com/huawei/datasight/molap/datatypes/ArrayDataType.java
+++ /dev/null
@@ -1,204 +0,0 @@
-package com.huawei.datasight.molap.datatypes;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.pentaho.di.core.exception.KettleException;
-
-import com.huawei.unibi.molap.keygenerator.KeyGenException;
-import com.huawei.unibi.molap.keygenerator.KeyGenerator;
-import com.huawei.unibi.molap.surrogatekeysgenerator.csvbased.MolapCSVBasedDimSurrogateKeyGen;
-
-public class ArrayDataType implements GenericDataType {
-	
-	private GenericDataType children;
-	
-	private String name;
-	
-	private String parentname;
-	
-	private int outputArrayIndex;
-	
-	private int dataCounter;
-	
-	@Override
-	public void addChildren(GenericDataType children) {
-		if(this.getName().equals(children.getParentname()))
-		{
-			this.children = children;
-		}
-		else
-		{
-			this.children.addChildren(children);
-		}
-	}
-	public ArrayDataType(String name, String parentname)
-	{
-		this.name = name;
-		this.parentname = parentname;
-	}
-	
-	@Override
-	public void setName(String name) {
-		this.name = name;
-	}
-	
-	@Override
-	public String getName() {
-		return name;
-	}
-	
-	@Override
-	public void setParentname(String parentname) {
-		this.parentname = parentname;
-		
-	}
-
-	@Override
-	public String getParentname() {
-		return parentname;
-	}
-	
-	@Override
-	public void getAllPrimitiveChildren(List<GenericDataType> primitiveChild) {
-		if (children instanceof PrimitiveDataType) 
-		{
-			primitiveChild.add(children);
-		}
-		else
-		{
-			children.getAllPrimitiveChildren(primitiveChild);
-		}
-	}
-	
-	
-	@Override
-	public int getSurrogateIndex() {
-		return 0;
-	}
-
-	@Override
-	public void setSurrogateIndex(int surrIndex) {
-		
-	}
-	@Override
-	public void parseStringAndWriteByteArray(String tableName, String inputString,
-			String[] delimiter, int delimiterIndex,
-			DataOutputStream dataOutputStream,
-			MolapCSVBasedDimSurrogateKeyGen surrogateKeyGen)
-			throws KettleException, IOException {
-		
-		if(inputString == null || inputString.equals("null"))
-		{
-			//Indicates null array
-			dataOutputStream.writeInt(0);
-		}
-		else
-		{
-			String[] splitInput = inputString.split(delimiter[delimiterIndex]);
-			dataOutputStream.writeInt(splitInput.length);
-			delimiterIndex = (delimiter.length - 1) == delimiterIndex ? delimiterIndex : delimiterIndex + 1;
-			for(String eachInput: splitInput)
-			{
-				children.parseStringAndWriteByteArray(tableName, eachInput, delimiter, delimiterIndex, dataOutputStream, surrogateKeyGen);
-			}
-		}
-	}
-	
-	@Override
-	public void parseAndBitPack(ByteBuffer byteArrayInput, DataOutputStream dataOutputStream, KeyGenerator[] generator) throws IOException, KeyGenException
-	{
-		int dataLength = byteArrayInput.getInt();
-		
-		dataOutputStream.writeInt(dataLength);
-		if(children instanceof PrimitiveDataType)
-		{
-			dataOutputStream.writeInt(generator[children.getSurrogateIndex()].getKeySizeInBytes());
-		}
-		for(int i=0;i<dataLength;i++)
-		{
-			children.parseAndBitPack(byteArrayInput, dataOutputStream, generator);
-		}
-		
-	}
-	@Override
-	public int getColsCount() {
-		return children.getColsCount() + 1;
-	}
-	
-	@Override
-	public void setOutputArrayIndex(int outputArrayIndex) {
-		this.outputArrayIndex = outputArrayIndex;
-		children.setOutputArrayIndex(outputArrayIndex + 1);
-	}
-	
-	@Override
-	public int getMaxOutputArrayIndex()
-	{
-		int currentMax = outputArrayIndex;
-		int childMax = children.getMaxOutputArrayIndex();
-		if(childMax > currentMax)
-		{
-			currentMax = childMax;
-		}
-		return currentMax;
-	}
-	
-	@Override
-	public void getColumnarDataForComplexType(
-			List<ArrayList<byte[]>> columnsArray, ByteBuffer inputArray) {
-		ByteBuffer b = ByteBuffer.allocate(8);
-		int dataLength = inputArray.getInt();
-		b.putInt(dataLength);
-		if(dataLength == 0)
-		{
-			b.putInt(0);
-		}
-		else
-		{
-			b.putInt(children.getDataCounter());
-		}
-		columnsArray.get(this.outputArrayIndex).add(b.array());
-
-		if(children instanceof PrimitiveDataType)
-		{
-			((PrimitiveDataType) children).setKeySize(inputArray.getInt());
-		}
-		for(int i=0;i<dataLength;i++)
-		{
-			children.getColumnarDataForComplexType(columnsArray, inputArray);
-		}
-		this.dataCounter++;
-	}
-	
-	@Override
-	public int getDataCounter()
-	{
-		return this.dataCounter;
-	}
-	
-	@Override
-	public void fillAggKeyBlock(List<Boolean> aggKeyBlockWithComplex, boolean[] aggKeyBlock)
-	{
-		aggKeyBlockWithComplex.add(false);
-		children.fillAggKeyBlock(aggKeyBlockWithComplex,aggKeyBlock);
-	}
-	
-	@Override
-	public void fillBlockKeySize(List<Integer> blockKeySizeWithComplex, int[] primitiveBlockKeySize)
-	{
-		blockKeySizeWithComplex.add(8);
-		children.fillBlockKeySize(blockKeySizeWithComplex, primitiveBlockKeySize);
-	}
-	
-	@Override
-	public void fillCardinalityAfterDataLoad(List<Integer> dimCardWithComplex, int[] maxSurrogateKeyArray)
-	{
-		dimCardWithComplex.add(0);
-		children.fillCardinalityAfterDataLoad(dimCardWithComplex, maxSurrogateKeyArray);
-	}
-	
-}
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/datasight/molap/datatypes/GenericDataType.java b/Molap/Molap-Data-Processor/src/com/huawei/datasight/molap/datatypes/GenericDataType.java
deleted file mode 100644
index b3ab7d7..0000000
--- a/Molap/Molap-Data-Processor/src/com/huawei/datasight/molap/datatypes/GenericDataType.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package com.huawei.datasight.molap.datatypes;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.pentaho.di.core.exception.KettleException;
-
-import com.huawei.unibi.molap.keygenerator.KeyGenException;
-import com.huawei.unibi.molap.keygenerator.KeyGenerator;
-import com.huawei.unibi.molap.surrogatekeysgenerator.csvbased.MolapCSVBasedDimSurrogateKeyGen;
-
-public interface GenericDataType {
-	
-	void setName(String name);
-	
-	String getName();
-
-	void setParentname(String parentname);
-	
-	String getParentname();
-	
-	void addChildren(GenericDataType children);
-	
-	void getAllPrimitiveChildren(List<GenericDataType> primitiveChild);
-	
-	void parseStringAndWriteByteArray(String tableName, String inputString, String[] delimiter, 
-			int delimiterIndex,	DataOutputStream dataOutputStream, 
-			MolapCSVBasedDimSurrogateKeyGen surrogateKeyGen) throws KettleException, IOException;
-	
-	int getSurrogateIndex();
-	
-	void setSurrogateIndex(int surrIndex);
-	
-	void parseAndBitPack(ByteBuffer byteArrayInput, DataOutputStream dataOutputStream, KeyGenerator[] generator) throws IOException, KeyGenException;
-	
-	int getColsCount();
-	
-	void setOutputArrayIndex(int outputArrayIndex);
-	
-	int getMaxOutputArrayIndex();
-	
-	void getColumnarDataForComplexType(List<ArrayList<byte[]>> columnsArray, ByteBuffer inputArray);
-	
-	int getDataCounter();
-	
-	void fillAggKeyBlock(List<Boolean> aggKeyBlockWithComplex, boolean[] aggKeyBlock);
-	
-	void fillBlockKeySize(List<Integer> blockKeySizeWithComplex, int[] primitiveBlockKeySize);
-	
-	void fillCardinalityAfterDataLoad(List<Integer> dimCardWithComplex, int[] maxSurrogateKeyArray);
-}
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/datasight/molap/datatypes/PrimitiveDataType.java b/Molap/Molap-Data-Processor/src/com/huawei/datasight/molap/datatypes/PrimitiveDataType.java
deleted file mode 100644
index d67c143..0000000
--- a/Molap/Molap-Data-Processor/src/com/huawei/datasight/molap/datatypes/PrimitiveDataType.java
+++ /dev/null
@@ -1,145 +0,0 @@
-package com.huawei.datasight.molap.datatypes;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.pentaho.di.core.exception.KettleException;
-
-import com.huawei.unibi.molap.keygenerator.KeyGenException;
-import com.huawei.unibi.molap.keygenerator.KeyGenerator;
-import com.huawei.unibi.molap.surrogatekeysgenerator.csvbased.MolapCSVBasedDimSurrogateKeyGen;
-
-public class PrimitiveDataType implements GenericDataType {
-
-	private int index;
-	
-	private String name;
-	private String parentname;
-	
-	private int keySize;
-	
-	private int outputArrayIndex;
-	
-	private int dataCounter;
-	
-	public PrimitiveDataType(String name, String parentname)
-	{
-		this.name = name;
-		this.parentname = parentname;
-	}
-	
-	@Override
-	public void addChildren(GenericDataType children) {
-
-	}
-
-	@Override
-	public void setName(String name) {
-		this.name = name;
-	}
-	
-	@Override
-	public String getName() {
-		return name;
-	}
-
-	@Override
-	public void setParentname(String parentname) {
-		this.parentname = parentname;
-		
-	}
-
-	@Override
-	public String getParentname() {
-		return parentname;
-	}
-	
-	@Override
-	public void getAllPrimitiveChildren(List<GenericDataType> primitiveChild) {
-
-	}
-
-	@Override
-	public int getSurrogateIndex() {
-		return index;
-	}
-
-	@Override
-	public void setSurrogateIndex(int surrIndex) {
-		index = surrIndex;
-	}
-
-	@Override
-	public void parseStringAndWriteByteArray(String tableName, String inputString,
-			String[] delimiter, int delimiterIndex,
-			DataOutputStream dataOutputStream,
-			MolapCSVBasedDimSurrogateKeyGen surrogateKeyGen) throws KettleException, IOException {
-		dataOutputStream.writeInt(surrogateKeyGen.generateSurrogateKeys(inputString,
-				tableName+"_"+name, index, new Object[0]));
-	}
-	
-	@Override
-	public void parseAndBitPack(ByteBuffer byteArrayInput, DataOutputStream dataOutputStream, KeyGenerator[] generator) throws IOException, KeyGenException
-	{
-		int data = byteArrayInput.getInt();
-		dataOutputStream.write(generator[index].generateKey(new int[]{data}));
-	}
-
-	@Override
-	public int getColsCount() {
-		return 1;
-	}
-
-	@Override
-	public void setOutputArrayIndex(int outputArrayIndex) {
-		this.outputArrayIndex = outputArrayIndex;
-	}
-	
-	@Override
-	public int getMaxOutputArrayIndex()
-	{
-		return outputArrayIndex;
-	}
-	
-
-	@Override
-	public void getColumnarDataForComplexType(
-			List<ArrayList<byte[]>> columnsArray, ByteBuffer inputArray) {
-		byte[] key = new byte[keySize];
-		inputArray.get(key);
-		columnsArray.get(outputArrayIndex).add(key);
-		dataCounter++;
-	}
-	
-	@Override
-	public int getDataCounter()
-	{
-		return this.dataCounter;
-	}
-	
-	public void setKeySize(int keySize)
-	{
-		this.keySize = keySize;
-	}
-	
-	@Override
-	public void fillAggKeyBlock(List<Boolean> aggKeyBlockWithComplex, boolean[] aggKeyBlock)
-	{
-		aggKeyBlockWithComplex.add(aggKeyBlock[index]);
-	}
-
-	@Override
-	public void fillBlockKeySize(List<Integer> blockKeySizeWithComplex, int[] primitiveBlockKeySize)
-	{
-		blockKeySizeWithComplex.add(primitiveBlockKeySize[index]);
-	}
-	
-	@Override
-	public void fillCardinalityAfterDataLoad(List<Integer> dimCardWithComplex, int[] maxSurrogateKeyArray)
-	{
-		dimCardWithComplex.add(maxSurrogateKeyArray[index]);
-	}
-}
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/datasight/molap/datatypes/StructDataType.java b/Molap/Molap-Data-Processor/src/com/huawei/datasight/molap/datatypes/StructDataType.java
deleted file mode 100644
index 8129130..0000000
--- a/Molap/Molap-Data-Processor/src/com/huawei/datasight/molap/datatypes/StructDataType.java
+++ /dev/null
@@ -1,234 +0,0 @@
-package com.huawei.datasight.molap.datatypes;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.pentaho.di.core.exception.KettleException;
-
-import com.huawei.unibi.molap.keygenerator.KeyGenException;
-import com.huawei.unibi.molap.keygenerator.KeyGenerator;
-import com.huawei.unibi.molap.surrogatekeysgenerator.csvbased.MolapCSVBasedDimSurrogateKeyGen;
-
-public class StructDataType implements GenericDataType {
-	
-	private List<GenericDataType> children = new ArrayList<GenericDataType>();
-	private String name;
-	private String parentname;
-	private int outputArrayIndex;
-	private int dataCounter;
-	
-	@Override
-	public void addChildren(GenericDataType newChild) {
-		if(this.getName().equals(newChild.getParentname()))
-		{
-			this.children.add(newChild);
-		}
-		else
-		{
-			for(GenericDataType child : this.children)
-			{
-				child.addChildren(newChild);
-			}
-		}
-		
-	}
-	
-	public StructDataType(String name, String parentname)
-	{
-		this.name = name;
-		this.parentname = parentname;
-	}
-	
-	@Override
-	public void setName(String name) {
-		this.name = name;
-	}
-	
-	@Override
-	public String getName() {
-		return name;
-	}
-	
-	@Override
-	public void setParentname(String parentname) {
-		this.parentname = parentname;
-		
-	}
-
-	@Override
-	public String getParentname() {
-		return parentname;
-	}
-	
-	@Override
-	public void getAllPrimitiveChildren(List<GenericDataType> primitiveChild) {
-		for(int i=0;i<children.size();i++)
-		{
-			GenericDataType child = children.get(i);
-			if (child instanceof PrimitiveDataType) 
-			{
-				primitiveChild.add(child);
-			}
-			else
-			{
-				child.getAllPrimitiveChildren(primitiveChild);
-			}
-		}
-	}
-	
-	@Override
-	public int getSurrogateIndex() {
-		return 0;
-	}
-
-	@Override
-	public void setSurrogateIndex(int surrIndex) {
-		
-	}
-
-	@Override
-	public void parseStringAndWriteByteArray(String tableName, String inputString,
-			String[] delimiter, int delimiterIndex,
-			DataOutputStream dataOutputStream,
-			MolapCSVBasedDimSurrogateKeyGen surrogateKeyGen)
-			throws KettleException, IOException {
-		if(inputString == null || inputString.equals("null"))
-		{
-			//Indicates null array
-			dataOutputStream.writeInt(0);
-		}
-		else
-		{
-			String[] splitInput = inputString.split(delimiter[delimiterIndex]);
-			dataOutputStream.writeInt(children.size());
-			delimiterIndex = (delimiter.length - 1) == delimiterIndex ? delimiterIndex : delimiterIndex + 1;
-			for(int i=0;i<children.size();i++)
-			{
-				children.get(i).parseStringAndWriteByteArray(tableName, splitInput[i], delimiter, delimiterIndex, dataOutputStream, surrogateKeyGen);
-			}
-		}
-	}
-	
-	@Override
-	public void parseAndBitPack(ByteBuffer byteArrayInput, DataOutputStream dataOutputStream, KeyGenerator[] generator) throws IOException, KeyGenException
-	{
-		int childElement = byteArrayInput.getInt();
-		dataOutputStream.writeInt(childElement);
-		for(int i=0;i<childElement;i++)
-		{
-			if(children.get(i) instanceof PrimitiveDataType)
-			{
-				dataOutputStream.writeInt(generator[children.get(i).getSurrogateIndex()].getKeySizeInBytes());
-			}
-			children.get(i).parseAndBitPack(byteArrayInput, dataOutputStream, generator);
-		}
-	}
-	
-	@Override
-	public int getColsCount() {
-		int colsCount = 1;
-		for(int i=0;i<children.size();i++)
-		{
-			colsCount += children.get(i).getColsCount();
-		}
-		return colsCount;
-	}
-	
-	@Override
-	public void setOutputArrayIndex(int outputArrayIndex) {
-		this.outputArrayIndex = outputArrayIndex++;
-		for(int i=0;i<children.size();i++)
-		{
-			if(children.get(i) instanceof PrimitiveDataType)
-			{
-				children.get(i).setOutputArrayIndex(outputArrayIndex++);
-			}
-			else
-			{
-				children.get(i).setOutputArrayIndex(outputArrayIndex++);
-				outputArrayIndex = getMaxOutputArrayIndex() + 1;
-			}
-		}
-	}
-	
-	@Override
-	public int getMaxOutputArrayIndex()
-	{
-		int currentMax = outputArrayIndex;
-		for(int i=0;i<children.size();i++)
-		{
-			int childMax = children.get(i).getMaxOutputArrayIndex();
-			if(childMax > currentMax)
-			{
-				currentMax = childMax;
-			}
-		}
-		return currentMax;
-	}
-	@Override
-	public void getColumnarDataForComplexType(
-			List<ArrayList<byte[]>> columnsArray, ByteBuffer inputArray) {
-		
-		ByteBuffer b = ByteBuffer.allocate(8);
-		int childElement = inputArray.getInt();
-		b.putInt(childElement);
-		if(childElement == 0)
-		{
-			b.putInt(0);
-		}
-		else
-		{
-			b.putInt(children.get(0).getDataCounter());
-		}
-		columnsArray.get(this.outputArrayIndex).add(b.array());
-
-		for(int i=0;i<childElement;i++)
-		{
-			if(children.get(i) instanceof PrimitiveDataType)
-			{
-				((PrimitiveDataType) children.get(i)).setKeySize(inputArray.getInt());
-			}
-			children.get(i).getColumnarDataForComplexType(columnsArray, inputArray);
-		}
-		this.dataCounter++;
-	}
-	
-	@Override
-	public int getDataCounter()
-	{
-		return this.dataCounter;
-	}
-	
-	@Override
-	public void fillAggKeyBlock(List<Boolean> aggKeyBlockWithComplex, boolean[] aggKeyBlock)
-	{
-		aggKeyBlockWithComplex.add(false);
-		for(int i=0;i<children.size();i++)
-		{
-			children.get(i).fillAggKeyBlock(aggKeyBlockWithComplex,aggKeyBlock);
-		}
-	}
-	
-	@Override
-	public void fillBlockKeySize(List<Integer> blockKeySizeWithComplex, int[] primitiveBlockKeySize)
-	{
-		blockKeySizeWithComplex.add(8);
-		for(int i=0;i<children.size();i++)
-		{
-			children.get(i).fillBlockKeySize(blockKeySizeWithComplex, primitiveBlockKeySize);
-		}
-	}
-	
-	@Override
-	public void fillCardinalityAfterDataLoad(List<Integer> dimCardWithComplex, int[] maxSurrogateKeyArray)
-	{
-		dimCardWithComplex.add(0);
-		for(int i=0;i<children.size();i++)
-		{
-			children.get(i).fillCardinalityAfterDataLoad(dimCardWithComplex, maxSurrogateKeyArray);
-		}
-	}
-}
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/aggregatesurrogategenerator/AggregateSurrogateGenerator.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/aggregatesurrogategenerator/AggregateSurrogateGenerator.java
index 4cc23fd..527fd54 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/aggregatesurrogategenerator/AggregateSurrogateGenerator.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/aggregatesurrogategenerator/AggregateSurrogateGenerator.java
@@ -11,7 +11,6 @@
  */
 package com.huawei.unibi.molap.aggregatesurrogategenerator;
 
-import java.util.List;
 //import java.util.Arrays;
 
 
@@ -117,9 +116,8 @@ public class AggregateSurrogateGenerator
      */
     public Object[] generateSurrogate(Object[] factTuple)
     {
-        // added 1 for the high card dims
         int size=measureIndex.length
-                + 1 +1;
+                + 1;
         if(isMdkeyInOutRowRequired)
         {
             size+=1;
@@ -131,10 +129,8 @@ public class AggregateSurrogateGenerator
         {
             records[count++] = factTuple[i];
         }
-        records[count++]=factTuple[i++];
-        // for high card cols.
-        records[count++]=(byte[])factTuple[i++];
-        byte[] mdkey= (byte[])factTuple[i++];
+        records[count++]=factTuple[i];
+        byte[] mdkey= (byte[])factTuple[factTuple.length-1];
         records[count++]=mdkey;
         if(isMdkeyInOutRowRequired)
         {
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/aggregatesurrogategenerator/step/MolapAggregateSurrogateGeneratorStep.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/aggregatesurrogategenerator/step/MolapAggregateSurrogateGeneratorStep.java
index a806cb2..a08508f 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/aggregatesurrogategenerator/step/MolapAggregateSurrogateGeneratorStep.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/aggregatesurrogategenerator/step/MolapAggregateSurrogateGeneratorStep.java
@@ -30,6 +30,7 @@ import com.huawei.iweb.platform.logging.LogServiceFactory;
 import com.huawei.unibi.molap.aggregatesurrogategenerator.AggregateSurrogateGenerator;
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.util.MolapDataProcessorLogEvent;
+import com.huawei.unibi.molap.util.MolapProperties;
 
 /**
  * Project Name NSE V3R8C10 
@@ -162,7 +163,11 @@ public class MolapAggregateSurrogateGeneratorStep extends BaseStep implements
                         meta.isMdkeyInOutRowRequired(), aggCardinality);
                 
                 this.logCounter = Integer
-                        .parseInt(MolapCommonConstants.DATA_LOAD_LOG_COUNTER_DEFAULT_COUNTER);
+                        .parseInt(MolapProperties
+                                .getInstance()
+                                .getProperty(
+                                        MolapCommonConstants.DATA_LOAD_LOG_COUNTER,
+                                        MolapCommonConstants.DATA_LOAD_LOG_COUNTER_DEFAULT_COUNTER));
 //                createStoreAndWriteSliceMetadata(meta.isManualAutoAggRequest(), factTuple, aggCardinality);
             }
             if(null == factTuple)
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/api/dataloader/SchemaInfo.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/api/dataloader/SchemaInfo.java
index a7c9028..b2c3cb2 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/api/dataloader/SchemaInfo.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/api/dataloader/SchemaInfo.java
@@ -76,26 +76,6 @@ public class SchemaInfo
      * isBackgroundMergingRequest
      */
     private boolean isBackgroundMergingRequest;
-    
-    private String complexDelimiterLevel1;
-
-    private String complexDelimiterLevel2;
-
-    public String getComplexDelimiterLevel1() {
-		return complexDelimiterLevel1;
-	}
-
-	public void setComplexDelimiterLevel1(String complexDelimiterLevel1) {
-		this.complexDelimiterLevel1 = complexDelimiterLevel1;
-	}
-
-	public String getComplexDelimiterLevel2() {
-		return complexDelimiterLevel2;
-	}
-
-	public void setComplexDelimiterLevel2(String complexDelimiterLevel2) {
-		this.complexDelimiterLevel2 = complexDelimiterLevel2;
-	}
 
     /**
      * 
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/csvload/GraphExecutionUtil.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/csvload/GraphExecutionUtil.java
index d6a6c73..f92284e 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/csvload/GraphExecutionUtil.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/csvload/GraphExecutionUtil.java
@@ -486,7 +486,7 @@ public final class GraphExecutionUtil
 
                         for(Level level : levels)
                         {
-                            if (level.visible && null == level.parentname)
+                            if (level.visible)
                             {
                                 columnNames.add(level.column.trim());
                             }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/dataprocessor/dataretention/DataRetentionHandler.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/dataprocessor/dataretention/DataRetentionHandler.java
index fdc8be5..1011aed 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/dataprocessor/dataretention/DataRetentionHandler.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/dataprocessor/dataretention/DataRetentionHandler.java
@@ -189,11 +189,6 @@ public class DataRetentionHandler
 
                 applyRetentionDetailsBasedOnRetentionMember();
 
-            // skip deleted and merged load folders.
-            if(!isLoadValid(listOfLoadMetadataDetails,molapFile.getName()))
-            {
-                continue;
-            }
                 /*
                  * if(retentionSurrogateKey==-1) { throw new
                  * MolapDataProcessorException("Invalid Date Member..."); }
@@ -241,40 +236,6 @@ public class DataRetentionHandler
 		return status;
 	}
 
-	 /**
-    * 
-    * @param loadMetadataDetails2
-    * @param name
-    * @return
-    */
-    private boolean isLoadValid(
-            List<LoadMetadataDetails> loadMetadataDetails2, String name)
-    {
-        String loadName = name.substring(name.indexOf(MolapCommonConstants.LOAD_FOLDER)+MolapCommonConstants.LOAD_FOLDER.length(), name.length());
-        
-        for(LoadMetadataDetails loads : loadMetadataDetails2)
-        {
-            if(loads.getLoadName().equalsIgnoreCase(loadName))
-            {
-                if(null != loads.getMergedLoadName())
-                {
-                    return false;
-                }
-                else if(loads.getLoadStatus().equalsIgnoreCase(MolapCommonConstants.MARKED_FOR_DELETE))
-                {
-                    return false;
-                }
-                return true;
-            }
-            else if( null != loads.getMergedLoadName() && loads.getMergedLoadName().equalsIgnoreCase(loadName) && !loads.getLoadStatus().equalsIgnoreCase(MolapCommonConstants.MARKED_FOR_DELETE))
-            {
-                return true;
-            }
-        }
-        
-        
-        return false;
-    }
     private void applyRetentionDetailsBasedOnRetentionMember()
     {
         measureLength = sliceMetadata.getMeasures().length;
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/dataprocessor/dataretention/MolapDataRetentionUtil.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/dataprocessor/dataretention/MolapDataRetentionUtil.java
index 502287f..ced3b22 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/dataprocessor/dataretention/MolapDataRetentionUtil.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/dataprocessor/dataretention/MolapDataRetentionUtil.java
@@ -5,15 +5,13 @@ import java.io.IOException;
 import java.nio.charset.Charset;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
-import java.util.List;
+//import java.util.HashMap;
 import java.util.Map;
 
 import org.apache.commons.codec.binary.Base64;
 
-import com.huawei.datasight.molap.core.load.LoadMetadataDetails;
 import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
@@ -253,65 +251,4 @@ public final class MolapDataRetentionUtil
         });
         return listFiles;
     }
-
-    /**
-     * 
-     * @param loadFiles
-     * @param loadMetadataDetails
-     * @return
-     */
-    public static MolapFile[] excludeUnwantedLoads(MolapFile[] loadFiles,
-            List<LoadMetadataDetails> loadMetadataDetails)
-    {
-        List<MolapFile> validLoads = new ArrayList<MolapFile>();
-        
-        List<String> validLoadsForRetention =  getValidLoadsForRetention(loadMetadataDetails);
-        
-        for(MolapFile loadFolder : loadFiles)
-        {
-            String loadName = loadFolder.getName().substring(loadFolder.getName().indexOf(MolapCommonConstants.LOAD_FOLDER)+MolapCommonConstants.LOAD_FOLDER.length(),loadFolder.getName().length() );
-            
-            if(validLoadsForRetention.contains(loadName))
-            {
-                validLoads.add(loadFolder);
-            }
-            
-        }
-        
-        
-        
-        
-        return validLoads.toArray(new MolapFile[validLoads.size()]);
-    }
-
-    /**
-     * 
-     * @param loadMetadataDetails
-     * @return
-     */
-    private static List<String> getValidLoadsForRetention(
-            List<LoadMetadataDetails> loadMetadataDetails)
-    {
-        List<String> validLoadNameForRetention = new ArrayList<String>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
-        
-        for(LoadMetadataDetails loadDetail : loadMetadataDetails )
-        {
-            //load should not be deleted and load should not be merged.
-            if(!loadDetail.getLoadStatus().equalsIgnoreCase(MolapCommonConstants.MARKED_FOR_DELETE))
-            {
-                if(null == loadDetail.getMergedLoadName())
-                {
-                    validLoadNameForRetention.add(loadDetail.getLoadName());
-                }
-                else
-                {
-                    validLoadNameForRetention.add(loadDetail.getMergedLoadName());
-                }
-                   
-            }
-            
-        }
-        
-        return validLoadNameForRetention;
-    }
 }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/factreader/MolapSliceTupleIterator.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/factreader/MolapSliceTupleIterator.java
index 1d57b19..d112542 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/factreader/MolapSliceTupleIterator.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/factreader/MolapSliceTupleIterator.java
@@ -58,7 +58,7 @@ public class MolapSliceTupleIterator implements
     /**
      * unique value if slice
      */
-    private double[] uniqueValue;
+    private Object[] uniqueValue;
 
     /**
      * mdkey length
@@ -166,13 +166,13 @@ public class MolapSliceTupleIterator implements
     private Object[] getMeasure()
     {
         Object[] measures = new Object[measureCount];
-        double values=0;
+        Object values=0;
         for(int i = 0;i < measures.length;i++)
         {
             if(aggType[i].charAt(0)=='n')
             {
                 values = dataHolder[i].getReadableDoubleValueByIndex(measureIndex);
-                if(values != uniqueValue[i])
+                if(!values.equals(uniqueValue[i]))
                 {
                     measures[i] = values;
                 }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/factreader/columnar/MolapColumnarLeafTupleIterator.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/factreader/columnar/MolapColumnarLeafTupleIterator.java
index 1e125ee..daabdd6 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/factreader/columnar/MolapColumnarLeafTupleIterator.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/factreader/columnar/MolapColumnarLeafTupleIterator.java
@@ -8,6 +8,7 @@ import com.huawei.unibi.molap.factreader.FactReaderInfo;
 import com.huawei.unibi.molap.factreader.MolapSurrogateTupleHolder;
 import com.huawei.unibi.molap.iterator.MolapIterator;
 import com.huawei.unibi.molap.metadata.LeafNodeInfoColumnar;
+import com.huawei.unibi.molap.olap.SqlStatement;
 import com.huawei.unibi.molap.util.ValueCompressionUtil;
 
 public class MolapColumnarLeafTupleIterator  implements
@@ -20,7 +21,7 @@ public class MolapColumnarLeafTupleIterator  implements
     /**
      * unique value if slice
      */
-    private double[] uniqueValue;
+    private Object[] uniqueValue;
 
     /**
      * hash next
@@ -131,13 +132,13 @@ public class MolapColumnarLeafTupleIterator  implements
     private Object[] getMeasure()
     {
         Object[] measures = new Object[measureCount];
-        double values=0;
+        Object values=0;
         for(int i = 0;i < measures.length;i++)
         {
             if(aggType[i]=='n')
             {
-                values = keyValue.getNormalMeasureValue(i);
-				if (isMeasureUpdateResuired && values != uniqueValue[i])
+                values = keyValue.getNormalMeasureValue(i, SqlStatement.Type.DOUBLE);
+				if (isMeasureUpdateResuired && !values.equals(uniqueValue[i]))
                 {
                     measures[i] = values;
                 }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/factreader/step/MolapFactReaderStep.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/factreader/step/MolapFactReaderStep.java
index 8baa8b1..f524ebe 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/factreader/step/MolapFactReaderStep.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/factreader/step/MolapFactReaderStep.java
@@ -22,6 +22,7 @@ import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 
+import com.huawei.unibi.molap.engine.aggregator.util.AggUtil;
 import org.eigenbase.xom.Parser;
 import org.eigenbase.xom.XOMUtil;
 import org.pentaho.di.core.exception.KettleException;
@@ -37,6 +38,7 @@ import org.pentaho.di.trans.step.StepMeta;
 import org.pentaho.di.trans.step.StepMetaInterface;
 
 
+
 //import com.huawei.datasight.molap.core.load.LoadMetadataDetails;
 import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
@@ -70,13 +72,13 @@ import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Measure;
 import com.huawei.unibi.molap.metadata.SliceMetaData;
 import com.huawei.unibi.molap.olap.MolapDef;
+import com.huawei.unibi.molap.olap.SqlStatement;
 import com.huawei.unibi.molap.olap.MolapDef.AggLevel;
 import com.huawei.unibi.molap.olap.MolapDef.AggMeasure;
 import com.huawei.unibi.molap.olap.MolapDef.Schema;
 import com.huawei.unibi.molap.util.MolapDataProcessorLogEvent;
 import com.huawei.unibi.molap.util.MolapProperties;
 import com.huawei.unibi.molap.util.MolapSchemaParser;
-import com.huawei.unibi.molap.util.RemoveDictionaryUtil;
 //import com.huawei.unibi.molap.util.MolapSliceAndFiles;
 import com.huawei.unibi.molap.util.MolapUtil;
 
@@ -162,9 +164,9 @@ public class MolapFactReaderStep extends BaseStep implements StepInterface
     List<DimensionAggregatorInfo> dimAggInfo;
     
     /**
-     * this is used to store the mapping of high card dims along with agg types.
+     * array of sql datatypes of mesaures and dimensions
      */
-    private boolean[] isHighCardinality;
+    protected SqlStatement.Type[] dataTypes;
     
     /**
      * 
@@ -213,24 +215,28 @@ public class MolapFactReaderStep extends BaseStep implements StepInterface
                 first = false;
                 meta.initialize();
                 this.logCounter = Integer
-                        .parseInt(MolapCommonConstants.DATA_LOAD_LOG_COUNTER_DEFAULT_COUNTER);
+                        .parseInt(MolapProperties
+                                .getInstance()
+                                .getProperty(
+                                        MolapCommonConstants.DATA_LOAD_LOG_COUNTER,
+                                        MolapCommonConstants.DATA_LOAD_LOG_COUNTER_DEFAULT_COUNTER));
                 setStepOutputInterface(meta.getAggType());
                 try
                 {
                     readCopies = Integer.parseInt(MolapProperties.getInstance()
-                            .getProperty(MolapCommonConstants.NUM_CORES_LOADING,
-                                    MolapCommonConstants.DEFAULT_NUMBER_CORES));
+                            .getProperty(MolapCommonConstants.CSV_READ_COPIES,
+                                    MolapCommonConstants.CSV_READ_COPIES_DEFAULT));
                 }
                 catch (NumberFormatException e)
                 {
                     LOGGER.error(
                             MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG,
                             "Invalid Value for: "
-                                    + MolapCommonConstants.NUM_CORES_LOADING
+                                    + MolapCommonConstants.CSV_READ_COPIES
                                     + "Default Value: "
-                                    + MolapCommonConstants.DEFAULT_NUMBER_CORES
+                                    + MolapCommonConstants.CSV_READ_COPIES_DEFAULT
                                     + " will be used");
-                    readCopies= Integer.parseInt(MolapCommonConstants.DEFAULT_NUMBER_CORES);
+                    readCopies= Integer.parseInt(MolapCommonConstants.CSV_READ_COPIES_DEFAULT);
                 }
                 this.executorService = Executors.newFixedThreadPool(readCopies);
                 this.threadStatusObserver= new ThreadStatusObserver();
@@ -321,6 +327,7 @@ public class MolapFactReaderStep extends BaseStep implements StepInterface
                     dimAggInfo = new ArrayList<DimensionAggregatorInfo>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
                     initQueryDims(cube);
                     initQueryMsrs(cube);
+                    AggUtil.initMeasureType(currentQueryMeasures);
                     aggTypes = getAggTypes();
                     SliceMetaData sliceMataData = null;
                     SliceExecutionInfo latestSliceInfo = null;
@@ -383,17 +390,9 @@ public class MolapFactReaderStep extends BaseStep implements StepInterface
                         value = queryResultIterator.getValue();
                         count++;
                         // length incremented by 2 (1 for mdkey and 1 for count)
-                        next = new Object[4];
+                        next = new Object[3];
                         next[j++] = value;
                         next[j++] = Double.valueOf(count);
-                        // converting high card dims into single byte buffer [].
-                        byte[] highCardByteArr = null;
-                                
-                        if(null != key.getDirectSurrogateKeyList())     
-                        {
-                            highCardByteArr = RemoveDictionaryUtil.convertListByteArrToSingleArr(key.getDirectSurrogateKeyList());
-                        }
-                        next[j++] = highCardByteArr;
                         next[j] = key.getMaskedKey();
                         putRow(data.outputRowMeta, next);
                         writeCounter++;
@@ -477,13 +476,13 @@ public class MolapFactReaderStep extends BaseStep implements StepInterface
 		holder.metaData = sliceMataData;
 		int[] measureOrdinal = new int[currentQueryMeasures.length];
 		boolean[] msrExists = new boolean[currentQueryMeasures.length];
-		double[] newMsrsDftVal = new double[currentQueryMeasures.length];
+		Object[] newMsrsDftVal = new Object[currentQueryMeasures.length];
 		RestructureUtil.updateMeasureInfo(sliceMataData, currentQueryMeasures,
 				measureOrdinal, msrExists, newMsrsDftVal);
     	SliceExecutionInfo info = new SliceExecutionInfo();
     	info.setIsMeasureExistis(msrExists);
     	info.setMsrDefaultValue(newMsrsDftVal);
-        double[] sliceUniqueValues = null;
+        Object[] sliceUniqueValues = null;
         boolean isCustomMeasure = false;
         sliceUniqueValues = slice.getDataCache(cube.getFactTableName()).getUniqueValue();
         char[] type = slice.getDataCache(cube.getFactTableName()).getType();
@@ -568,9 +567,9 @@ public class MolapFactReaderStep extends BaseStep implements StepInterface
         info.setCurrentSliceIndex(currentSliceIndex);
         int measureStartIndex = aggTypes.length - currentQueryMeasures.length;
         // check for is aggregate table here as second parameter below is isAggTable boolean (table from which data has to be read)
-        double[] msrMinValue = QueryExecutorUtility.getMinValueOfSlices(cube.getFactTableName(),
+        Object[] msrMinValue = QueryExecutorUtility.getMinValueOfSlices(cube.getFactTableName(),
                 false, activeSlices);
-        double[] queryMsrMinValue = new double[aggTypes.length]; 
+        Object[] queryMsrMinValue = new Object[aggTypes.length];
         for(int i = 0;i < currentQueryMeasures.length;i++)
         {
         	queryMsrMinValue[measureStartIndex + i] = msrMinValue[currentQueryMeasures[i].getOrdinal()];
@@ -580,6 +579,7 @@ public class MolapFactReaderStep extends BaseStep implements StepInterface
         info.setMeasureStartIndex(measureStartIndex);
         List<CustomMolapAggregateExpression> expression = new ArrayList<CustomMolapAggregateExpression>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
         info.setCustomExpressions(expression);
+        info.setDataTypes(dataTypes);
         return info;
     }
     
@@ -603,24 +603,8 @@ public class MolapFactReaderStep extends BaseStep implements StepInterface
     private String[] getAggTypes()
     {
         String[] aggTypes = new String[aggMeasures.length];
-        // initializing high card mapping.
-        isHighCardinality = new boolean[aggTypes.length];
-
-           // executerProperties.a
         for(int i = 0;i < aggMeasures.length;i++)
         {
-            if(null!=dimAggInfo)
-            {
-                for(DimensionAggregatorInfo dimAgg : dimAggInfo)
-                {
-                    // checking if the dimension aggregate is high cardinality or not.
-                    if(aggMeasures[i].column.equals(dimAgg.getColumnName())
-                            && dimAgg.getDim().isHighCardinalityDim())
-                    {
-                        isHighCardinality[i] = true;
-                    }
-                }
-            }
             aggTypes[i] = aggMeasures[i].aggregator;
         }
         return aggTypes;
@@ -635,6 +619,8 @@ public class MolapFactReaderStep extends BaseStep implements StepInterface
         int count = 0;
         int[] matchedIndexes = new int[aggMeasures.length];
         Measure[] measure = new Measure[aggMeasures.length];
+        dataTypes = new SqlStatement.Type[aggMeasures.length];
+        int typeCount = 0;
         for(int i = 0;i < aggMeasures.length;i++)
         {
             measure[i] = cube.getMeasure(meta.getTableName(),
@@ -651,9 +637,11 @@ public class MolapFactReaderStep extends BaseStep implements StepInterface
                 List<String> aggList = new ArrayList<String>(1);
                 aggList.add(aggMeasures[i].aggregator);
                 info.setAggList(aggList);
-                if(dimension!=null){
-                info.setColumnName(dimension.getColName());
-                info.setDim(dimension);
+                if(dimension != null)
+                {
+                    info.setColumnName(dimension.getColName());
+                    info.setDim(dimension);
+                    dataTypes[typeCount++] = dimension.getDataType();
                 }
                 dimAggInfo.add(info);
             }
@@ -662,6 +650,7 @@ public class MolapFactReaderStep extends BaseStep implements StepInterface
         for(int i = 0;i < count;i++)
         {
             currentQueryMeasures[i] = measure[matchedIndexes[i]];
+            dataTypes[typeCount++] = currentQueryMeasures[i].getDataType();
         }
     }
     /**
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/graphgenerator/GraphGenerator.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/graphgenerator/GraphGenerator.java
index 6207ad7..f972e97 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/graphgenerator/GraphGenerator.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/graphgenerator/GraphGenerator.java
@@ -78,7 +78,6 @@ import com.huawei.unibi.molap.util.MolapProperties;
 import com.huawei.unibi.molap.util.MolapSchemaParser;
 import com.huawei.unibi.molap.util.MolapUtil;
 import com.huawei.unibi.molap.util.MolapUtilException;
-import com.huawei.unibi.molap.util.RemoveDictionaryUtil;
 
 /**
  * Project Name 	: Carbon 
@@ -1004,8 +1003,8 @@ public class GraphGenerator
                 (StepMetaInterface)fileInputMeta);
         csvDataStep.setLocation(100, 100);
         int copies = Integer.parseInt(instance.getProperty(
-                MolapCommonConstants.NUM_CORES_LOADING,
-                MolapCommonConstants.DEFAULT_NUMBER_CORES));
+                MolapCommonConstants.CSV_READ_COPIES,
+                MolapCommonConstants.CSV_READ_COPIES_DEFAULT));
         if(copies > 1)
         {
             csvDataStep.setCopies(4);
@@ -1040,13 +1039,13 @@ public class GraphGenerator
         try
         {
             copies = Integer.parseInt(instance.getProperty(
-                    MolapCommonConstants.NUM_CORES_LOADING,
-                    MolapCommonConstants.DEFAULT_NUMBER_CORES));
+                    MolapCommonConstants.CSV_READ_COPIES,
+                    MolapCommonConstants.CSV_READ_COPIES_DEFAULT));
         }
         catch(NumberFormatException e)
         {
             copies = Integer
-                    .parseInt(MolapCommonConstants.DEFAULT_NUMBER_CORES);
+                    .parseInt(MolapCommonConstants.CSV_READ_COPIES_DEFAULT);
         }
         if(copies > 1)
         {
@@ -1080,8 +1079,8 @@ public class GraphGenerator
                 MolapCommonConstants.CSV_READ_BUFFER_SIZE,
                 MolapCommonConstants.CSV_READ_BUFFER_SIZE_DEFAULT));
         int copies = Integer.parseInt(instance.getProperty(
-                MolapCommonConstants.NUM_CORES_LOADING,
-                MolapCommonConstants.DEFAULT_NUMBER_CORES));
+                MolapCommonConstants.CSV_READ_COPIES,
+                MolapCommonConstants.CSV_READ_COPIES_DEFAULT));
         if(copies > 1)
         {
             csvDataStep.setCopies(copies);
@@ -1519,14 +1518,10 @@ public class GraphGenerator
         //
         MolapCSVBasedSeqGenMeta seqMeta = new MolapCSVBasedSeqGenMeta();
         seqMeta.setMolapdim(graphConfiguration.getDimensionString());
-        seqMeta.setComplexTypeString(graphConfiguration.getComplexTypeString());
         seqMeta.setBatchSize(Integer.parseInt(graphConfiguration.getBatchSize()));
-        seqMeta.setHighCardinalityDims(graphConfiguration.getHighCardinalityDims());
         // seqMeta.setStoreLocation(graphConfiguration.getStoreLocation());
         seqMeta.setCubeName(cubeName);
         seqMeta.setSchemaName(schemaName);
-        seqMeta.setComplexDelimiterLevel1(schemaInfo.getComplexDelimiterLevel1());
-        seqMeta.setComplexDelimiterLevel2(schemaInfo.getComplexDelimiterLevel2());
         seqMeta.setCurrentRestructNumber(graphConfiguration.getCurrentRestructNumber());
         seqMeta.setMolapMetaHier(graphConfiguration.getMetaHeirString());
         seqMeta.setMolapmsr(graphConfiguration.getMeasuresString());
@@ -1608,7 +1603,6 @@ public class GraphGenerator
         molapMdKey.setTableName(graphConfiguration.getTableName());
         molapMdKey.setSchemaName(schemaName);
         molapMdKey.setCubeName(cubeName);
-        molapMdKey.setComplexTypeString(graphConfiguration.getComplexTypeString());
         molapMdKey.setCurrentRestructNumber(graphConfiguration.getCurrentRestructNumber());
         molapMdKey.setAggregateLevels(MolapDataProcessorUtil
                 .getLevelCardinalitiesString(
@@ -1616,9 +1610,6 @@ public class GraphGenerator
                         graphConfiguration.getDimensions()));
         
         molapMdKey.setMeasureCount(graphConfiguration.getMeasureCount() + "");
-        molapMdKey.setDimensionCount(graphConfiguration.getActualDims().length + "");
-        molapMdKey.setComplexDimsCount(graphConfiguration.getComplexTypeString().isEmpty()?"0":graphConfiguration.getComplexTypeString().
-        		split(MolapCommonConstants.SEMICOLON_SPC_CHARACTER).length + "");
         StepMeta mdkeyStepMeta = new StepMeta(
                 GraphGeneratorConstants.MDKEY_GENERATOR
                         + graphConfiguration.getTableName(),
@@ -1634,7 +1625,6 @@ public class GraphGenerator
         mdkeyStepMeta.setDescription("Generate MDKey For Table Data: "
                 + GraphGeneratorConstants.MDKEY_GENERATOR
                 + graphConfiguration.getTableName());
-        molapMdKey.setHighCardinalityDims(graphConfiguration.getHighCardinalityDims());
 
         return mdkeyStepMeta;
     }
@@ -1651,12 +1641,6 @@ public class GraphGenerator
         molapDataWriter.setCurrentRestructNumber(MolapUtil
                 .getRestructureNumber(this.factStoreLocation,
                         this.factTableName));
-        
-        // getting the high cardinality string from graphjConfigurationForFact.
-        String[] highCardDims = RemoveDictionaryUtil.extractHighCardDimsArr(graphjConfigurationForFact.getHighCardinalityDims());
-        // using the string [] of high card dims , trying to get the count of the high cardinality dims in the agg query.
-        molapDataWriter.sethighCardCount(getHighCardDimsCountInAggQuery(highCardDims,graphConfiguration.getDimensions()));
-        
         processAutoAggRequest(graphConfiguration, graphjConfigurationForFact,
 				molapDataWriter);
         
@@ -1719,7 +1703,7 @@ public class GraphGenerator
         return molapDataWriterStep;
     }
 
-    /**
+	/**
 	 * @param graphConfiguration
 	 * @param graphjConfigurationForFact
 	 * @param molapDataWriter
@@ -2048,9 +2032,6 @@ public class GraphGenerator
         sortRowsMeta.setSchemaName(schemaName);
         sortRowsMeta.setCurrentRestructNumber(MolapUtil.getRestructureNumber(
                 this.factStoreLocation, this.factTableName));
-        
-        String[] highCardDims = RemoveDictionaryUtil.extractHighCardDimsArr(configurationInfoFact.getHighCardinalityDims());
-        sortRowsMeta.setHighCardinalityCount(getHighCardDimsCountInAggQuery(highCardDims,graphConfiguration.getDimensions()));
 //        sortRowsMeta.setOutputRowSize(actualMeasures.length + 1 + "");
         sortRowsMeta.setIsAutoAggRequest(isAutoAggRequest + "");
         boolean isFactMdKeyInInputRow = false;
@@ -2124,7 +2105,7 @@ public class GraphGenerator
 //            factDimensions = selectedFactDims;
         }
         String mdkeySize = getMdkeySizeInCaseOfAutoAggregate(
-                graphConfiguration.getDimensions(), factDimensions, factCardinality );
+                graphConfiguration.getDimensions(), factDimensions, factCardinality);
         sortRowsMeta.setMdkeyLength(mdkeySize);
         SliceMetaData sliceMetaData = MolapDataProcessorUtil.readSliceMetadata(factStoreLocation, currentRestructNumber);
         int[] globalDimensioncardinality = MolapDataProcessorUtil
@@ -2228,11 +2209,9 @@ public class GraphGenerator
         sortRowsMeta.setOutputRowSize(actualMeasures.length + 1 + "");
         sortRowsMeta.setCurrentRestructNumber(graphConfiguration.getCurrentRestructNumber());
         sortRowsMeta.setDimensionCount(graphConfiguration.getDimensions().length + "");
-        sortRowsMeta.setComplexDimensionCount(graphConfiguration.getComplexTypeString().isEmpty()?"0":graphConfiguration.getComplexTypeString().
-        		split(MolapCommonConstants.SEMICOLON_SPC_CHARACTER).length + "");
         sortRowsMeta.setIsUpdateMemberRequest(isUpdateMemberRequest + "");
         sortRowsMeta.setMeasureCount(graphConfiguration.getMeasureCount() + "");
-        sortRowsMeta.setHighCardinalityDims(graphConfiguration.getHighCardinalityDims());
+        sortRowsMeta.setMeasureDataType(graphConfiguration.getMeasureDataTypeInfo());
         StepMeta sortRowsStep = new StepMeta(
                 GraphGeneratorConstants.SORT_KEY_AND_GROUPBY
                         + graphConfiguration.getTableName(),
@@ -2261,21 +2240,14 @@ public class GraphGenerator
         CubeDimension[] dimensions = cube.dimensions;
         graphConfiguration.setDimensions(MolapSchemaParser.getCubeDimensions(
                 cube, schema));
-       // graphConfiguration.setHighCardinalityDims(MolapSchemaParser.getHighCardinalityDimensions(cube, schema));
         graphConfiguration.setActualDims(MolapSchemaParser.getDimensions(cube,
                 schema));
-        graphConfiguration.setComplexTypeString(MolapSchemaParser.getLevelDataTypeAndParentMapString(cube,
-        		schema));
         String factTableName = MolapSchemaParser.getFactTableName(cube);
         graphConfiguration.setTableName(factTableName);
         StringBuilder dimString = new StringBuilder();
         //
         int currentCount = MolapSchemaParser.getDimensionString(cube,
                 dimensions, dimString, 0, schema);
-        StringBuilder highCardinalitydimString = new StringBuilder();
-        MolapSchemaParser.getHighCardinalityDimensionString(cube,
-                dimensions, highCardinalitydimString, 0, schema);
-        graphConfiguration.setHighCardinalityDims(highCardinalitydimString.toString());
 
         String tableString = MolapSchemaParser.getTableNameString(
                 factTableName, dimensions, schema);
@@ -2598,27 +2570,4 @@ public class GraphGenerator
     {
         return cube;
     }
-    
-    /**
-     * 
-     * @param highCardDims
-     * @param actualDims
-     * @return
-     */
-    private int getHighCardDimsCountInAggQuery(String[] highCardDims,
-            String[] actualDims)
-    {
-        int count = 0;
-        for(String eachSelectedDim : actualDims)
-        {
-            for(String eachHighCardDim : highCardDims)
-            {
-                if(eachSelectedDim.equalsIgnoreCase(eachHighCardDim))
-                {
-                    count++;
-                }
-            }
-        }
-        return count;
-    }
 }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/graphgenerator/configuration/GraphConfigurationInfo.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/graphgenerator/configuration/GraphConfigurationInfo.java
index a3340f0..60e41d5 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/graphgenerator/configuration/GraphConfigurationInfo.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/graphgenerator/configuration/GraphConfigurationInfo.java
@@ -80,12 +80,6 @@ public class GraphConfigurationInfo
     /**
      * 
      */
-     private String  highCardinalityDims;
-
-
-	/**
-     * 
-     */
     private String [] measures;
     
     /**
@@ -177,7 +171,6 @@ public class GraphConfigurationInfo
      * 
      */
     private String [] actualDims;
-
     /**
      * Sets the dimension:hirearchy#levelnames1,levelName2 
      */
@@ -192,13 +185,8 @@ public class GraphConfigurationInfo
      * mdkeySize
      */
     private String mdkeySize;
-    
-	/**
-	 * complexTypeString
-	 */
-	private String complexTypeString;
 
-	/**
+    /**
      * measureCount
      */
     
@@ -379,14 +367,6 @@ public class GraphConfigurationInfo
         this.tableName = tableName;
     }
 
-    public String getComplexTypeString() {
-		return complexTypeString;
-	}
-
-	public void setComplexTypeString(String complexTypeString) {
-		this.complexTypeString = complexTypeString;
-	}
-	
     /**
      * @return the leafNodeSize
      */
@@ -1246,19 +1226,4 @@ public class GraphConfigurationInfo
         this.levelAnddataType = levelAnddataType;
     }
 
-    /**
-     * getHighCardinalityDims.
-     * @return
-     */
-    public String getHighCardinalityDims() {
-		return highCardinalityDims;
-	}
-
-    /**
-     * setHighCardinalityDims.
-     * @param highCardinalityDims
-     */
-	public void setHighCardinalityDims(String highCardinalityDims) {
-		this.highCardinalityDims = highCardinalityDims;
-	}
 }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/groupby/MolapAutoAggGroupBy.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/groupby/MolapAutoAggGroupBy.java
index 8b3f806..f80044d 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/groupby/MolapAutoAggGroupBy.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/groupby/MolapAutoAggGroupBy.java
@@ -20,6 +20,7 @@ import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.math.BigDecimal;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
 
@@ -90,12 +91,12 @@ public class MolapAutoAggGroupBy
     /**
      * max value for each measure
      */
-    protected double[] maxValue;
+    protected Object[] maxValue;
 
     /**
      * min value for each measure
      */
-    protected double[] minValue;
+    protected Object[] minValue;
 
     /**
      * decimal length of each measure
@@ -105,7 +106,7 @@ public class MolapAutoAggGroupBy
     /**
      * uniqueValue
      */
-    protected double[] uniqueValue;
+    protected Object[] uniqueValue;
     
     /**
      * max value for each measure
@@ -202,7 +203,7 @@ public class MolapAutoAggGroupBy
     /**
      * mergedMinValue
      */
-    protected double[] mergedMinValue;
+    protected Object[] mergedMinValue;
     
     
     /**
@@ -243,10 +244,10 @@ public class MolapAutoAggGroupBy
      */
     private void initialiseMaxMinDecimal(String extension)
     {
-        this.maxValue = new double[this.aggType.length];
-        this.minValue = new double[this.aggType.length];
+        this.maxValue = new Object[this.aggType.length];
+        this.minValue = new Object[this.aggType.length];
         this.decimalLength = new int[this.aggType.length];
-        this.uniqueValue = new double[this.aggType.length];
+        this.uniqueValue = new Object[this.aggType.length];
         for(int i = 0;i < this.aggType.length;i++)
         {
             maxValue[i] = -Double.MAX_VALUE;
@@ -263,7 +264,7 @@ public class MolapAutoAggGroupBy
                 this.type[i]='c';
             }
         }
-        mergedMinValue=MolapDataProcessorUtil.updateMergedMinValue(schemaName, cubeName, tableName,this.aggType.length,extension, currentRestructNumber);
+        mergedMinValue=MolapDataProcessorUtil.updateMergedMinValue(schemaName, cubeName, tableName, this.aggType.length, extension, currentRestructNumber);
     }
 
     /**
@@ -378,8 +379,7 @@ public class MolapAutoAggGroupBy
             {
                 this.isNotNullValue[i]=true;
                 double value=(Double)row[i];
-                aggregators[i].agg(value, (byte[])row[row.length - 1],
-                        0, ((byte[])row[row.length - 1]).length);
+                aggregators[i].agg(value);
             }
         }
         prvKey = (byte[])row[this.keyIndex];
@@ -467,7 +467,20 @@ public class MolapAutoAggGroupBy
                     if(isNotNullValue[i])
                     {
                         writeStream.write(1);
-                        writeStream.writeDouble(aggregators[i].getValue());
+                        //TODO ggin: chect i
+                        switch (AggUtil.getMeasureType(AggUtil.measureOrdinal[i]))
+                        {
+                            case BIGINT:
+
+                                writeStream.writeLong(aggregators[i].getLongValue());
+                                break;
+                            case DECIMAL:
+
+                                writeStream.writeUTF(aggregators[i].getBigDecimalValue().toString());
+                                break;
+                            default:
+                                writeStream.writeDouble(aggregators[i].getDoubleValue());
+                        }
                     }
                     else
                     {
@@ -524,28 +537,34 @@ public class MolapAutoAggGroupBy
             throw new MolapGroupByException(
                     "Problem while deleting the measure meta data file ", e1);
         }
-        try
-        {
-            for(int i = 0;i < aggType.length;i++)
-            {
-                if(aggType[i].equals(MolapCommonConstants.DISTINCT_COUNT) || aggType[i].equals(MolapCommonConstants.CUSTOM))
-                {
-                    type[i]='c';
-                }
-                else
-                {
-                    type[i]='n';
-                }
-            }
-            MolapDataProcessorUtil.writeMeasureMetaDataToFileForAgg(maxValue,
-                    minValue, decimalLength, uniqueValue,this.type,new byte[this.maxValue.length],mergedMinValue,
-                    measureMetaDataFileLocation);
-        }
-        catch(MolapDataProcessorException e1)
-        {
-            throw new MolapGroupByException(
-                    "Problem while writing the measure meta data file ", e1);
-        }
+//        try
+//        {
+//            for(int i = 0;i < aggType.length;i++)
+//            {
+//                if(aggType[i].equals(MolapCommonConstants.DISTINCT_COUNT) || aggType[i].equals(MolapCommonConstants.CUSTOM))
+//                {
+//                    type[i]='c';
+//                }
+//                else
+//                {
+//                    type[i]='n';
+//                }
+//            }
+////  TODO here we hard code just for test query
+//            double[] mergedminvalue = new double[mergedMinValue.length];
+//            for(int i = 0; i < mergedMinValue.length; i++)
+//            {
+//                mergedminvalue[i] = (double)mergedMinValue[i];
+//            }
+//            MolapDataProcessorUtil.writeMeasureMetaDataToFileForAgg(maxValue,
+//                    minValue, decimalLength, uniqueValue,this.type,new byte[this.maxValue.length],mergedminvalue,
+//                    measureMetaDataFileLocation);
+//        }
+//        catch(MolapDataProcessorException e1)
+//        {
+//            throw new MolapGroupByException(
+//                    "Problem while writing the measure meta data file ", e1);
+//        }
         try
         {
             // creating reading strem
@@ -656,8 +675,7 @@ public class MolapAutoAggGroupBy
             if(null != row[i])
             {
                 double value=(Double)row[i];
-                aggregators[i].agg(value, (byte[])row[row.length - 1],
-                        0, ((byte[])row[row.length - 1]).length);
+                aggregators[i].agg(value);
             }
         }
         calculateMaxMinUnique();
@@ -673,13 +691,36 @@ public class MolapAutoAggGroupBy
     {
         for(int i = 0;i < aggregators.length;i++)
         {
+            int num;
             if(isNotNullValue[i])
             {
-                double value = (Double)aggregators[i].getValue();
-                maxValue[i] = (maxValue[i] > value ? maxValue[i] : value);
-                minValue[i] = (minValue[i] < value ? minValue[i] : value);
-                uniqueValue[i] = minValue[i] - 1;
-                int num = (value % 1 == 0) ? 0 : decimalPointers;
+                switch (AggUtil.getMeasureType(AggUtil.measureOrdinal[i]))
+                {
+                    case BIGINT:
+                        long valueL = aggregators[i].getLongValue();
+                        maxValue[i] = ((long)maxValue[i] > valueL ? maxValue[i] : valueL);
+                        minValue[i] = ((double)minValue[i] < valueL ? minValue[i] : valueL);
+                        uniqueValue[i] = (double)minValue[i] - 1;
+                        num = (valueL % 1 == 0) ? 0 : decimalPointers;
+
+                        break;
+                    case DECIMAL:
+
+                        BigDecimal valueD = aggregators[i].getBigDecimalValue();
+                        maxValue[i] = (new BigDecimal(maxValue[i].toString()).compareTo(valueD) == 1 ? maxValue[i] : valueD);
+                        minValue[i] = (new BigDecimal(maxValue[i].toString()).compareTo(valueD) == -1 ? minValue[i] : valueD);
+                        uniqueValue[i] = (double)minValue[i] - 1;
+                        num = (valueD.doubleValue() % 1 == 0) ? 0 : decimalPointers;
+                        break;
+                    default:
+
+                        double value = aggregators[i].getDoubleValue();
+                        maxValue[i] = ((double)maxValue[i] > value ? maxValue[i] : value);
+                        minValue[i] = ((double)minValue[i] < value ? minValue[i] : value);
+                        uniqueValue[i] = (double)minValue[i] - 1;
+                        num = (value % 1 == 0) ? 0 : decimalPointers;
+                }
+
                 decimalLength[i] = (decimalLength[i] > num ? decimalLength[i] : num);
             }
         }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/groupby/MolapAutoAggGroupByExtended.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/groupby/MolapAutoAggGroupByExtended.java
index c88f84f..fce5684 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/groupby/MolapAutoAggGroupByExtended.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/groupby/MolapAutoAggGroupByExtended.java
@@ -48,8 +48,7 @@ public class MolapAutoAggGroupByExtended extends MolapAutoAggGroupBy
             if(null != row[i])
             {
                 this.isNotNullValue[i]=true;
-                aggregators[i].agg(row[i], (byte[])row[keyIndex],
-                        0, 0);
+                aggregators[i].agg(row[i]);
             }
         }
         prvKey = (byte[])row[this.keyIndex];
@@ -70,8 +69,7 @@ public class MolapAutoAggGroupByExtended extends MolapAutoAggGroupBy
         {
             if(null != row[i])
             {
-                aggregators[i].agg(row[i], (byte[])row[keyIndex],
-                        0, 0);
+                aggregators[i].agg(row[i]);
             }
         }
         calculateMaxMinUnique();
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/mdkeygen/MDKeyGenStep.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/mdkeygen/MDKeyGenStep.java
index 85b23e5..369e11d 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/mdkeygen/MDKeyGenStep.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/mdkeygen/MDKeyGenStep.java
@@ -16,18 +16,8 @@ wcFcE9sOJA21XxKLHhsfpiNjOXWVDTusYXFm8W8GB9h6a5aIG6Laf6S5m92gQg==*/
 */
 package com.huawei.unibi.molap.mdkeygen;
 
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
 import java.io.File;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
 
 import org.pentaho.di.core.exception.KettleException;
 import org.pentaho.di.core.row.RowMeta;
@@ -40,16 +30,15 @@ import org.pentaho.di.trans.step.StepDataInterface;
 import org.pentaho.di.trans.step.StepMeta;
 import org.pentaho.di.trans.step.StepMetaInterface;
 
-import com.huawei.datasight.molap.datatypes.GenericDataType;
 import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
 import com.huawei.iweb.platform.logging.impl.StandardLogService;
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
+import com.huawei.unibi.molap.datastorage.store.compression.ValueCompressionModel;
 import com.huawei.unibi.molap.file.manager.composite.FileData;
 import com.huawei.unibi.molap.file.manager.composite.IFileManagerComposite;
 import com.huawei.unibi.molap.file.manager.composite.LoadFolderData;
 import com.huawei.unibi.molap.keygenerator.KeyGenException;
-import com.huawei.unibi.molap.keygenerator.KeyGenerator;
 import com.huawei.unibi.molap.keygenerator.factory.KeyGeneratorFactory;
 import com.huawei.unibi.molap.store.MolapFactDataHandlerColumnar;
 import com.huawei.unibi.molap.store.MolapFactHandler;
@@ -59,7 +48,7 @@ import com.huawei.unibi.molap.util.MolapDataProcessorLogEvent;
 import com.huawei.unibi.molap.util.MolapProperties;
 import com.huawei.unibi.molap.util.MolapUtil;
 import com.huawei.unibi.molap.util.MolapUtilException;
-import com.huawei.unibi.molap.util.RemoveDictionaryUtil;
+import com.huawei.unibi.molap.util.ValueCompressionUtil;
 
 /**
  * Project Name 	: Carbon 
@@ -91,11 +80,6 @@ public class MDKeyGenStep extends BaseStep
     private int dimensionCount;
     
     /**
-     * dimsLenIncludingComplexPrimitives
-     */
-    private int dimsLenIncludingComplexPrimitives;
-    
-    /**
      * table name
      */
     private String tableName;
@@ -105,8 +89,6 @@ public class MDKeyGenStep extends BaseStep
      */
     private IFileManagerComposite fileManager;
     
-    private Map<Integer,GenericDataType> complexIndexMap;
-    
     /**
      * readCounter
      */
@@ -128,6 +110,8 @@ public class MDKeyGenStep extends BaseStep
      */
     private MolapFactHandler dataHandler;
     
+    private char[] aggType;
+    
     /**
      * MolapMDKeyGenStep
      * 
@@ -167,7 +151,6 @@ public class MDKeyGenStep extends BaseStep
             StandardLogService.setThreadName(StandardLogService.getPartitionID(meta.getCubeName()), null);
             data = (MDKeyGenStepData)sdi;
             
-            meta.initialize();
             Object[] row = getRow();
             if(first)
             {
@@ -295,25 +278,12 @@ public class MDKeyGenStep extends BaseStep
               return false;
         }
         
-        this.meta.setHighCardinalityCount(RemoveDictionaryUtil.extractHighCardCount(this.meta.getHighCardinalityDims()));
-        
         String levelCardinalityFilePath = storeLocation + File.separator + 
 				MolapCommonConstants.LEVEL_METADATA_FILE + meta.getTableName() + ".metadata";
         
         int[] dimLens = null;
 		try {
-			int[] dimLensWithComplex = MolapUtil.getCardinalityFromLevelMetadataFile(levelCardinalityFilePath);
-			List<Integer> dimsLenList = new ArrayList<Integer>();
-			for(int eachDimLen : dimLensWithComplex)
-			{
-				if(eachDimLen != 0)
-					dimsLenList.add(eachDimLen);
-			}
-			dimLens = new int[dimsLenList.size()];
-			for(int i=0;i<dimsLenList.size();i++)
-			{
-				dimLens[i] = dimsLenList.get(i);
-			}
+			dimLens = MolapUtil.getCardinalityFromLevelMetadataFile(levelCardinalityFilePath);
 		} catch (MolapUtilException e) {
 			LOGGER.error(
                     MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG,
@@ -327,46 +297,10 @@ public class MDKeyGenStep extends BaseStep
                     "Cardinality could not determined. Nothing to process further in MDKeyGenstep");
 			return false;
 		}
-  
-		data.generator = new KeyGenerator[dimLens.length + 1];
-		for(int i=0;i<dimLens.length;i++)
-		{
-			data.generator[i] = KeyGeneratorFactory.getKeyGenerator(new int[]{dimLens[i]});
-		}
         
-//      this.dimensionCount = dimLens.length;
-      this.dimensionCount = meta.getDimensionCount();
-      this.dimsLenIncludingComplexPrimitives = dimLens.length;
-      
-      int simpleDimsCount = this.dimensionCount - meta.getComplexDimsCount();
-      int[] simpleDimsLen = new int[simpleDimsCount];
-      for(int i=0;i<simpleDimsCount;i++)
-      {
-      	simpleDimsLen[i] = dimLens[i];
-      }
-      
-      //Actual primitive dimension used to generate start & end key 
-      data.generator[dimLens.length] = KeyGeneratorFactory.getKeyGenerator(simpleDimsLen);
-      
-      //To Set MDKey Index of each primitive type in complex type 
-      int surrIndex = simpleDimsCount;
-      Iterator<Entry<String,GenericDataType>> complexMap = meta.getComplexTypes().entrySet().iterator();
-      complexIndexMap = new HashMap<Integer,GenericDataType>(meta.getComplexDimsCount());
-      while(complexMap.hasNext())
-      {
-          Entry<String,GenericDataType> complexDataType = complexMap.next();
-          complexDataType.getValue().setOutputArrayIndex(0);
-          complexIndexMap.put(simpleDimsCount, complexDataType.getValue());
-          simpleDimsCount++;
-          List<GenericDataType> primitiveTypes = new ArrayList<GenericDataType>();
-          complexDataType.getValue().getAllPrimitiveChildren(primitiveTypes);
-          for(GenericDataType eachPrimitive : primitiveTypes)
-          {
-          	eachPrimitive.setSurrogateIndex(surrIndex++);
-          }
-      }
-      
+        data.generator = KeyGeneratorFactory.getKeyGenerator(dimLens);
         
+        this.dimensionCount = dimLens.length;
         this.measureCount = meta.getMeasureCount();
 
         String metaDataFileName = MolapCommonConstants.MEASURE_METADATA_FILE_NAME
@@ -378,34 +312,31 @@ public class MDKeyGenStep extends BaseStep
         // Set the data file location
         this.dataFolderLocation = baseStorelocation + File.separator +
         		MolapCommonConstants.SORT_TEMP_FILE_LOCATION + File.separator + this.tableName;
-        
-        /*finalMerger = new SingleThreadFinalSortFilesMerger(dataFolderLocation,
-    			tableName, dimensionCount, measureCount,meta.getHighCardinalityDims().length);*/
+        ValueCompressionModel valueCompressionModel = getValueCompressionModel(storeLocation);
+        aggType = valueCompressionModel.getType();
         finalMerger = new SingleThreadFinalSortFilesMerger(dataFolderLocation,
-                tableName, dimensionCount - meta.getComplexDimsCount(), meta.getComplexDimsCount(), measureCount,meta.getHighCardinalityCount());
-        if(meta.getHighCardinalityCount() > 0)
-        {
-            dataHandler = new MolapFactDataHandlerColumnar(
-                    meta.getSchemaName(), meta.getCubeName(), this.tableName,
-                    false, measureCount, data.generator[dimLens.length].getKeySizeInBytes(),
-                    measureCount + 1, null, null, storeLocation, dimLens,
-                    false, false, dimLens, null, null, true,
-                    meta.getCurrentRestructNumber(),
-                    meta.getHighCardinalityCount(), dimensionCount, complexIndexMap);
-        }
-        else
-        {
-            dataHandler = new MolapFactDataHandlerColumnar(
-                    meta.getSchemaName(), meta.getCubeName(), this.tableName,
-                    false, measureCount, data.generator[dimLens.length].getKeySizeInBytes(),
-                    measureCount, null, null, storeLocation, dimLens,
-                    false, false, dimLens, null, null, true,
-                    meta.getCurrentRestructNumber(),
-                    meta.getHighCardinalityCount(), dimensionCount, complexIndexMap);
-        }
+    			tableName, dimensionCount, measureCount, aggType);
+        
+        dataHandler = new MolapFactDataHandlerColumnar(meta.getSchemaName(),
+                meta.getCubeName(), this.tableName, false, measureCount,
+                data.generator.getKeySizeInBytes(), measureCount, null, null,
+                storeLocation, dimLens, false, false, dimLens, null, null,
+                true, meta.getCurrentRestructNumber(),
+                valueCompressionModel);
+        
         return true;
     }
-
+    
+    private ValueCompressionModel getValueCompressionModel(String storeLocation)
+    {
+        String measureMetaDataFileLoc = storeLocation
+                + MolapCommonConstants.MEASURE_METADATA_FILE_NAME 
+                + this.tableName
+                + MolapCommonConstants.MEASUREMETADATA_FILE_EXT;
+        return ValueCompressionUtil.getValueCompressionModel(
+                measureMetaDataFileLoc, this.measureCount);
+    }
+    
     /**
      * This method will be used for setting the output interface.
      * Output interface is how this step will process the row to next step  
@@ -448,41 +379,26 @@ public class MDKeyGenStep extends BaseStep
      */
     private Object[] process(Object[] row) throws KettleException
     {
-        Object[] outputRow = null;
-        // adding one for the high cardinality dims byte array.
-        if(meta.getHighCardinalityCount() > 0 || meta.getComplexDimsCount() > 0)
-        {
-        	outputRow = new Object[measureCount + 1 + 1];
-        }
-        else
-        {
-            outputRow = new Object[measureCount + 1];
-        }
+    	Object[] outputRow = new Object[measureCount + 1];
         int[] keys = new int[this.dimensionCount];
-
         int l = 0;
-        int index = 0;
-        for(int i = 0; i < measureCount; i++)
+        
+        for(int i = this.dimensionCount; i < row.length; i++)
         {
-//            if(null != row[i])
-//            {
-            
-            	outputRow[l++] = (Double)RemoveDictionaryUtil.getMeasure(index++, row);
-//            }
+            outputRow[l++] = row[i];
         }
-        outputRow[l] =  RemoveDictionaryUtil.getByteArrayForNoDictionaryCols(row);
         
         // copy all the dimension to keys Array. This key array will be used to generate id
         for(int i = 0; i < this.dimensionCount; i++)
         {
-            Object key = RemoveDictionaryUtil.getDimension(i, row);
+            Object key = row[i];
             keys[i] = (Integer)key;
         }
         
         try
         {
             // generate byte array from id.
-            byte[] k = data.generator[data.generator.length-1].generateKey(keys);
+            byte[] k = data.generator.generateKey(keys);
             outputRow[outputRow.length - 1] = k;
         }
         catch(KeyGenException e)
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/mdkeygen/MDKeyGenStepData.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/mdkeygen/MDKeyGenStepData.java
index 890603d..71d51e1 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/mdkeygen/MDKeyGenStepData.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/mdkeygen/MDKeyGenStepData.java
@@ -47,9 +47,9 @@ public class MDKeyGenStepData extends BaseStepData implements
   //  protected RowMetaInterface rowMeta;
     
     /**
-     * generator for each column independently
+     * generator
      */
-    protected KeyGenerator[] generator;
+    protected KeyGenerator generator;
     
     /**
      * precomputed default objects
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/mdkeygen/MDKeyGenStepMeta.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/mdkeygen/MDKeyGenStepMeta.java
index edb93bb..1d2c330 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/mdkeygen/MDKeyGenStepMeta.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/mdkeygen/MDKeyGenStepMeta.java
@@ -18,7 +18,6 @@ ha0lV5CtaKBMz+q4WgyOq9DZZsMS3YQWs9M5OKLquLd1C9HNPFoI0S8QtbtLrA==*/
  */
 package com.huawei.unibi.molap.mdkeygen;
 
-import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -41,11 +40,6 @@ import org.pentaho.di.trans.step.StepMeta;
 import org.pentaho.di.trans.step.StepMetaInterface;
 import org.w3c.dom.Node;
 
-import com.huawei.datasight.molap.datatypes.ArrayDataType;
-import com.huawei.datasight.molap.datatypes.GenericDataType;
-import com.huawei.datasight.molap.datatypes.PrimitiveDataType;
-import com.huawei.datasight.molap.datatypes.StructDataType;
-import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.util.MolapDataProcessorUtil;
 
 /**
@@ -59,7 +53,7 @@ import com.huawei.unibi.molap.util.MolapDataProcessorUtil;
  */
 public class MDKeyGenStepMeta extends BaseStepMeta implements StepMetaInterface
 {
-	/**
+    /**
      * for i18n purposes
      */
     private static Class<?> pkg = MDKeyGenStepMeta.class;
@@ -94,31 +88,8 @@ public class MDKeyGenStepMeta extends BaseStepMeta implements StepMetaInterface
      */
     private String measureCount;
     
-    /**
-     * dimensionCount
-     */
-    private String dimensionCount;
-    
-    /**
-     * complexDimsCount
-     */
-    private String complexDimsCount;
-    
-    /**
-     * ComplexTypeString
-     */
-    private String complexTypeString;
-    
-    private Map<String, GenericDataType> complexTypes;
-    
     private int currentRestructNumber;
     
-	private String  highCardinalityDims;
-	
-	 /**
-     * highCardinalityCount 
-     */
-    private int highCardinalityCount;
     /**
      * Constructor
      */
@@ -135,7 +106,6 @@ public class MDKeyGenStepMeta extends BaseStepMeta implements StepMetaInterface
         aggregateLevels = "";
         cubeName = "";
         schemaName = "";
-        highCardinalityDims="";
         currentRestructNumber = -1;
     }
 
@@ -151,11 +121,7 @@ public class MDKeyGenStepMeta extends BaseStepMeta implements StepMetaInterface
         retval.append("    ").append(XMLHandler.addTagValue("NumberOfCores", numberOfCores));
         retval.append("    ").append(XMLHandler.addTagValue("cubeName", cubeName));
         retval.append("    ").append(XMLHandler.addTagValue("schemaName", schemaName));
-        retval.append("    ").append(XMLHandler.addTagValue("highCardinalityDims", highCardinalityDims));
         retval.append("    ").append(XMLHandler.addTagValue("measureCount", measureCount));
-        retval.append("    ").append(XMLHandler.addTagValue("dimensionCount", dimensionCount));
-        retval.append("    ").append(XMLHandler.addTagValue("complexDimsCount", complexDimsCount));
-        retval.append("    ").append(XMLHandler.addTagValue("complexTypeString", complexTypeString));
         retval.append("    ").append(XMLHandler.addTagValue("currentRestructNumber", currentRestructNumber));
         return retval.toString();
     }
@@ -172,11 +138,7 @@ public class MDKeyGenStepMeta extends BaseStepMeta implements StepMetaInterface
             numberOfCores = XMLHandler.getTagValue(stepnode, "NumberOfCores");
             schemaName = XMLHandler.getTagValue(stepnode, "schemaName");
             cubeName = XMLHandler.getTagValue(stepnode, "cubeName");
-            highCardinalityDims = XMLHandler.getTagValue(stepnode, "highCardinalityDims");
             measureCount = XMLHandler.getTagValue(stepnode, "measureCount");
-            dimensionCount = XMLHandler.getTagValue(stepnode, "dimensionCount");
-            complexDimsCount = XMLHandler.getTagValue(stepnode, "complexDimsCount");
-            complexTypeString = XMLHandler.getTagValue(stepnode, "complexTypeString");
             currentRestructNumber = Integer.parseInt(XMLHandler.getTagValue(
                     stepnode, "currentRestructNumber"));
         }
@@ -202,11 +164,7 @@ public class MDKeyGenStepMeta extends BaseStepMeta implements StepMetaInterface
             rep.saveStepAttribute(idTransformation, idStep, "NumberOfCores", numberOfCores);
             rep.saveStepAttribute(idTransformation, idStep, "schemaName", schemaName);
             rep.saveStepAttribute(idTransformation, idStep, "cubeName", cubeName);
-            rep.saveStepAttribute(idTransformation, idStep, "highCardinalityDims", highCardinalityDims);
             rep.saveStepAttribute(idTransformation, idStep, "measureCount", measureCount);
-            rep.saveStepAttribute(idTransformation, idStep, "dimensionCount", dimensionCount);
-            rep.saveStepAttribute(idTransformation, idStep, "complexDimsCount", complexDimsCount);
-            rep.saveStepAttribute(idTransformation, idStep, "complexTypeString", complexTypeString);
             rep.saveStepAttribute(idTransformation, idStep, "currentRestructNumber", 
                     currentRestructNumber);
         }
@@ -229,11 +187,7 @@ public class MDKeyGenStepMeta extends BaseStepMeta implements StepMetaInterface
             numberOfCores = rep.getStepAttributeString(idStep, "NumberOfCores");
             schemaName = rep.getStepAttributeString(idStep, "schemaName");
             cubeName = rep.getStepAttributeString(idStep, "cubeName");
-            highCardinalityDims=rep.getStepAttributeString(idStep, "highCardinalityDims");
             measureCount = rep.getStepAttributeString(idStep, "measureCount");
-            dimensionCount = rep.getStepAttributeString(idStep, "dimensionCount");
-            complexDimsCount = rep.getStepAttributeString(idStep, "complexDimsCount");
-            complexTypeString = rep.getStepAttributeString(idStep, "complexTypeString");
             currentRestructNumber = (int)rep.getStepAttributeInteger(idStep, 
                     "currentRestructNumber");
         }
@@ -283,15 +237,7 @@ public class MDKeyGenStepMeta extends BaseStepMeta implements StepMetaInterface
     {
         return aggregateLevels;
     }
-    
-    public Map<String, GenericDataType> getComplexTypes() {
-		return complexTypes;
-	}
 
-	public void setComplexTypes(Map<String, GenericDataType> complexTypes) {
-		this.complexTypes = complexTypes;
-	}
-    
     public String getNumberOfCores()
     {
         return numberOfCores;
@@ -325,30 +271,6 @@ public class MDKeyGenStepMeta extends BaseStepMeta implements StepMetaInterface
     {
         this.measureCount = measureCount;
     }
-    
-    /**
-     * @param dimensionCount the dimensionCount to set
-     */
-    public void setDimensionCount(String dimensionCount)
-    {
-    	this.dimensionCount = dimensionCount;
-    }
-    
-    /**
-     * @param complexDimsCount the complexDimsCount to set
-     */
-    public void setComplexDimsCount(String complexDimsCount)
-    {
-    	this.complexDimsCount = complexDimsCount;
-    }
-
-    /**
-     * @param complexTypeString the complexTypeString to set
-     */
-    public void setComplexTypeString(String complexTypeString)
-    {
-    	this.complexTypeString = complexTypeString;
-    }
 
     /**
      * @param cubeName the cubeName to set
@@ -357,7 +279,7 @@ public class MDKeyGenStepMeta extends BaseStepMeta implements StepMetaInterface
     {
         this.cubeName = cubeName;
     }
-    
+
     /**
      * @param schemaName the schemaName to set
      */
@@ -375,30 +297,6 @@ public class MDKeyGenStepMeta extends BaseStepMeta implements StepMetaInterface
     }
     
     /**
-     * @return the dimensionCount
-     */
-    public int getDimensionCount()
-    {
-    	return Integer.parseInt(dimensionCount);
-    }
-
-    /**
-     * @return the complexDimsCount
-     */
-    public int getComplexDimsCount()
-    {
-    	return Integer.parseInt(complexDimsCount);
-    }
-
-    /**
-     * @return the complexTypeString
-     */
-    public int getComplexTypeString()
-    {
-    	return Integer.parseInt(complexTypeString);
-    }
-    
-    /**
      * @return the currentRestructNumber
      */
     public int getCurrentRestructNumber()
@@ -413,73 +311,5 @@ public class MDKeyGenStepMeta extends BaseStepMeta implements StepMetaInterface
     {
         this.currentRestructNumber = currentRestructNum;
     }
-    /**
-     * 
-     * @return
-     */
-    public String  getHighCardinalityDims() {
-		return highCardinalityDims;
-	}
 
-    /**
-     * 
-     * @param highCardinalityDims
-     */
-	public void setHighCardinalityDims(String  highCardinalityDims) {
-		this.highCardinalityDims = highCardinalityDims;
-	}
-	
-	/**
-     * @return the highCardinalityCount
-     */
-    public int getHighCardinalityCount()
-    {
-        return highCardinalityCount;
-    }
-
-    /**
-     * @param highCardinalityCount the highCardinalityCount to set
-     */
-    public void setHighCardinalityCount(int highCardinalityCount)
-    {
-        this.highCardinalityCount = highCardinalityCount;
-    }
-    
-    public void initialize()
-    {
-    	complexTypes = getComplexTypesMap(complexTypeString);
-    }
-    private Map<String,GenericDataType> getComplexTypesMap(String complexTypeString)
-    {
-    	if(null==complexTypeString)
-    	{
-    		return new LinkedHashMap<>();
-    	}
-    	Map<String,GenericDataType> complexTypesMap = new LinkedHashMap<String,GenericDataType>();
-    	String[] hierarchies = complexTypeString.split(MolapCommonConstants.SEMICOLON_SPC_CHARACTER);
-        for(int i = 0;i < hierarchies.length;i++)
-        {
-            String[] levels = hierarchies[i].split(MolapCommonConstants.HASH_SPC_CHARACTER);
-            String[] levelInfo = levels[0].split(MolapCommonConstants.COLON_SPC_CHARACTER);
-			GenericDataType g = levelInfo[1].equals("Array")?
-						new ArrayDataType(levelInfo[0], ""):new StructDataType(levelInfo[0], "");
-			complexTypesMap.put(levelInfo[0], g);
-            for(int j = 1;j < levels.length;j++)
-            {
-            	levelInfo = levels[j].split(MolapCommonConstants.COLON_SPC_CHARACTER);
-				switch(levelInfo[1])
-				{
-					case "Array" : 
-						g.addChildren(new ArrayDataType(levelInfo[0], levelInfo[2]));
-						break;
-					case "Struct" : 
-						g.addChildren(new StructDataType(levelInfo[0], levelInfo[2]));
-						break;
-					default :
-						g.addChildren(new PrimitiveDataType(levelInfo[0], levelInfo[2]));
-				}
-            }
-        }
-        return complexTypesMap;
-    }
 }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/mdkeygen/MolapMDKeyGenStep.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/mdkeygen/MolapMDKeyGenStep.java
index e492b9f..237c2e9 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/mdkeygen/MolapMDKeyGenStep.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/mdkeygen/MolapMDKeyGenStep.java
@@ -420,11 +420,11 @@ public class MolapMDKeyGenStep extends BaseStep implements StepInterface
         //    System.out.println("Number of times came.");
 //            startProcesses();
             // writre data to measure meta file
-            try
-            {
-                MolapDataProcessorUtil.writeMeasureMetaDataToFile(maxValue,
-                        minValue, decimalLength, uniqueValue,type,new byte[this.maxValue.length],
-                        measureMetaDataFileLocation);
+//            try
+//            {
+//                MolapDataProcessorUtil.writeMeasureMetaDataToFile(maxValue,
+//                        minValue, decimalLength, uniqueValue,type,new byte[this.maxValue.length],
+//                        measureMetaDataFileLocation);
                 FileData fileData = (FileData)fileManager.get(0);
                 String storePath = fileData.getStorePath();
                 String inProgFileName = fileData.getFileName();
@@ -435,12 +435,12 @@ public class MolapMDKeyGenStep extends BaseStep implements StepInterface
                 File destFile = new File(changedFileName);
                 currentFile.renameTo(destFile);
                 fileData.setName(changedFileName);
-            }
-            catch(MolapDataProcessorException e)
-            {
-                throw new KettleException(
-                        "Problem while writing the measure meta file", e);
-            }
+//            }
+//            catch(MolapDataProcessorException e)
+//            {
+//                throw new KettleException(
+//                        "Problem while writing the measure meta file", e);
+//            }
             LOGGER.info(MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG, "Record Procerssed For table: "+ this.tableName);
             String logMessage= "Finished Molap Mdkey Generation Step: Read: " + readCounter + ": Write: "+ writeCounter;
             LOGGER.info(MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG, logMessage);
@@ -774,7 +774,9 @@ public class MolapMDKeyGenStep extends BaseStep implements StepInterface
 
         }
         
-        logCounter = Integer.parseInt(MolapCommonConstants.DATA_LOAD_LOG_COUNTER_DEFAULT_COUNTER);
+        logCounter = Integer.parseInt(instance.getProperty(
+                MolapCommonConstants.DATA_LOAD_LOG_COUNTER,
+                MolapCommonConstants.DATA_LOAD_LOG_COUNTER_DEFAULT_COUNTER));
     }
 
     /**
@@ -1242,18 +1244,18 @@ public class MolapMDKeyGenStep extends BaseStep implements StepInterface
         String measuremetaDataFilepath = sortTempFileLoc + File.separator
                 + metaDataFileName;
 
-        try
-        {
-            MolapDataProcessorUtil.writeMeasureMetaDataToFile(this.maxValue,
-                    this.minValue, this.decimalLength, this.uniqueValue,this.type,new byte[this.maxValue.length],
-                    measuremetaDataFilepath);
-        }
-        catch(MolapDataProcessorException e)
-        {
-            LOGGER.error(
-                    MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG,
-                    "Not able to write temp measure metadatafile.");
-        }
+//        try
+//        {
+//            MolapDataProcessorUtil.writeMeasureMetaDataToFile(this.maxValue,
+//                    this.minValue, this.decimalLength, this.uniqueValue,this.type,new byte[this.maxValue.length],
+//                    measuremetaDataFilepath);
+//        }
+//        catch(MolapDataProcessorException e)
+//        {
+//            LOGGER.error(
+//                    MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG,
+//                    "Not able to write temp measure metadatafile.");
+//        }
 
         // first check if the metadata file already present the take backup and
         // rename inprofress file to
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/MolapColumnarSliceMerger.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/MolapColumnarSliceMerger.java
index 94a87b7..b8e498c 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/MolapColumnarSliceMerger.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/MolapColumnarSliceMerger.java
@@ -1,7 +1,6 @@
 package com.huawei.unibi.molap.merger;
 
 import java.io.File;
-import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
@@ -18,8 +17,6 @@ import com.huawei.unibi.molap.datastorage.store.compression.ValueCompressionMode
 import com.huawei.unibi.molap.datastorage.store.filesystem.MolapFile;
 import com.huawei.unibi.molap.datastorage.store.impl.FileFactory;
 import com.huawei.unibi.molap.exception.MolapDataProcessorException;
-import com.huawei.unibi.molap.keygenerator.KeyGenerator;
-import com.huawei.unibi.molap.keygenerator.factory.KeyGeneratorFactory;
 import com.huawei.unibi.molap.merger.columnar.ColumnarFactFileMerger;
 import com.huawei.unibi.molap.merger.columnar.impl.NonTimeBasedMergerColumnar;
 import com.huawei.unibi.molap.merger.columnar.impl.TimeBasedMergerColumnar;
@@ -28,15 +25,11 @@ import com.huawei.unibi.molap.merger.sliceMerger.DimesionMappingFileMerger;
 import com.huawei.unibi.molap.merger.sliceMerger.HierarchyFileMerger;
 import com.huawei.unibi.molap.metadata.LeafNodeInfoColumnar;
 import com.huawei.unibi.molap.metadata.SliceMetaData;
-
-
 import com.huawei.unibi.molap.schema.metadata.AggregateTable;
 import com.huawei.unibi.molap.schema.metadata.MolapColumnarFactMergerInfo;
 import com.huawei.unibi.molap.util.ByteUtil;
-import com.huawei.unibi.molap.util.MolapCoreLogEvent;
 import com.huawei.unibi.molap.util.MolapDataProcessorLogEvent;
 import com.huawei.unibi.molap.util.MolapDataProcessorUtil;
-import com.huawei.unibi.molap.util.MolapMergerUtil;
 import com.huawei.unibi.molap.util.MolapProperties;
 import com.huawei.unibi.molap.util.MolapSchemaParser;
 import com.huawei.unibi.molap.util.MolapSliceAndFiles;
@@ -59,10 +52,6 @@ public class MolapColumnarSliceMerger implements MolapSliceMerger
      * table name to be merged
      */
     private String tableName;
-    
-    private List<String> loadsToBeMerged;
-    
-    private String mergedLoadName;
 
     /**
      * logger
@@ -136,24 +125,20 @@ public class MolapColumnarSliceMerger implements MolapSliceMerger
             cube.name = cube.name + '_' + molapSliceMergerInfo.getPartitionID();
         }
         this.tableName = molapSliceMergerInfo.getTableName();
-        
-        this.loadsToBeMerged = molapSliceMergerInfo.getLoadsToBeMerged();
-        
-        this.mergedLoadName = molapSliceMergerInfo.getMergedLoadName();
     }
 
     @Override
-    public boolean fullMerge(int currentRestructNumber) throws SliceMergerException
+    public void fullMerge(int currentRestructNumber) throws SliceMergerException
     {
-        
         String hdfsLocation = MolapProperties.getInstance().getProperty(
                 MolapCommonConstants.STORE_LOCATION_HDFS)
                 + '/' + schema.name + '/' + cube.name;
 
         LOGGER.info(MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG,"HDFS Location: "+ hdfsLocation);
-//        String tempLocationKey = schema.name + '/' + cube.name;
+//        System.out.println("HDFS Location: "+ hdfsLocation);
+        String tempLocationKey = schema.name + '/' + cube.name;
         String localStore = MolapProperties.getInstance().getProperty(
-                MolapCommonConstants.STORE_LOCATION,
+                tempLocationKey,
                 MolapCommonConstants.STORE_LOCATION_DEFAULT_VAL)
                 + '/' + schema.name + '/' + cube.name;
 
@@ -166,33 +151,10 @@ public class MolapColumnarSliceMerger implements MolapSliceMerger
         hdfsLocation = hdfsLocation + '/'
                 + MolapCommonConstants.RESTRUCTRE_FOLDER + restrctFolderCount
                 + '/' + tableName;
-        
-        
-        
-        try
-        {
-            if(!FileFactory.isFileExist(hdfsLocation, FileFactory.getFileType(hdfsLocation)))
-            {
-                return false;
-            }
-        }
-        catch(IOException e)
-        {
-            LOGGER.error(
-                    MolapCoreLogEvent.UNIBI_MOLAPCORE_MSG ,
-                    "Error occurred :: " + e.getMessage());
-        }
-        
-        
-        
-        List<MolapSliceAndFiles> slicesFromHDFS = MolapMergerUtil.getSliceAndFilesList(
-                hdfsLocation, this.tableName,FileFactory.getFileType(hdfsLocation),loadsToBeMerged);
-        
-        if(slicesFromHDFS.isEmpty())
-        {
-            return false;
-        }
-        
+        List<MolapSliceAndFiles> slicesFromHDFS = MolapUtil.getSlicesFromHDFS(
+                hdfsLocation, this.tableName, FileFactory.getFileType(hdfsLocation));
+        String[] lastloadFolder = slicesFromHDFS.get(slicesFromHDFS.size() - 1)
+                .getPath().split("_");
         localStore = localStore
                 + '/'
                 + MolapCommonConstants.RESTRUCTRE_FOLDER
@@ -200,16 +162,18 @@ public class MolapColumnarSliceMerger implements MolapSliceMerger
                 + '/'
                 + tableName
                 +'/'
-                + MolapCommonConstants.LOAD_FOLDER+mergedLoadName;
+                + MolapCommonConstants.LOAD_FOLDER
+                + (Integer.parseInt(lastloadFolder[lastloadFolder.length - 1]) + 1);
 
         String destinationLocation = localStore
+                + MolapCommonConstants.MERGERD_EXTENSION
                 + MolapCommonConstants.FILE_INPROGRESS_STATUS;
       File file = new File(destinationLocation);
       if(!file.mkdirs())
       {
           throw new SliceMergerException("Problem while creating the destination location for slicemerging");
-          
       }
+      
       startMerge(slicesFromHDFS,
               MolapUtil.readSliceMetaDataFile(hdfsLocation, restrctFolderCount),file.getAbsolutePath(), restrctFolderCount);
       
@@ -217,12 +181,61 @@ public class MolapColumnarSliceMerger implements MolapSliceMerger
       {
           throw new SliceMergerException("Problem while renaming the destination location for slicemerging");
       }
-      return true;
     }
 
+//    @Override
+//    public void fullMerge() throws SliceMergerException
+//    {
+//        String hdfsLocation = MolapProperties.getInstance().getProperty(
+//                MolapCommonConstants.STORE_LOCATION,
+//                MolapCommonConstants.STORE_LOCATION_DEFAULT_VAL)
+//                + "/" + schema.name + "/" + cube.name;
+//
+//        String localStore = MolapProperties.getInstance().getProperty(
+//                MolapCommonConstants.STORE_LOCATION,
+//                MolapCommonConstants.STORE_LOCATION_DEFAULT_VAL)
+//                + "/" + schema.name + "/" + cube.name;
+//
+//        int restrctFolderCount = MolapUtil
+//                .checkAndReturnNextRestructFolderNumber(hdfsLocation);
+//        if(restrctFolderCount == -1)
+//        {
+//            restrctFolderCount = 0;
+//        }
+//        hdfsLocation = hdfsLocation + File.separator
+//                + MolapCommonConstants.RESTRUCTRE_FOLDER + restrctFolderCount
+//                + File.separator + tableName;
+//        List<MolapSliceAndFiles> slicesFromHDFS = MolapUtil.getSlicesFromLocal(
+//                hdfsLocation, this.tableName);
+//
+//        if(slicesFromHDFS.size() < 2)
+//        {
+//            return;
+//        }
+//        String[] lastloadFolder = slicesFromHDFS.get(slicesFromHDFS.size() - 1)
+//                .getPath().split("_");
+//        localStore = localStore
+//                + File.separator
+//                + MolapCommonConstants.RESTRUCTRE_FOLDER
+//                + restrctFolderCount
+//                + File.separator
+//                + tableName
+//                + File.separator
+//                + MolapCommonConstants.LOAD_FOLDER
+//                + (Integer.parseInt(lastloadFolder[lastloadFolder.length - 1]) + 1)
+//                + MolapCommonConstants.MERGERD_EXTENSION
+//                + MolapCommonConstants.FILE_INPROGRESS_STATUS;
+//
+//        File file = new File(localStore);
+//        file.mkdirs();
+//        startMerge(slicesFromHDFS,
+//                MolapUtil.readSliceMetaDataFile(hdfsLocation),
+//                file.getAbsolutePath());
+//    }
 
     /**
      * startMerge
+     * 
      * @throws SliceMergerException
      * @throws MolapDataProcessorException
      */
@@ -232,17 +245,43 @@ public class MolapColumnarSliceMerger implements MolapSliceMerger
             throws SliceMergerException
     {
         String factTableName = MolapSchemaParser.getFactTableName(this.cube);
+        if(MolapCommonConstants.MOLAP_AUTO_TYPE_VALUE
+                .equalsIgnoreCase(this.cube.autoAggregationType)
+                || MolapCommonConstants.MOLAP_MANUAL_TYPE_VALUE
+                        .equalsIgnoreCase(this.cube.autoAggregationType))
+        {
+            AggregateTable[] aggregateTables = MolapSchemaParser
+                    .getAggregateTable(this.cube, schema);
+            String[] aggregator = null;
             if(factTableName.equals(this.tableName))
             {
                 mergerSlice(slicesFromHDFS, sliceMetaData, null, null,
                         destinationLocation, currentRestructNumber);
             }
+            else
+            {
+                for(int i = 0;i < aggregateTables.length;i++)
+                {
+                    if(aggregateTables[i].getAggregateTableName().equals(
+                            this.tableName))
+                    {
+                        aggregator = aggregateTables[i].getAggregator();
+                        aggregator = MolapDataProcessorUtil
+                                .getUpdatedAggregator(aggregator);
+                        mergerSlice(slicesFromHDFS, sliceMetaData, aggregator,
+                                aggregateTables[i].getAggregateClass(),
+                                destinationLocation, currentRestructNumber);
+                        break;
                     }
+                }
+            }
+        }
+    }
 
     private MolapColumnarFactMergerInfo getMolapColumnarFactMergerInfo(
             List<MolapSliceAndFiles> slicesFromHDFS, String[] aggType,
             String[] aggClass, SliceMetaData readSliceMetaDataFile,
-            String destinationLocation, KeyGenerator globalKeyGen)
+            String destinationLocation)
     {
         MolapColumnarFactMergerInfo columnarFactMergerInfo = new MolapColumnarFactMergerInfo();
         columnarFactMergerInfo.setAggregatorClass(aggClass);
@@ -271,9 +310,6 @@ public class MolapColumnarSliceMerger implements MolapSliceMerger
         columnarFactMergerInfo.setTableName(tableName);
         columnarFactMergerInfo.setDimLens(readSliceMetaDataFile.getDimLens());
         columnarFactMergerInfo.setSlicesFromHDFS(slicesFromHDFS);
-        
-        columnarFactMergerInfo.setGlobalKeyGen(globalKeyGen);
-        
         char[] type = new char[readSliceMetaDataFile.getMeasures().length];
         Arrays.fill(type, 'n');
         if(null != aggType)
@@ -299,6 +335,7 @@ public class MolapColumnarSliceMerger implements MolapSliceMerger
      * Below method will be used for merging the slice All the concrete classes
      * will override this method and will implements its own type of merging
      * method
+     * 
      * @throws SliceMergerException
      *             will throw slice merger exception if any problem occurs
      *             during merging the slice
@@ -330,18 +367,10 @@ public class MolapColumnarSliceMerger implements MolapSliceMerger
                         factFiles[j], sliceMetaData.getMeasures().length,
                         sliceMetaData.getKeyGenerator().getKeySizeInBytes()));
             }
-
-            int [] cardinality = MolapMergerUtil.getCardinalityFromLevelMetadata(sliceAndFiles.getPath(),tableName);
-            KeyGenerator localKeyGen = KeyGeneratorFactory.getKeyGenerator(cardinality);
-            sliceAndFiles.setKeyGen(localKeyGen);
-            
-            
             leafNodeInfoList.add(sliceLeafNodeInfo);
             existingSliceCompressionModel
                     .add(getCompressionModel(sliceAndFiles.getPath(),
                             sliceMetaData.getMeasures().length));
-            
-            
         }
         for(int i = 0;i < sliceLocation.length;i++)
         {
@@ -368,40 +397,103 @@ public class MolapColumnarSliceMerger implements MolapSliceMerger
                     0, decimalLength, 0, sliceMetaData.getMeasures().length);
             for(int i = 1;i < existingSliceCompressionModel.size();i++)
             {
-                updateUniqueValue(existingSliceCompressionModel.get(i)
-                        .getUniqueValue(), uniqueValue);
-                calculateMax(
-                        existingSliceCompressionModel.get(i).getMaxValue(),
-                        maxValue);
-                calculateMin(
-                        existingSliceCompressionModel.get(i).getMinValue(),
-                        minValue);
+//                updateUniqueValue(existingSliceCompressionModel.get(i)
+//                        .getUniqueValue(), uniqueValue);
+//                calculateMax(
+//                        existingSliceCompressionModel.get(i).getMaxValue(),
+//                        maxValue);
+//                calculateMin(
+//                        existingSliceCompressionModel.get(i).getMinValue(),
+//                        minValue);
                 calculateDecimalLength(existingSliceCompressionModel.get(i)
                         .getDecimal(), decimalLength);
             }
             writeMeasureMetaFile(maxValue, minValue, uniqueValue,
                     decimalLength, existingSliceCompressionModel.get(0)
                             .getType(), destinationLocation);
-            
-            // write level metadata
-            
-            int [] maxCardinality = MolapMergerUtil.mergeLevelMetadata(sliceLocation,tableName,destinationLocation);
-            
-            KeyGenerator globalKeyGen=KeyGeneratorFactory.getKeyGenerator(maxCardinality);
-            
-            
-            
+            boolean isTimeBased = checkIfTimeBased(leafNodeInfoList);
             ColumnarFactFileMerger factMerger = null;
-            
-            // pass global key generator;
+            // isTimeBased = false;
+            if(isTimeBased)
+            {
+                factMerger = new TimeBasedMergerColumnar(
+                        getMolapColumnarFactMergerInfo(slicesFromHDFS, aggType,
+                                aggClass, sliceMetaData, destinationLocation), currentRestructNumber);
+            }
+            else
+            {
                 factMerger = new NonTimeBasedMergerColumnar(
                         getMolapColumnarFactMergerInfo(slicesFromHDFS, aggType,
-                                aggClass, sliceMetaData, destinationLocation,globalKeyGen), currentRestructNumber);
+                                aggClass, sliceMetaData, destinationLocation), currentRestructNumber);
+            }
             LOGGER.info(
                     MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG,
                     "Starting fact file merging: ");
             factMerger.mergerSlice();
+            LOGGER.info(
+                    MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG,
+                    "Merging dimension mapping file");
+            DimesionMappingFileMerger dimesionMerger = new DimesionMappingFileMerger(
+                    destinationLocation);
+            dimesionMerger.mergerDimesionFile(sliceLocation, false, null);
+
+            LOGGER.info(
+                    MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG,
+                    "Merger Hierarchy file");
+            HierarchyFileMerger hierMerger = new HierarchyFileMerger(
+                    destinationLocation,
+                    getHeirAndKeySizeMap(sliceMetaData.getHeirAnKeySize()));
+            hierMerger.mergerData(sliceLocation);
+        }
+    }
+
+    /**
+     * setHeirAndKeySizeMap
+     * 
+     * @param heirAndKeySize
+     *            void
+     */
+    private Map<String, Integer> getHeirAndKeySizeMap(String heirAndKeySize)
+    {
+        String[] split = heirAndKeySize
+                .split(MolapCommonConstants.AMPERSAND_SPC_CHARACTER);
+        String[] split2 = null;
+        Map<String, Integer> heirAndKeySizeMap = new HashMap<String, Integer>(
+                split.length);
+        for(int i = 0;i < split.length;i++)
+        {
+            split2 = split[i].split(MolapCommonConstants.COLON_SPC_CHARACTER);
+            heirAndKeySizeMap.put(split2[0], Integer.parseInt(split2[1]));
         }
+        return heirAndKeySizeMap;
+    }
+
+    /**
+     * This method checks whether its a time based merger or not If startkey of
+     * leaf is less than end key of next lef then its a time based merge
+     * 
+     * @param leafNodeInfoList
+     *            leafNodeInfoList
+     * @return is time based or not
+     * 
+     */
+    private boolean checkIfTimeBased(
+            List<List<LeafNodeInfoColumnar>> leafNodeInfoList)
+    {
+        byte[] startKey = null;
+        byte[] endKey = null;
+        for(int i = 1;i < leafNodeInfoList.size();i++)
+        {
+            List<LeafNodeInfoColumnar> list1 = leafNodeInfoList.get(i - 1);
+            endKey = list1.get(list1.size() - 1).getEndKey();
+            List<LeafNodeInfoColumnar> list2 = leafNodeInfoList.get(i);
+            startKey = list2.get(0).getStartKey();
+            if(ByteUtil.compare(endKey, startKey) > 0)
+            {
+                return false;
+            }
+        }
+        return true;
     }
 
     /**
@@ -419,22 +511,22 @@ public class MolapColumnarSliceMerger implements MolapSliceMerger
                 + this.tableName
                 + MolapCommonConstants.MEASUREMETADATA_FILE_EXT
                 + MolapCommonConstants.FILE_INPROGRESS_STATUS;
-        try
-        {
-            MolapDataProcessorUtil.writeMeasureMetaDataToFile(maxValue,
-                    minValue, decimalLength, uniqueValue, type,
-                    new byte[maxValue.length], msrMetaDataFile);
-            String changedFileName = msrMetaDataFile.substring(0,
-                    msrMetaDataFile.lastIndexOf('.'));
-            File currentFile = new File(msrMetaDataFile);
-            File destFile = new File(changedFileName);
-            currentFile.renameTo(destFile);
-        }
-        catch(MolapDataProcessorException e)
-        {
-            throw new SliceMergerException(
-                    "Problem While Writing the measure meta file" + e);
-        }
+//        try
+//        {
+//            MolapDataProcessorUtil.writeMeasureMetaDataToFile(maxValue,
+//                    minValue, decimalLength, uniqueValue, type,
+//                    new byte[maxValue.length], msrMetaDataFile);
+//            String changedFileName = msrMetaDataFile.substring(0,
+//                    msrMetaDataFile.lastIndexOf('.'));
+//            File currentFile = new File(msrMetaDataFile);
+//            File destFile = new File(changedFileName);
+//            currentFile.renameTo(destFile);
+//        }
+//        catch(MolapDataProcessorException e)
+//        {
+//            throw new SliceMergerException(
+//                    "Problem While Writing the measure meta file" + e);
+//        }
     }
 
     /**
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/MolapSliceMerger.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/MolapSliceMerger.java
index 6b440c0..55d1ae0 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/MolapSliceMerger.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/MolapSliceMerger.java
@@ -4,5 +4,5 @@ import com.huawei.unibi.molap.merger.exeception.SliceMergerException;
 
 public interface MolapSliceMerger
 {
-    boolean fullMerge(int currentRestructNumber) throws SliceMergerException;
+    void fullMerge(int currentRestructNumber) throws SliceMergerException;
 }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/MolapSliceMergerInfo.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/MolapSliceMergerInfo.java
index c8838a6..0c8001d 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/MolapSliceMergerInfo.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/MolapSliceMergerInfo.java
@@ -1,7 +1,5 @@
 package com.huawei.unibi.molap.merger;
 
-import java.util.List;
-
 import com.huawei.unibi.molap.olap.MolapDef.Schema;
 
 public class MolapSliceMergerInfo
@@ -17,12 +15,6 @@ public class MolapSliceMergerInfo
     private Schema schema;
     
     private String schemaPath;
-    
-    private String metadataPath;
-    
-    private List<String> loadsToBeMerged;
-    
-    private String mergedLoadName;
 
     /**
      * @return the schemaName
@@ -119,54 +111,6 @@ public class MolapSliceMergerInfo
     {
         this.schemaPath = schemaPath;
     }
-
-    /**
-     * @return the metadataPath
-     */
-    public String getMetadataPath()
-    {
-        return metadataPath;
-    }
-
-    /**
-     * @param metadataPath the metadataPath to set
-     */
-    public void setMetadataPath(String metadataPath)
-    {
-        this.metadataPath = metadataPath;
-    }
-
-    /**
-     * @return the loadsToBeMerged
-     */
-    public List<String> getLoadsToBeMerged()
-    {
-        return loadsToBeMerged;
-    }
-
-    /**
-     * @param loadsToMerge the loadsToBeMerged to set
-     */
-    public void setLoadsToBeMerged(List<String> loadsToMerge)
-    {
-        this.loadsToBeMerged = loadsToMerge;
-    }
-
-    /**
-     * @return the mergedLoadName
-     */
-    public String getMergedLoadName()
-    {
-        return mergedLoadName;
-    }
-
-    /**
-     * @param mergedLoadName the mergedLoadName to set
-     */
-    public void setMergedLoadName(String mergedLoadName)
-    {
-        this.mergedLoadName = mergedLoadName;
-    }
     
     
 }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/Util/SliceModel.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/Util/SliceModel.java
index 2fce8a7..fb88ced 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/Util/SliceModel.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/Util/SliceModel.java
@@ -83,7 +83,8 @@ public class SliceModel
     public SliceModel(SliceInfo sliceInfo)
     {
         this.compressionModel = sliceInfo.getCompressionModel();
-        this.uniqueValue=this.compressionModel.getUniqueValue();
+//  TODO here we hard code just for test query
+//        this.uniqueValue=this.compressionModel.getUniqueValue();
         initialize(sliceInfo);
     }
 
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/columnar/ColumnarFactFileMerger.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/columnar/ColumnarFactFileMerger.java
index ff8bd5b..9f14e03 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/columnar/ColumnarFactFileMerger.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/columnar/ColumnarFactFileMerger.java
@@ -9,7 +9,6 @@ import com.huawei.unibi.molap.factreader.FactReaderInfo;
 import com.huawei.unibi.molap.factreader.MolapSurrogateTupleHolder;
 import com.huawei.unibi.molap.merger.columnar.iterator.MolapDataIterator;
 import com.huawei.unibi.molap.merger.columnar.iterator.impl.MolapColumnarLeafTupleDataIterator;
-import com.huawei.unibi.molap.merger.columnar.iterator.impl.MolapLeafTupleWrapperIterator;
 import com.huawei.unibi.molap.merger.exeception.SliceMergerException;
 import com.huawei.unibi.molap.schema.metadata.MolapColumnarFactMergerInfo;
 import com.huawei.unibi.molap.store.MolapFactDataHandlerColumnarMerger;
@@ -80,13 +79,9 @@ public abstract class ColumnarFactFileMerger
         for(MolapSliceAndFiles sliceInfo : molapColumnarFactMergerInfo
                 .getSlicesFromHDFS())
         {
-            /*leaftTupleIterator = new MolapColumnarLeafTupleDataIterator(
+            leaftTupleIterator = new MolapColumnarLeafTupleDataIterator(
                     sliceInfo.getPath(), sliceInfo.getSliceFactFilesList(),
-                    getFactReaderInfo(molapColumnarFactMergerInfo), mdkeyLength);*/
-            
-            leaftTupleIterator = new MolapLeafTupleWrapperIterator(sliceInfo.getKeyGen(), molapColumnarFactMergerInfo.getGlobalKeyGen(), new MolapColumnarLeafTupleDataIterator(
-                    sliceInfo.getPath(), sliceInfo.getSliceFactFilesList(),
-                    getFactReaderInfo(molapColumnarFactMergerInfo), mdkeyLength));
+                    getFactReaderInfo(molapColumnarFactMergerInfo), mdkeyLength);
             if(leaftTupleIterator.hasNext())
             {
                 leaftTupleIterator.fetchNextData();
@@ -138,7 +133,6 @@ public abstract class ColumnarFactFileMerger
             blockIndex[i] = i;
         }
         factReaderInfo.setBlockIndex(blockIndex);
-        factReaderInfo.setUpdateMeasureRequired(true);
 
         return factReaderInfo;
     }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/columnar/iterator/impl/MolapColumnarLeafTupleDataIterator.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/columnar/iterator/impl/MolapColumnarLeafTupleDataIterator.java
index 1035f26..f6edb3e 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/columnar/iterator/impl/MolapColumnarLeafTupleDataIterator.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/columnar/iterator/impl/MolapColumnarLeafTupleDataIterator.java
@@ -9,6 +9,7 @@ import com.huawei.unibi.molap.factreader.MolapSurrogateTupleHolder;
 import com.huawei.unibi.molap.factreader.columnar.MolapColumnarLeafNodeIterator;
 import com.huawei.unibi.molap.iterator.MolapIterator;
 import com.huawei.unibi.molap.merger.columnar.iterator.MolapDataIterator;
+import com.huawei.unibi.molap.olap.SqlStatement;
 import com.huawei.unibi.molap.util.ValueCompressionUtil;
 
 
@@ -22,7 +23,7 @@ public class MolapColumnarLeafTupleDataIterator implements MolapDataIterator<Mol
     /**
      * unique value if slice
      */
-    private double[] uniqueValue;
+    private Object[] uniqueValue;
 
     /**
      * hash next
@@ -127,13 +128,13 @@ public class MolapColumnarLeafTupleDataIterator implements MolapDataIterator<Mol
     private Object[] getMeasure()
     {
         Object[] measures = new Object[measureCount];
-        double values=0;
+        Object values=0;
         for(int i = 0;i < measures.length;i++)
         {
             if(aggType[i]=='n')
             {
-                values = keyValue.getNormalMeasureValue(i);
-                if(this.isMeasureUpdateResuired && values != uniqueValue[i])
+                values = keyValue.getNormalMeasureValue(i, SqlStatement.Type.DOUBLE);
+                if(this.isMeasureUpdateResuired && !values.equals(uniqueValue[i]))
                 {
                     measures[i] = values;
                 }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/columnar/iterator/impl/MolapLeafTupleWrapperIterator.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/columnar/iterator/impl/MolapLeafTupleWrapperIterator.java
deleted file mode 100644
index 39fbe52..0000000
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/merger/columnar/iterator/impl/MolapLeafTupleWrapperIterator.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package com.huawei.unibi.molap.merger.columnar.iterator.impl;
-
-import com.huawei.iweb.platform.logging.LogService;
-import com.huawei.iweb.platform.logging.LogServiceFactory;
-import com.huawei.unibi.molap.factreader.MolapSurrogateTupleHolder;
-import com.huawei.unibi.molap.keygenerator.KeyGenException;
-import com.huawei.unibi.molap.keygenerator.KeyGenerator;
-import com.huawei.unibi.molap.merger.columnar.iterator.MolapDataIterator;
-import com.huawei.unibi.molap.util.MolapCoreLogEvent;
-
-/**
- * This class is a wrapper class over MolapColumnarLeafTupleDataIterator.
- * This uses the global key gen for generating key.
- * @author R00903928
- *
- */
-public class MolapLeafTupleWrapperIterator implements MolapDataIterator<MolapSurrogateTupleHolder>
-{
-    MolapDataIterator<MolapSurrogateTupleHolder> iterator;
-    
-    private KeyGenerator localKeyGen; 
-    
-    private KeyGenerator globalKeyGen;
-    
-    /**
-     * logger
-     */
-    private static final LogService LOGGER = LogServiceFactory
-            .getLogService(MolapLeafTupleWrapperIterator.class.getName());
-    
-    public MolapLeafTupleWrapperIterator(KeyGenerator localKeyGen, KeyGenerator globalKeyGen, MolapDataIterator<MolapSurrogateTupleHolder> iterator)
-    {
-        this.iterator = iterator;
-        this.localKeyGen = localKeyGen;
-        this.globalKeyGen = globalKeyGen;
-    }
-
-    @Override
-    public boolean hasNext()
-    {
-        return iterator.hasNext();
-    }
-
-    @Override
-    public void fetchNextData()
-    {
-        iterator.fetchNextData();
-    }
-
-    @Override
-    public MolapSurrogateTupleHolder getNextData()
-    {
-        MolapSurrogateTupleHolder nextData = iterator.getNextData();
-        byte[] mdKey = nextData.getMdKey();
-        long[] keyArray = localKeyGen.getKeyArray(mdKey);
-        byte[] generateKey = null;
-        try
-        {
-            generateKey = globalKeyGen.generateKey(keyArray);
-        }
-        catch(KeyGenException e)
-        {
-            LOGGER.error(
-                    MolapCoreLogEvent.UNIBI_MOLAPCORE_MSG ,
-                    "Error occurred :: " + e.getMessage());
-        }
-        nextData.setSurrogateKey(generateKey);
-        return nextData;
-    }
-}
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/schema/metadata/MolapColumnarFactMergerInfo.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/schema/metadata/MolapColumnarFactMergerInfo.java
index 82a12c9..9d00694 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/schema/metadata/MolapColumnarFactMergerInfo.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/schema/metadata/MolapColumnarFactMergerInfo.java
@@ -2,7 +2,6 @@ package com.huawei.unibi.molap.schema.metadata;
 
 import java.util.List;
 
-import com.huawei.unibi.molap.keygenerator.KeyGenerator;
 import com.huawei.unibi.molap.util.MolapSliceAndFiles;
 
 
@@ -36,8 +35,6 @@ public class MolapColumnarFactMergerInfo
     private boolean isMergingRequestForCustomAgg;
 
 	private boolean isUpdateFact;
-	
-	private KeyGenerator globalKeyGen;
     
     /**
      * @return the tableName
@@ -256,20 +253,4 @@ public class MolapColumnarFactMergerInfo
 		return isUpdateFact;
 		
 	}
-
-    /**
-     * @return the globalKeyGen
-     */
-    public KeyGenerator getGlobalKeyGen()
-    {
-        return globalKeyGen;
-    }
-
-    /**
-     * @param globalKeyGen the globalKeyGen to set
-     */
-    public void setGlobalKeyGen(KeyGenerator globalKeyGen)
-    {
-        this.globalKeyGen = globalKeyGen;
-    }
 }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/schema/metadata/MolapInfo.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/schema/metadata/MolapInfo.java
index b59867e..0066eef 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/schema/metadata/MolapInfo.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/schema/metadata/MolapInfo.java
@@ -22,7 +22,6 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
-import com.huawei.datasight.molap.datatypes.GenericDataType;
 import com.huawei.unibi.molap.keygenerator.KeyGenerator;
 
 
@@ -156,18 +155,7 @@ public class MolapInfo
     private boolean[] dimsPresent;
     
     private String schemaName;
-    
-    private Map<String,GenericDataType> complexTypesMap;
-    
-	public Map<String, GenericDataType> getComplexTypesMap() {
-		return complexTypesMap;
-	}
-
-	public void setComplexTypesMap(Map<String, GenericDataType> complexTypesMap) {
-		this.complexTypesMap = complexTypesMap;
-	}
-
-	/**
+    /**
      * 
      * @return Returns the dims.
      * 
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/AbstractTempSortFileReader.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/AbstractTempSortFileReader.java
index fd27f52..e53436c 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/AbstractTempSortFileReader.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/AbstractTempSortFileReader.java
@@ -26,11 +26,6 @@ public abstract class AbstractTempSortFileReader implements TempSortFileReader
      * Measure count 
      */
     protected int dimensionCount;
-    
-    /**
-     * complexDimension count 
-     */
-    protected int complexDimensionCount;
 
     /**
      * entryCount
@@ -51,8 +46,6 @@ public abstract class AbstractTempSortFileReader implements TempSortFileReader
      * eachRecordSize
      */
     protected int eachRecordSize;
-    
-    protected int highCardinalityCount;
 
     /**
      * AbstractTempSortFileReader
@@ -61,16 +54,14 @@ public abstract class AbstractTempSortFileReader implements TempSortFileReader
      * @param dimensionCount
      * @param tempFile
      */
-    public AbstractTempSortFileReader(int dimensionCount, int complexDimensionCount, int measureCount, File tempFile,int highCardinalityCount)
+    public AbstractTempSortFileReader(int dimensionCount, int measureCount, File tempFile)
     {
         this.measureCount = measureCount;
         this.dimensionCount = dimensionCount;
-        this.highCardinalityCount = highCardinalityCount;
-		this.complexDimensionCount = complexDimensionCount;
         this.fileHolder = new FileHolderImpl(1);
         this.filePath = tempFile.getAbsolutePath();
         entryCount = fileHolder.readInt(filePath);
-        eachRecordSize = dimensionCount + complexDimensionCount + measureCount;
+        eachRecordSize = dimensionCount + measureCount;
     }
     
     /**
@@ -117,13 +108,6 @@ public abstract class AbstractTempSortFileReader implements TempSortFileReader
 	        {
 	        	record[index++] = buffer.getInt();
 	        }
-
-	        for(int j = 0; j < complexDimensionCount; j++)
-	        {
-	        	byte[] complexByteArray = new byte[buffer.getInt()];
-	        	buffer.get(complexByteArray);
-	        	record[index++] = complexByteArray;
-	        }
 	        
 	        for(int j = 0; j < measureCount; j++)
 	        {
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/AbstractTempSortFileWriter.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/AbstractTempSortFileWriter.java
index 6d214cb..8ff808c 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/AbstractTempSortFileWriter.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/AbstractTempSortFileWriter.java
@@ -36,21 +36,11 @@ public abstract class AbstractTempSortFileWriter implements TempSortFileWriter
      * Measure count 
      */
     protected int dimensionCount;
-    
-    /**
-     * complexDimension count 
-     */
-    protected int complexDimensionCount;
 
     /**
      * stream
      */
     protected DataOutputStream stream;
-
-    /**
-     * highCardinalityCount
-     */
-    protected int highCardinalityCount;
     
     /**
      * AbstractTempSortFileWriter 
@@ -58,14 +48,12 @@ public abstract class AbstractTempSortFileWriter implements TempSortFileWriter
      * @param dimensionCount
      * @param measureCount
      */
-    public AbstractTempSortFileWriter(int dimensionCount, int complexDimensionCount,
-    		int measureCount,int highCardinalityCount, int writeBufferSize)
+    public AbstractTempSortFileWriter(int dimensionCount, 
+    		int measureCount, int writeBufferSize)
     {
         this.writeBufferSize = writeBufferSize;
         this.dimensionCount = dimensionCount;
-        this.complexDimensionCount = complexDimensionCount;
         this.measureCount = measureCount;
-        this.highCardinalityCount = highCardinalityCount;
     }
     
     /**
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/CompressedTempSortFileReader.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/CompressedTempSortFileReader.java
index c650332..2d4da1d 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/CompressedTempSortFileReader.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/CompressedTempSortFileReader.java
@@ -24,10 +24,10 @@ public class CompressedTempSortFileReader extends AbstractTempSortFileReader
      * @param tempFile
      * @param type
      */
-    public CompressedTempSortFileReader(int dimensionCount, int complexDimensionCount, int measureCount,
-    		File tempFile,int highCardinalityCount)
+    public CompressedTempSortFileReader(int dimensionCount, int measureCount,
+    		File tempFile)
     {
-        super(dimensionCount, complexDimensionCount, measureCount, tempFile, highCardinalityCount);
+        super(dimensionCount, measureCount, tempFile);
     }
 
     /**
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/CompressedTempSortFileWriter.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/CompressedTempSortFileWriter.java
index 0fa2794..fc5d5ec 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/CompressedTempSortFileWriter.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/CompressedTempSortFileWriter.java
@@ -27,10 +27,10 @@ public class CompressedTempSortFileWriter extends AbstractTempSortFileWriter
      * @param dimensionCount
      * @param measureCount
      */
-    public CompressedTempSortFileWriter(int dimensionCount, int complexDimensionCount,
-    		int measureCount,int highCardinalityCount, int writeBufferSize)
+    public CompressedTempSortFileWriter(int dimensionCount, 
+    		int measureCount, int writeBufferSize)
     {
-        super(dimensionCount, complexDimensionCount, measureCount,highCardinalityCount, writeBufferSize);
+        super(dimensionCount, measureCount, writeBufferSize);
     }
 
     /**
@@ -53,7 +53,7 @@ public class CompressedTempSortFileWriter extends AbstractTempSortFileWriter
             blockDataArray = new ByteArrayOutputStream(totalSize);
             dataOutputStream = new DataOutputStream(blockDataArray);
             
-            UnCompressedTempSortFileWriter.writeDataOutputStream(records, dataOutputStream, measureCount, dimensionCount, highCardinalityCount, complexDimensionCount);
+            UnCompressedTempSortFileWriter.writeDataOutputStream(records, dataOutputStream, measureCount, dimensionCount);
             
             /*for(int recordIndex = 0; recordIndex < records.length; recordIndex++)
             {
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/FileMergerParameters.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/FileMergerParameters.java
index 78a9f88..ecfb457 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/FileMergerParameters.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/FileMergerParameters.java
@@ -28,16 +28,6 @@ public class FileMergerParameters
      * measure count
      */
     private int dimColCount;
-  
-    /**
-     * complexDimColCount
-     */
-    private int complexDimColCount;
-    
-    /**
-     * measure count
-     */
-    private int highCardinalityCount;
     
     /**
      * outFile
@@ -58,6 +48,8 @@ public class FileMergerParameters
      * prefetch
      */
     private boolean prefetch;
+    
+    private char[] aggType;
 
     /**
      * prefetchBufferSize
@@ -115,16 +107,6 @@ public class FileMergerParameters
 		this.dimColCount = dimColCount;
 	}
 
-	public int getComplexDimColCount()
-	{
-		return complexDimColCount;
-	}
-
-	public void setComplexDimColCount(int complexDimColCount)
-	{
-		this.complexDimColCount = complexDimColCount;
-	}
-
 	public File getOutFile()
 	{
 		return outFile;
@@ -175,17 +157,13 @@ public class FileMergerParameters
 		this.prefetchBufferSize = prefetchBufferSize;
 	}
 
-	/**
-	 * @return the highCardinalityCount
-	 */
-	public int getHighCardinalityCount() {
-		return highCardinalityCount;
-	}
+    public char[] getAggType()
+    {
+        return aggType;
+    }
 
-	/**
-	 * @param highCardinalityCount the highCardinalityCount to set
-	 */
-	public void setHighCardinalityCount(int highCardinalityCount) {
-		this.highCardinalityCount = highCardinalityCount;
-	}
+    public void setAggType(char[] aggType)
+    {
+        this.aggType = aggType;
+    }
 }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/IntermediateFileMerger.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/IntermediateFileMerger.java
index 7f2258c..98f439e 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/IntermediateFileMerger.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/IntermediateFileMerger.java
@@ -24,6 +24,7 @@ import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.math.BigDecimal;
 import java.util.AbstractQueue;
 import java.util.Comparator;
 import java.util.PriorityQueue;
@@ -31,11 +32,12 @@ import java.util.concurrent.Callable;
 
 import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
+import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.sortandgroupby.exception.MolapSortKeyAndGroupByException;
+import com.huawei.unibi.molap.util.DataTypeUtil;
 import com.huawei.unibi.molap.util.MolapDataProcessorLogEvent;
 import com.huawei.unibi.molap.util.MolapUtil;
 import com.huawei.unibi.molap.util.MolapUtilException;
-import com.huawei.unibi.molap.util.RemoveDictionaryUtil;
 
 /**
  * Project Name 	: Carbon 
@@ -215,7 +217,7 @@ public class IntermediateFileMerger implements Callable<Void>
         else
         {
         	 writer = TempSortFileWriterFactory.getInstance().getTempSortFileWriter(mergerParameters.isCompressionEnabled(), 
-        			 mergerParameters.getDimColCount(), mergerParameters.getComplexDimColCount(), mergerParameters.getMeasureColCount(), mergerParameters.getHighCardinalityCount(),mergerParameters.getFileWriteBufferSize());
+        			 mergerParameters.getDimColCount(), mergerParameters.getMeasureColCount(), mergerParameters.getFileWriteBufferSize());
         	 writer.initiaize(mergerParameters.getOutFile(), totalNumberOfRecords);
         	 
         	 if(mergerParameters.isPrefetch())
@@ -301,10 +303,8 @@ public class IntermediateFileMerger implements Callable<Void>
         {
             // create chunk holder
         	sortTempFileChunkHolder = new SortTempFileChunkHolder(
-                    tempFile, mergerParameters.getDimColCount(), 
-                    mergerParameters.getComplexDimColCount(),
-                    mergerParameters.getMeasureColCount(), 
-                    mergerParameters.getFileReadBufferSize(),mergerParameters.getHighCardinalityCount());
+                    tempFile, mergerParameters.getDimColCount(), mergerParameters.getMeasureColCount(), 
+                    mergerParameters.getFileReadBufferSize(), mergerParameters.getAggType());
             
         	// initialize
         	sortTempFileChunkHolder.initialize();
@@ -344,8 +344,8 @@ public class IntermediateFileMerger implements Callable<Void>
 
                         for(int i = 0; i < mergerParameters.getDimColCount(); i++)
                         {
-                            int dimFieldA = (Integer)RemoveDictionaryUtil.getDimension(i, rowA);
-                            int dimFieldB = (Integer)RemoveDictionaryUtil.getDimension(i, rowB);
+                            int dimFieldA = (Integer)rowA[i];
+                            int dimFieldB = (Integer)rowB[i];
                             
                             diff = dimFieldA - dimFieldB;
                             if(diff != 0)
@@ -413,35 +413,44 @@ public class IntermediateFileMerger implements Callable<Void>
         try
         {
             int fieldIndex = 0;
-
-            for(int counter = 0;counter < mergerParameters.getDimColCount();counter++)
-            {
-                stream.writeInt((Integer)RemoveDictionaryUtil.getDimension(
-                        fieldIndex++, row));
-            }
-
-            // added for high card also
-            if(mergerParameters.getHighCardinalityCount() > 0)
+            char[] aggType = mergerParameters.getAggType();
+            
+            for(int counter = 0; counter < mergerParameters.getDimColCount(); counter++)
             {
-                stream.write(RemoveDictionaryUtil
-                        .getByteArrayForNoDictionaryCols(row));
+            	stream.writeInt((Integer)row[fieldIndex++]);
             }
-
-            fieldIndex = 0;
-            for(int counter = 0;counter < mergerParameters.getMeasureColCount();counter++)
+            
+            for(int counter = 0; counter < mergerParameters.getMeasureColCount(); counter++)
             {
-                if(null != RemoveDictionaryUtil.getMeasure(fieldIndex, row))
+            	if(null != row[fieldIndex])
                 {
-                    stream.write((byte)1);
-                    stream.writeDouble(RemoveDictionaryUtil.getMeasure(
-                            fieldIndex, row));
+            		// TODO:- changes to made here for writing data according to datatype
+            		stream.write((byte)1);
+            		stream.writeDouble((Double)row[fieldIndex]);
+            		if(aggType[counter] == MolapCommonConstants.BYTE_VALUE_MEASURE)
+                    {
+                        Double val = (Double)row[fieldIndex];
+                        stream.writeDouble(val);
+                    }
+                    else if(aggType[counter] == MolapCommonConstants.BIG_INT_MEASURE)
+                    {
+                        Long val = (Long)row[fieldIndex];
+                        stream.writeLong(val);
+                    }
+                    else if(aggType[counter] == MolapCommonConstants.BIG_DECIMAL_MEASURE)
+                    {
+                        BigDecimal val = (BigDecimal)row[fieldIndex];
+                        byte[] bigDecimalInBytes = DataTypeUtil.bigDecimalToByte(val);
+                        stream.writeInt(bigDecimalInBytes.length);
+                        stream.write(bigDecimalInBytes);
+                    }
                 }
                 else
                 {
-                    stream.write((byte)0);
+                	stream.write((byte)0);
                 }
-
-                fieldIndex++;
+            	
+            	fieldIndex++;
             }
 
         }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/RowComparator.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/RowComparator.java
index 9d6425a..748ae35 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/RowComparator.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/RowComparator.java
@@ -20,8 +20,6 @@ package com.huawei.unibi.molap.sortandgroupby.sortData;
 
 import java.util.Comparator;
 
-import com.huawei.unibi.molap.util.RemoveDictionaryUtil;
-
 /**
  * Project Name 	: Carbon 
  * Module Name 		: MOLAP Data Processor
@@ -61,9 +59,8 @@ public class RowComparator implements Comparator<Object[]>
 
         for(int i = 0; i < dimensionCount; i++)
         {
-            
-            int dimFieldA = RemoveDictionaryUtil.getDimension(i, rowA);
-            int dimFieldB = RemoveDictionaryUtil.getDimension(i, rowB);
+            int dimFieldA = (Integer)rowA[i];
+            int dimFieldB = (Integer)rowB[i];
             
             diff = dimFieldA - dimFieldB;
             if(diff != 0)
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/SortDataRows.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/SortDataRows.java
index 79fc7f2..0d7a11a 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/SortDataRows.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/SortDataRows.java
@@ -5,7 +5,7 @@ import java.io.DataOutputStream;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
-import java.nio.ByteBuffer;
+import java.math.BigDecimal;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -20,11 +20,11 @@ import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.exception.MolapDataProcessorException;
 import com.huawei.unibi.molap.schema.metadata.SortObserver;
 import com.huawei.unibi.molap.sortandgroupby.exception.MolapSortKeyAndGroupByException;
+import com.huawei.unibi.molap.util.DataTypeUtil;
 import com.huawei.unibi.molap.util.MolapDataProcessorLogEvent;
 import com.huawei.unibi.molap.util.MolapDataProcessorUtil;
 import com.huawei.unibi.molap.util.MolapProperties;
 import com.huawei.unibi.molap.util.MolapUtil;
-import com.huawei.unibi.molap.util.RemoveDictionaryUtil;
 
 /**
  * Project Name 	: Carbon 
@@ -79,11 +79,6 @@ public class SortDataRows
     private int dimColCount;
 
     /**
-     * measure count
-     */
-    private int complexDimColCount;
-
-    /**
      * fileBufferSize
      */
     private int fileBufferSize;
@@ -155,12 +150,12 @@ public class SortDataRows
     /**
      * max value for each measure
      */
-    private double[] maxValue;
+    private Object[] maxValue;
     
     /**
      * min value for each measure
      */
-    private double[] minValue;
+    private Object[] minValue;
     
     /**
      * decimal length of each measure
@@ -170,7 +165,7 @@ public class SortDataRows
     /**
      * uniqueValue
      */
-    private double[] uniqueValue;
+    private Object[] uniqueValue;
     
     /**
      * maxMinLock
@@ -179,21 +174,20 @@ public class SortDataRows
     
     private int currentRestructNumber;
     
+    private String[] measureDatatype;
+    
+    private char[] aggType;
+    
     /**
      * decimalPointers
      */
 	private final byte decimalPointers = Byte.parseByte(MolapProperties
 			.getInstance().getProperty(MolapCommonConstants.MOLAP_DECIMAL_POINTERS,
 					MolapCommonConstants.MOLAP_DECIMAL_POINTERS_DEFAULT));
-
-	/**
-	 * To know how many columns are of high cardinality.
-	 */
-	private int highCardinalityCount;
     
     
-	public SortDataRows(String tabelName, int dimColCount, int complexDimColCount, int measureColCount,
-			SortObserver observer, int currentRestructNum,int highCardinalityCount)
+	public SortDataRows(String tabelName, int dimColCount, int measureColCount,
+			SortObserver observer, int currentRestructNum, String[] measureDatatype)
 	{
 		// set table name
         this.tableName = tabelName;
@@ -203,9 +197,6 @@ public class SortDataRows
         
         this.dimColCount = dimColCount;
         
-        this.highCardinalityCount = highCardinalityCount;
-		this.complexDimColCount = complexDimColCount;
-        
         // processed file list
         this.procFiles = new ArrayList<File>(MolapCommonConstants.CONSTANT_SIZE_TEN);
         
@@ -216,6 +207,9 @@ public class SortDataRows
         this.threadStatusObserver = new ThreadStatusObserver();
         
         this.currentRestructNumber = currentRestructNum;
+        
+        this.measureDatatype = measureDatatype;
+        this.aggType = new char[measureColCount];
 	}
 	
 	/**
@@ -301,22 +295,58 @@ public class SortDataRows
                     "Compression will be used for writing the sort temp File");
         }
         
-        prefetch =MolapCommonConstants.MOLAP_PREFETCH_IN_MERGE_VALUE;
-        bufferSize=MolapCommonConstants.MOLAP_PREFETCH_BUFFERSIZE;
-              
-        maxValue = new double[measureColCount];
-        minValue = new double[measureColCount];
+        prefetch = Boolean.parseBoolean(molapProperties
+                .getProperty("molap.prefetch.in.merge", "false"));
+        try
+        {
+            bufferSize = Integer.parseInt(molapProperties
+                    .getProperty("molap.prefetch.bufferSize", "1000"));
+        }
+        catch(NumberFormatException e)
+        {
+            LOGGER.error(
+                    MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG,
+                    "Invalid value for: "
+                            + "molap.prefetch.bufferSize"
+                            + ": Only Positive Integer value (greater than zero) is allowed. Default value will be used");
+            bufferSize = 1000;
+        }
+        initAggType();
+        maxValue = new Object[measureColCount];
+        minValue = new Object[measureColCount];
         decimalLength = new int[measureColCount];
-        uniqueValue = new double[measureColCount];
+        uniqueValue = new Object[measureColCount];
         
         for(int i = 0; i < maxValue.length; i++)
         {
-            maxValue[i] = -Double.MAX_VALUE;
+            if(aggType[i] == MolapCommonConstants.BIG_INT_MEASURE)
+            {
+                maxValue[i] = Long.MIN_VALUE;
+            }
+            else if(aggType[i] == MolapCommonConstants.SUM_COUNT_VALUE_MEASURE)
+            {
+            	maxValue[i] = -Double.MAX_VALUE;
+            }
+            else
+            {
+            	maxValue[i] = 0.0;
+            }
         }
         
         for(int i = 0; i < minValue.length; i++)
         {
-            minValue[i] = Double.MAX_VALUE;
+            if(aggType[i] == MolapCommonConstants.BIG_INT_MEASURE)
+            {
+            	minValue[i] = Long.MAX_VALUE;
+            }
+            else if(aggType[i] == MolapCommonConstants.SUM_COUNT_VALUE_MEASURE)
+            {
+            	minValue[i] = Double.MAX_VALUE;
+            }
+            else
+            {
+            	minValue[i] = 0.0;
+            }
         }
         
         for(int i = 0; i < decimalLength.length; i++)
@@ -324,7 +354,16 @@ public class SortDataRows
             decimalLength[i] = 0;
         }
     }
-	
+    
+    private void initAggType()
+    {
+        Arrays.fill(aggType, 'n');
+        for(int i = 0;i < measureColCount;i++)
+        {
+            aggType[i] = DataTypeUtil.getAggType(measureDatatype[i]);
+        }
+    }
+
 	/**
      * This method will be used to add new row
      * 
@@ -512,21 +551,43 @@ public class SortDataRows
             // write number of entries to the file
             stream.writeInt(entryCountLocal);
             Object[] row = null;
-            double[] measures = null;
+            Object[] measures = null;
             
             // Row level min max
-            double[] max = new double[measureColCount];
-            double[] min = new double[measureColCount];
+            Object[] max = new Object[measureColCount];
+            Object[] min = new Object[measureColCount];
             int[] decimal = new int[measureColCount];
             
             for(int i = 0; i < max.length; i++)
             {
-            	max[i] = -Double.MAX_VALUE;
+                if(aggType[i] == MolapCommonConstants.BIG_INT_MEASURE)
+                {
+                    max[i] = Long.MIN_VALUE;
+                }
+                else if(aggType[i] == MolapCommonConstants.SUM_COUNT_VALUE_MEASURE)
+                {
+                    max[i] = -Double.MAX_VALUE;
+                }
+                else
+                {
+                	max[i] = 0.0;
+                }
             }
             
             for(int i = 0; i < min.length; i++)
             {
-            	min[i] = Double.MAX_VALUE;
+                if(aggType[i] == MolapCommonConstants.BIG_INT_MEASURE)
+                {
+                    min[i] = Long.MAX_VALUE;
+                }
+                else if(aggType[i] == MolapCommonConstants.SUM_COUNT_VALUE_MEASURE)
+                {
+                    min[i] = Double.MAX_VALUE;
+                }
+                else
+                {
+                	min[i] = 0.0;
+                }
             }
             
             for(int i = 0; i < decimal.length; i++)
@@ -538,56 +599,52 @@ public class SortDataRows
             {
                 // get row from record holder list
                 row = recordHolderList[i];
-                measures = new double[measureColCount];
+                measures = new Object[measureColCount];
                 
                 int fieldIndex = 0;
-               
-                for(int dimCount = 0; dimCount < this.dimColCount; dimCount++)
-                {
-                    stream.writeInt(RemoveDictionaryUtil.getDimension(fieldIndex++, row));
-//                	stream.writeInt((Integer)row[fieldIndex++]);
-                }
-
-                for(int dimCount = 0; dimCount < this.complexDimColCount; dimCount++)
-                {
-                	int complexByteArrayLength = ((byte[])row[fieldIndex]).length;
-                	stream.writeInt(complexByteArrayLength);
-                	stream.write(((byte[])row[fieldIndex++]));
-                }
                 
-                // if any high cardinality dims are present then write it to the file.
-                if(this.highCardinalityCount > 0)
+                for(int dimCount = 0; dimCount < this.dimColCount; dimCount++)
                 {
-                    stream.write(RemoveDictionaryUtil.getByteArrayForNoDictionaryCols(row));
+                	stream.writeInt((Integer)row[fieldIndex++]);
                 }
                 
-                /*for(int highCardinality = 0; highCardinality < this.highCardinalityCount; highCardinality++)
-                {
-                	 ByteBuffer buffer = (ByteBuffer) row[fieldIndex++];
-                	 int length = (int)buffer.getShort();
-                	stream.writeShort(length);
-                	byte[] arr = new byte[length];
-                	buffer.get(arr);
-                	stream.write(arr);
-                	buffer.rewind();
-                }*/
-                
-                // as measures are stored in separate array.
-                fieldIndex = 0;
                 for(int mesCount = 0; mesCount < this.measureColCount; mesCount++)
                 {
-                	if(null != RemoveDictionaryUtil.getMeasure(fieldIndex, row))
+                	if(null != row[fieldIndex])
                     {
+                		// TODO:- changes to made here for reading data according to datatype
                 		stream.write((byte)1);
-                		
-                		Double val = (Double)RemoveDictionaryUtil.getMeasure(fieldIndex, row);
-                		stream.writeDouble(val);
-                		measures[mesCount] = val;
+                		if(aggType[mesCount] == MolapCommonConstants.SUM_COUNT_VALUE_MEASURE)
+                		{
+                		    Double val = (Double)row[fieldIndex];
+                            stream.writeDouble(val);
+                            measures[mesCount] = val;
+                		}
+                		else if(aggType[mesCount] == MolapCommonConstants.BIG_INT_MEASURE)
+                        {
+                		    Long val = (Long)row[fieldIndex];
+                            stream.writeLong(val);
+                            measures[mesCount] = val; 
+                        }
+                		else if(aggType[mesCount] == MolapCommonConstants.BIG_DECIMAL_MEASURE)
+                		{
+                		    BigDecimal val = (BigDecimal)row[fieldIndex];
+                		    byte[] bigDecimalInBytes = DataTypeUtil.bigDecimalToByte(val);
+                		    stream.writeInt(bigDecimalInBytes.length);
+                		    stream.write(bigDecimalInBytes);
+                		}
                     }
                     else
                     {
                     	stream.write((byte)0);
-                    	measures[mesCount] = 0;
+                    	if(aggType[mesCount] == MolapCommonConstants.BIG_INT_MEASURE)
+                    	{
+                    	    measures[mesCount] = 0L;
+                    	}
+                    	else
+                    	{
+                    	    measures[mesCount] = 0.0;
+                    	}
                     }
                 	fieldIndex++;
                 }
@@ -595,11 +652,29 @@ public class SortDataRows
                 // Update row level min max
 				for (int count = 0; count < measures.length; count++)
 				{
-					double value = measures[count];
-					max[count] = (max[count] > value ? max[count] : value);
-					min[count] = (min[count] < value ? min[count] : value);
-					int num = (value % 1 == 0) ? 0 : decimalPointers;
-		   			decimal[count] = (decimal[count] > num ? decimal[count] : num);
+					// TODO: - check for measure agg type, if 'n' or 'l' then only proceed
+                    if(aggType[count] == MolapCommonConstants.SUM_COUNT_VALUE_MEASURE)
+                    {
+                        double value = (double)measures[count];
+                        double maxVal = (double)max[count];
+                        double minVal = (double)min[count];
+                        max[count] = (maxVal > value ? max[count] : value);
+                        min[count] = (minVal < value ? min[count] : value);
+                        int num = (value % 1 == 0) ? 0 : decimalPointers;
+                        decimal[count] = (decimal[count] > num ? decimal[count]
+                                : num);
+                    }
+                    else if(aggType[count] == MolapCommonConstants.BIG_INT_MEASURE)
+                    {
+                        long value = (long)measures[count];
+                        long maxVal = (long)max[count];
+                        long minVal = (long)min[count];
+                        max[count] = (maxVal > value ? max[count] : value);
+                        min[count] = (minVal < value ? min[count] : value);
+                        int num = (value % 1 == 0) ? 0 : decimalPointers;
+                        decimal[count] = (decimal[count] > num ? decimal[count]
+                                : num);
+                    }
 				}
             }
             
@@ -622,7 +697,7 @@ public class SortDataRows
     {
     	TempSortFileWriter chunkWriter = null;
     	TempSortFileWriter writer = TempSortFileWriterFactory.getInstance().getTempSortFileWriter(
-        		isSortFileCompressionEnabled, dimColCount, complexDimColCount, measureColCount,highCardinalityCount, fileWriteBufferSize);
+        		isSortFileCompressionEnabled, dimColCount, measureColCount, fileWriteBufferSize);
         
         if(prefetch && !isSortFileCompressionEnabled)
         {
@@ -648,7 +723,6 @@ public class SortDataRows
         FileMergerParameters parameters = new FileMergerParameters();
         
         parameters.setDimColCount(dimColCount);
-        parameters.setComplexDimColCount(complexDimColCount);
         parameters.setMeasureColCount(measureColCount);
         parameters.setIntermediateFiles(intermediateFiles);
         parameters.setFileReadBufferSize(fileBufferSize);
@@ -658,8 +732,8 @@ public class SortDataRows
         parameters.setNoOfRecordsInCompression(sortTempFileNoOFRecordsInCompression);
         parameters.setPrefetch(prefetch);
         parameters.setPrefetchBufferSize(bufferSize);
-        parameters.setHighCardinalityCount(highCardinalityCount);
-        
+        parameters.setAggType(aggType);
+        // TODO: -set agg type in the parameter list and proceed
         IntermediateFileMerger merger = new IntermediateFileMerger(parameters);
         executorService.submit(merger);
     }
@@ -773,16 +847,38 @@ public class SortDataRows
      * @param currentMeasures
      *
      */
-   private void calculateMaxMinUnique(double[] max, double[] min, int[] decimal, int length)
+   private void calculateMaxMinUnique(Object[] max, Object[] min, int[] decimal, int length)
    {
 	   synchronized(maxMinLock) 
 	   {
 		   for (int i = 0; i < length; i++) 
 		   {
-			   maxValue[i] = (maxValue[i] > max[i] ? maxValue[i] : max[i]);
-			   minValue[i] = (minValue[i] < min[i] ? minValue[i] : min[i]);
-			   uniqueValue[i] = minValue[i] - 1;
-   			   decimalLength[i] = (decimalLength[i] > decimal[i] ? decimalLength[i] : decimal[i]);
+		       if(aggType[i] == MolapCommonConstants.SUM_COUNT_VALUE_MEASURE)
+               {
+                   double prevMaxVal = (double)maxValue[i];
+                   double prevMinVal = (double)minValue[i];
+                   double curMaxVal = (double)max[i];
+                   double curMinVal = (double)min[i];
+                   maxValue[i] = (prevMaxVal > curMaxVal ? maxValue[i] : max[i]);
+                   minValue[i] = (prevMinVal < curMinVal ? minValue[i] : min[i]);
+                   uniqueValue[i] = (double)minValue[i] - 1;
+                   decimalLength[i] = (decimalLength[i] > decimal[i] ? decimalLength[i] : decimal[i]);
+               }
+               else if(aggType[i] == MolapCommonConstants.BIG_INT_MEASURE)
+               {
+                   long prevMaxVal = (long)maxValue[i];
+                   long prevMinVal = (long)maxValue[i];
+                   long curMaxVal = (long)max[i];
+                   long curMinVal = (long)min[i];
+                   maxValue[i] = (prevMaxVal > curMaxVal ? maxValue[i] : max[i]);
+                   minValue[i] = (prevMinVal < curMinVal ? minValue[i] : min[i]);
+                   uniqueValue[i] = (long)minValue[i] - 1;
+                   decimalLength[i] = (decimalLength[i] > decimal[i] ? decimalLength[i] : decimal[i]);
+               }
+               else
+               {
+            	   uniqueValue[i] = 0.0;
+               }
 		   }
 	   }
    }
@@ -828,9 +924,6 @@ public class SortDataRows
 
        try
        {
-    	   char[] aggType = new char[measureColCount];
-    	   Arrays.fill(aggType, 'n');
-    	   
            MolapDataProcessorUtil.writeMeasureMetaDataToFile(this.maxValue,
                    this.minValue, this.decimalLength, this.uniqueValue, aggType, new byte[this.maxValue.length],
                    measuremetaDataFilepath);
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/SortTempFileChunkHolder.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/SortTempFileChunkHolder.java
index 78553ab..f481ec4 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/SortTempFileChunkHolder.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/SortTempFileChunkHolder.java
@@ -24,8 +24,6 @@ import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -38,7 +36,6 @@ import com.huawei.unibi.molap.sortandgroupby.exception.MolapSortKeyAndGroupByExc
 import com.huawei.unibi.molap.util.MolapDataProcessorLogEvent;
 import com.huawei.unibi.molap.util.MolapProperties;
 import com.huawei.unibi.molap.util.MolapUtil;
-import com.huawei.unibi.molap.util.RemoveDictionaryUtil;
 
 /**
  * Project Name 	: Carbon 
@@ -88,16 +85,11 @@ public class SortTempFileChunkHolder
     private int measureCount;
     
     /**
-     * number of dimensionCount
+     * number of measures
      */
     private int dimensionCount;
 
     /**
-     * number of complexDimensionCount
-     */
-    private int complexDimensionCount;
-
-    /**
      * fileBufferSize for file reader stream size
      */
     private int fileBufferSize;
@@ -144,8 +136,8 @@ public class SortTempFileChunkHolder
      * totalRecordFetch
      */
     private int totalRecordFetch;
-
-	private int highCardinalityCount;
+    
+    private char[] aggType;
     
     /**
      * MolapSortTempFileChunkHolder Constructor
@@ -158,8 +150,8 @@ public class SortTempFileChunkHolder
      *            mdkey length
      * 
      */
-    public SortTempFileChunkHolder(File tempFile, int dimensionCount, int complexDimensionCount,  int measureCount, 
-            int fileBufferSize, int highCardinalityCount)
+    public SortTempFileChunkHolder(File tempFile, int dimensionCount, int measureCount, 
+            int fileBufferSize, char[] aggType)
     {
         // set temp file
         this.tempFile = tempFile;
@@ -167,13 +159,12 @@ public class SortTempFileChunkHolder
         // set measure and dimension count
         this.measureCount = measureCount;
         this.dimensionCount = dimensionCount;
-        this.complexDimensionCount = complexDimensionCount;
         
-        this.highCardinalityCount = highCardinalityCount;
         // set mdkey length
         this.fileBufferSize = fileBufferSize;
         this.executorService = Executors.newFixedThreadPool(1);
-        this.outRecSize = this.measureCount + dimensionCount + this.highCardinalityCount + complexDimensionCount;
+        this.outRecSize = this.measureCount + dimensionCount;
+        this.aggType = aggType;
     }
 
     /**
@@ -184,8 +175,18 @@ public class SortTempFileChunkHolder
      */
     public void initialize() throws MolapSortKeyAndGroupByException
     {
-        prefetch = MolapCommonConstants.MOLAP_PREFETCH_IN_MERGE_VALUE;
-        bufferSize=MolapCommonConstants.MOLAP_PREFETCH_BUFFERSIZE;
+        prefetch = Boolean.parseBoolean(MolapProperties.getInstance()
+                .getProperty("molap.prefetch.in.merge", "false"));
+        try
+        {
+            bufferSize = Integer.parseInt(MolapProperties.getInstance()
+                    .getProperty("molap.prefetch.bufferSize", "1000"));
+        }
+        catch(NumberFormatException e)
+        {
+            bufferSize = 1000;
+        }
+
         this.isSortTempFileCompressionEnabled = Boolean
                 .parseBoolean(MolapProperties
                         .getInstance()
@@ -238,7 +239,7 @@ public class SortTempFileChunkHolder
         try
         {
         	reader = TempSortFileReaderFactory.getInstance().getTempSortFileReader(
-        			isSortTempFileCompressionEnabled, dimensionCount, complexDimensionCount, measureCount, tempFile,highCardinalityCount);
+        			isSortTempFileCompressionEnabled, dimensionCount, measureCount, tempFile);
         	
         	if(isSortTempFileCompressionEnabled)
     		{
@@ -379,70 +380,47 @@ public class SortTempFileChunkHolder
      */
     private Object[] getRowFromStream() throws MolapSortKeyAndGroupByException
     {
-        // create new row of size 3 (1 for dims , 1 for high card , 1 for measures)
+        // create new row of size number of dimensions + measures
 
-        Object[] holder = new Object[3];
+        Object[] holder = new Object[this.outRecSize];
         int index = 0;
-        Integer[] dim = new Integer[this.dimensionCount];
-        Double[]  measures = new Double[this.measureCount]; 
-        byte[] finalByteArr = null ; 
+        
         try
         {
-        	
         	// read dimension values
-        	
         	for(int i = 0; i < this.dimensionCount; i++)
             {
-        		dim[index++] = stream.readInt();
+        		holder[index++] = stream.readInt();
             }
         	
-        	//Complex Type ByteArray to be read and kept for columnar
-        	for(int i = 0; i < this.complexDimensionCount; i++)
-        	{
-        		byte[] complexArray = new byte[stream.readInt()];
-        		stream.read(complexArray);
-        		holder[index++] = complexArray;
-        	}
-        	if(this.highCardinalityCount > 0)
-        	{
-        	    short lengthOfByteArray = stream.readShort();
-        	    ByteBuffer buff = ByteBuffer.allocate(lengthOfByteArray+2);
-        	    buff.putShort(lengthOfByteArray);
-        	    byte[] byteArr = new byte[lengthOfByteArray];
-        	    stream.readFully(byteArr);
-        	    
-        	    buff.put(byteArr);
-        	    finalByteArr = buff.array();
-        	    
-        	}
-        	
-        	/*for(int i = 0; i < this.highCardinalityCount; i++)
-            {
-        		short length = stream.readShort();
-        		byte[] arr = new byte[length];
-        		stream.read(arr);
-        		ByteBuffer buffer = ByteBuffer.allocate(MolapCommonConstants.BYTESREQTOSTORELENGTH+length);
-             	buffer.putShort(length);
-             	buffer.put(arr);
-             	buffer.rewind();
-        		holder[index++] = buffer;
-            }*/
-        	 index = 0;
             // read measure values
             for(int i = 0; i < this.measureCount; i++)
             {
             	if(stream.readByte() == 1)
                 {
-            	    measures[index++] = stream.readDouble();
+            		// TODO:- changes to made here for reading data according to datatype
+                    if(aggType[i] == MolapCommonConstants.SUM_COUNT_VALUE_MEASURE)
+                    {
+                        holder[index++] = stream.readDouble();
+                    }
+                    else if(aggType[i] == MolapCommonConstants.BIG_INT_MEASURE)
+                    {
+                        holder[index++] = stream.readLong();
+                    }
+                    else
+                    {
+                        int len = stream.readInt();
+                        byte[] buff = new byte[len];
+                        stream.readFully(buff);
+                        holder[index++] = buff;
+                    }
                 }
                 else
                 {
-                    measures[index++] = null;
+                    holder[index++] = null;
                 }
             }
             
-            RemoveDictionaryUtil.prepareOutObj(holder,dim,finalByteArr,measures);
-            
             // increment number if record read
             this.numberOfObjectRead++;
         }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/TempSortFileReaderFactory.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/TempSortFileReaderFactory.java
index 9ae94ff..bea526e 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/TempSortFileReaderFactory.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/TempSortFileReaderFactory.java
@@ -26,17 +26,17 @@ public final class TempSortFileReaderFactory
 	}
 	
 	public TempSortFileReader getTempSortFileReader(boolean isCompressionEnabled, int dimensionCount,
-			int complexDimensionCount, int measureCount, File tempFile,int highCardinalityCount)
+			int measureCount, File tempFile)
 	{
 		if(isCompressionEnabled)
 		{
-			return new CompressedTempSortFileReader(dimensionCount, complexDimensionCount,
-					measureCount, tempFile,highCardinalityCount);
+			return new CompressedTempSortFileReader(dimensionCount,
+					measureCount, tempFile);
 		}
 		else
 		{
-			return new UnCompressedTempSortFileReader(dimensionCount, complexDimensionCount,
-					measureCount, tempFile,highCardinalityCount);
+			return new UnCompressedTempSortFileReader(dimensionCount,
+					measureCount, tempFile);
 		}
 	}
 }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/TempSortFileWriterFactory.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/TempSortFileWriterFactory.java
index e6f678f..d237948 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/TempSortFileWriterFactory.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/TempSortFileWriterFactory.java
@@ -25,17 +25,17 @@ public final class TempSortFileWriterFactory
 	}
 	
 	public TempSortFileWriter getTempSortFileWriter(boolean isCompressionEnabled, int dimensionCount, 
-    		int complexDimensionCount, int measureCount,int highCardinalityCount, int writeBufferSize)
+    		int measureCount, int writeBufferSize)
 	{
 		if(isCompressionEnabled)
 		{
-			return new CompressedTempSortFileWriter(dimensionCount, complexDimensionCount,
-					measureCount,highCardinalityCount, writeBufferSize);
+			return new CompressedTempSortFileWriter(dimensionCount,
+					measureCount, writeBufferSize);
 		}
 		else
 		{
-			return new UnCompressedTempSortFileWriter(dimensionCount, complexDimensionCount,
-					measureCount,highCardinalityCount, writeBufferSize);
+			return new UnCompressedTempSortFileWriter(dimensionCount,
+					measureCount, writeBufferSize);
 		}
 	}
 }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/UnCompressedTempSortFileReader.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/UnCompressedTempSortFileReader.java
index 4804411..4aad0bb 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/UnCompressedTempSortFileReader.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/UnCompressedTempSortFileReader.java
@@ -23,10 +23,10 @@ public class UnCompressedTempSortFileReader extends AbstractTempSortFileReader
      * @param tempFile
      * @param type
      */
-    public UnCompressedTempSortFileReader(int dimensionCount, int complexDimensionCount, int measureCount,
-    		File tempFile, int highCardinalityCount)
+    public UnCompressedTempSortFileReader(int dimensionCount, int measureCount,
+    		File tempFile)
     {
-        super(dimensionCount, complexDimensionCount, measureCount, tempFile,highCardinalityCount);
+        super(dimensionCount, measureCount, tempFile);
     }
 
     /**
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/UnCompressedTempSortFileWriter.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/UnCompressedTempSortFileWriter.java
index 1a80b00..7fba07f 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/UnCompressedTempSortFileWriter.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortData/UnCompressedTempSortFileWriter.java
@@ -7,7 +7,6 @@ import java.io.IOException;
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.sortandgroupby.exception.MolapSortKeyAndGroupByException;
 import com.huawei.unibi.molap.util.MolapUtil;
-import com.huawei.unibi.molap.util.RemoveDictionaryUtil;
 
 /**
  * Project Name 	: Carbon 
@@ -27,10 +26,10 @@ public class UnCompressedTempSortFileWriter extends AbstractTempSortFileWriter
      * @param dimensionCount
      * @param measureCount
      */
-    public UnCompressedTempSortFileWriter(int dimensionCount, int complexDimensionCount, 
-    		int measureCount,int highCardinalityCount, int writeBufferSize)
+    public UnCompressedTempSortFileWriter(int dimensionCount, 
+    		int measureCount, int writeBufferSize)
     {
-        super(dimensionCount, complexDimensionCount, measureCount,highCardinalityCount, writeBufferSize);
+        super(dimensionCount, measureCount, writeBufferSize);
     }
 
     /**
@@ -53,7 +52,7 @@ public class UnCompressedTempSortFileWriter extends AbstractTempSortFileWriter
             blockDataArray = new ByteArrayOutputStream(totalSize);
             dataOutputStream = new DataOutputStream(blockDataArray);
             
-            writeDataOutputStream(records, dataOutputStream,measureCount,dimensionCount,highCardinalityCount,complexDimensionCount);
+            writeDataOutputStream(records, dataOutputStream,measureCount,dimensionCount);
             stream.writeInt(records.length);
             byte[] byteArray = blockDataArray.toByteArray();
             stream.writeInt(byteArray.length);
@@ -79,7 +78,7 @@ public class UnCompressedTempSortFileWriter extends AbstractTempSortFileWriter
 	 * @throws IOException
 	 */
 	public static void writeDataOutputStream(Object[][] records,
-			DataOutputStream dataOutputStream, int measureCount, int dimensionCount,int highCardinalityCount, int complexDimensionCount) throws IOException
+			DataOutputStream dataOutputStream, int measureCount, int dimensionCount) throws IOException
 	{
 		Object[] row;
 		for(int recordIndex = 0; recordIndex < records.length; recordIndex++)
@@ -89,28 +88,15 @@ public class UnCompressedTempSortFileWriter extends AbstractTempSortFileWriter
 		    
 		    for(int counter = 0; counter < dimensionCount; counter++)
 		    {
-		    	dataOutputStream.writeInt((Integer)RemoveDictionaryUtil.getDimension(fieldIndex++, row));
+		    	dataOutputStream.writeInt((Integer)row[fieldIndex++]);
 		    }
 		    
-		    //write byte[] of high card dims
-		    if(highCardinalityCount > 0)
-		    {
-		        dataOutputStream.write(RemoveDictionaryUtil.getByteArrayForNoDictionaryCols(row));
-		    }
-		    fieldIndex = 0;
-		    for(int counter = 0; counter < complexDimensionCount; counter++)
-            {
-            	int complexByteArrayLength = ((byte[])row[fieldIndex]).length;
-            	dataOutputStream.writeInt(complexByteArrayLength);
-            	dataOutputStream.write(((byte[])row[fieldIndex++]));
-            }
-		    
 		    for(int counter = 0; counter < measureCount; counter++)
 		    {
 		    	if(null != row[fieldIndex])
 		        {
 		            dataOutputStream.write((byte)1);
-		            dataOutputStream.writeDouble(RemoveDictionaryUtil.getMeasure(fieldIndex, row));
+		            dataOutputStream.writeDouble((Double)row[fieldIndex]);
 		        }
 		        else
 		        {
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortDataStep/SortKeyStep.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortDataStep/SortKeyStep.java
index 908834a..6af422a 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortDataStep/SortKeyStep.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortDataStep/SortKeyStep.java
@@ -34,7 +34,8 @@ import com.huawei.unibi.molap.schema.metadata.SortObserver;
 import com.huawei.unibi.molap.sortandgroupby.exception.MolapSortKeyAndGroupByException;
 import com.huawei.unibi.molap.sortandgroupby.sortData.SortDataRows;
 import com.huawei.unibi.molap.util.MolapDataProcessorLogEvent;
-import com.huawei.unibi.molap.util.RemoveDictionaryUtil;
+import com.huawei.unibi.molap.util.MolapDataProcessorUtil;
+import com.huawei.unibi.molap.util.MolapProperties;
 
 /**
  * Project Name 	: Carbon 
@@ -139,7 +140,7 @@ public class SortKeyStep extends BaseStep
         }
         
         // check if all records are null than send empty row to next step
-        else if(RemoveDictionaryUtil.checkAllValuesForNull(row))
+        else if(MolapDataProcessorUtil.checkAllValuesAreNull(row))
         {
             // create empty row out size 
             int outSize = Integer.parseInt(meta.getOutputRowSize());
@@ -173,15 +174,20 @@ public class SortKeyStep extends BaseStep
             // get all fields 
             this.meta.getFields(data.getOutputRowMeta(), getStepname(), null, null, this);
 
-			/*this.sortDataRows = new SortDataRows(meta.getTabelName(),
-					meta.getDimensionCount(), meta.getMeasureCount(), this.observer, meta.getCurrentRestructNumber(), meta.getHighCardinalityCount()); */
-            // TODO : send high cardinality count.
-            
-            this.meta.setHighCardinalityCount(RemoveDictionaryUtil.extractHighCardCount(meta.getHighCardinalityDims()));
-            
+			String measureDataType = meta.getMeasureDataType();
+			String[] msrdataTypes = null;
+            if(measureDataType.length() > 0)
+            {
+                msrdataTypes = measureDataType
+                        .split(MolapCommonConstants.AMPERSAND_SPC_CHARACTER);
+            }
+            else
+            {
+                msrdataTypes = new String[0];
+            }
             this.sortDataRows = new SortDataRows(meta.getTabelName(),
-					meta.getDimensionCount() - meta.getComplexDimensionCount(), 
-					meta.getComplexDimensionCount(), meta.getMeasureCount(), this.observer, meta.getCurrentRestructNumber(),meta.getHighCardinalityCount());
+					meta.getDimensionCount(), meta.getMeasureCount(), this.observer, meta.getCurrentRestructNumber(), msrdataTypes); 
+            
 			try 
 			{
 				// initialize sort
@@ -193,7 +199,9 @@ public class SortKeyStep extends BaseStep
                 throw new KettleException(e);
             }
 			
-            this.logCounter = Integer.parseInt(MolapCommonConstants.DATA_LOAD_LOG_COUNTER_DEFAULT_COUNTER);
+            this.logCounter = Integer.parseInt(MolapProperties.getInstance().getProperty(
+                    MolapCommonConstants.DATA_LOAD_LOG_COUNTER,
+                    MolapCommonConstants.DATA_LOAD_LOG_COUNTER_DEFAULT_COUNTER));
         }
         
         readCounter++;
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortDataStep/SortKeyStepMeta.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortDataStep/SortKeyStepMeta.java
index 04eb740..83ae19a 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortDataStep/SortKeyStepMeta.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortDataStep/SortKeyStepMeta.java
@@ -20,7 +20,6 @@ package com.huawei.unibi.molap.sortandgroupby.sortDataStep;
 
 import java.util.List;
 import java.util.Map;
-
 import org.pentaho.di.core.CheckResultInterface;
 import org.pentaho.di.core.Counter;
 import org.pentaho.di.core.database.DatabaseMeta;
@@ -82,16 +81,6 @@ public class SortKeyStepMeta extends BaseStepMeta implements StepMetaInterface
      * Dimension Count
      */
     private String dimensionCount;
-
-    /**
-     * ComplexTypes Count
-     */
-    private String complexDimensionCount;
-    
-    /**
-     * Dimension Count
-     */
-    private int highCardinalityCount;
     
     /**
      * measureCount
@@ -107,8 +96,9 @@ public class SortKeyStepMeta extends BaseStepMeta implements StepMetaInterface
 	private String updateMemberRequest;
 	
 	private int currentRestructNumber;
+	
+	private String measureDataType;
 
-	private String  highCardinalityDims;
     /**
      * set the default value for all the properties
      * 
@@ -120,13 +110,12 @@ public class SortKeyStepMeta extends BaseStepMeta implements StepMetaInterface
         factDimLensString = "";
         outputRowSize = "";
         schemaName = "";
-        highCardinalityDims="";
         cubeName = "";
         dimensionCount = "";
-        complexDimensionCount = "";
         measureCount = "";
         updateMemberRequest = "";
         currentRestructNumber = -1;
+        measureDataType = "";
     }
 
     /**
@@ -146,11 +135,10 @@ public class SortKeyStepMeta extends BaseStepMeta implements StepMetaInterface
         retval.append("    ").append(XMLHandler.addTagValue("cubeName", this.cubeName));
         retval.append("    ").append(XMLHandler.addTagValue("schemaName", this.schemaName));
         retval.append("    ").append(XMLHandler.addTagValue("dimensionCount", this.dimensionCount));
-        retval.append("    ").append(XMLHandler.addTagValue("highCardinalityDims", this.highCardinalityDims));
-        retval.append("    ").append(XMLHandler.addTagValue("complexDimensionCount", this.complexDimensionCount));
         retval.append("    ").append(XMLHandler.addTagValue("measureCount", this.measureCount));
         retval.append("    ").append(XMLHandler.addTagValue("isUpdateMemberRequest", this.updateMemberRequest));
         retval.append("    ").append(XMLHandler.addTagValue("currentRestructNumber", currentRestructNumber));
+        retval.append("    ").append(XMLHandler.addTagValue("measureDataType", measureDataType));
         return retval.toString();
     }
 
@@ -177,10 +165,9 @@ public class SortKeyStepMeta extends BaseStepMeta implements StepMetaInterface
             this.cubeName = XMLHandler.getTagValue(stepnode, "cubeName");
             this.schemaName = XMLHandler.getTagValue(stepnode, "schemaName");
             this.dimensionCount = XMLHandler.getTagValue(stepnode, "dimensionCount");
-            this.highCardinalityDims=XMLHandler.getTagValue(stepnode, "highCardinalityDims");
-            this.complexDimensionCount = XMLHandler.getTagValue(stepnode, "complexDimensionCount");
             this.measureCount = XMLHandler.getTagValue(stepnode, "measureCount");
             this.updateMemberRequest = XMLHandler.getTagValue(stepnode, "isUpdateMemberRequest");
+            this.measureDataType = XMLHandler.getTagValue(stepnode, "measureDataType");
             currentRestructNumber = Integer.parseInt(XMLHandler.getTagValue(stepnode, "currentRestructNumber"));
         }
         catch(Exception e)
@@ -213,11 +200,10 @@ public class SortKeyStepMeta extends BaseStepMeta implements StepMetaInterface
             rep.saveStepAttribute(idTransformation, idStep, "cubeName", this.cubeName);
             rep.saveStepAttribute(idTransformation, idStep, "schemaName", this.schemaName); 
             rep.saveStepAttribute(idTransformation, idStep, "dimensionCount", this.dimensionCount);
-            rep.saveStepAttribute(idTransformation, idStep, "highCardinalityDims", this.highCardinalityDims);
-            rep.saveStepAttribute(idTransformation, idStep, "complexDimensionCount", this.complexDimensionCount);
             rep.saveStepAttribute(idTransformation, idStep, "measureCount", this.measureCount); 
             rep.saveStepAttribute(idTransformation, idStep, "isUpdateMemberRequest", this.updateMemberRequest); 
             rep.saveStepAttribute(idTransformation, idStep, "currentRestructNumber", currentRestructNumber);
+            rep.saveStepAttribute(idTransformation, idStep, "measureDataType", measureDataType);
         }
         catch(Exception e)
         {
@@ -250,10 +236,9 @@ public class SortKeyStepMeta extends BaseStepMeta implements StepMetaInterface
             this.schemaName = rep.getStepAttributeString(idStep, "schemaName");
             this.cubeName = rep.getStepAttributeString(idStep, "cubeName");
             this.dimensionCount = rep.getStepAttributeString(idStep, "dimensionCount");
-            this.highCardinalityDims=rep.getStepAttributeString(idStep, "highCardinalityDims");
-            this.complexDimensionCount = rep.getStepAttributeString(idStep, "complexDimensionCount");
             this.measureCount = rep.getStepAttributeString(idStep, "measureCount");
             this.updateMemberRequest = rep.getStepAttributeString(idStep, "isUpdateMemberRequest");
+            this.measureDataType = rep.getStepAttributeString(idStep, "measureDataType");
             this.currentRestructNumber = (int)rep.getStepAttributeInteger(idStep, "currentRestructNumber");
         }
         catch(Exception ex)
@@ -408,33 +393,19 @@ public class SortKeyStepMeta extends BaseStepMeta implements StepMetaInterface
         return schemaName;
     }
 
-	/**
-	 * @return the dimensionCount
-	 */
-	public int getDimensionCount()
+    /**
+     * @return the dimensionCount
+     */
+    public int getDimensionCount()
 	{
 		return Integer.parseInt(dimensionCount);
 	}
-	
+
 	public void setDimensionCount(String dimensionCount)
 	{
 		this.dimensionCount = dimensionCount;
 	}
 
-	
-	/**
-	 * @return the complexDimensionCount
-	 */
-	public int getComplexDimensionCount()
-	{
-		return Integer.parseInt(complexDimensionCount);
-	}
-	
-	public void setComplexDimensionCount(String complexDimensionCount)
-	{
-		this.complexDimensionCount = complexDimensionCount;
-	}
-
 	/**
      * @return the measureCount
      */
@@ -499,28 +470,13 @@ public class SortKeyStepMeta extends BaseStepMeta implements StepMetaInterface
         this.currentRestructNumber = currentRestructNum;
     }
 
-	public String getHighCardinalityDims() {
-		return highCardinalityDims;
-	}
-
-	public void setHighCardinalityDims(String highCardinalityDims) {
-		this.highCardinalityDims = highCardinalityDims;
-	}
-
-    /**
-     * @return the highCardinalityCount
-     */
-    public int getHighCardinalityCount()
+    public String getMeasureDataType()
     {
-        return highCardinalityCount;
+        return measureDataType;
     }
 
-    /**
-     * @param highCardinalityCount the highCardinalityCount to set
-     */
-    public void setHighCardinalityCount(int highCardinalityCount)
+    public void setMeasureDataType(String measureDataType)
     {
-        this.highCardinalityCount = highCardinalityCount;
+        this.measureDataType = measureDataType;
     }
-
 }
\ No newline at end of file
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/IntermediateFileMerger.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/IntermediateFileMerger.java
index 97c1860..e34cdbf 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/IntermediateFileMerger.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/IntermediateFileMerger.java
@@ -24,6 +24,7 @@ import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.math.BigDecimal;
 import java.util.AbstractQueue;
 import java.util.Comparator;
 import java.util.PriorityQueue;
@@ -34,6 +35,7 @@ import com.huawei.iweb.platform.logging.LogServiceFactory;
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 import com.huawei.unibi.molap.sortandgroupby.exception.MolapSortKeyAndGroupByException;
+import com.huawei.unibi.molap.util.DataTypeUtil;
 import com.huawei.unibi.molap.util.MolapDataProcessorLogEvent;
 import com.huawei.unibi.molap.util.MolapUtil;
 import com.huawei.unibi.molap.util.MolapUtilException;
@@ -403,7 +405,7 @@ public class IntermediateFileMerger implements Callable<Void>
             // create chunk holder
             molapSortTempFileChunkHolder = new MolapSortTempFileChunkHolder(
                     tempFile, this.measureCount, this.mdKeyLength,
-                    this.fileReadBufferSize, this.isFactMdkeyInInputRow,this.factMdkeyLength, this.aggregator);
+                    this.fileReadBufferSize, this.isFactMdkeyInInputRow,this.factMdkeyLength, this.aggregator, this.type);
             // initialize
             molapSortTempFileChunkHolder.initialize();
             molapSortTempFileChunkHolder.readRow();
@@ -516,9 +518,48 @@ public class IntermediateFileMerger implements Callable<Void>
             MeasureAggregator[] aggregator = (MeasureAggregator[])row[aggregatorIndexInRowObject];
             for(int j = 0;j < aggregator.length;j++)
             {
-                byte[] byteArray = aggregator[j].getByteArray();
-                stream.writeInt(byteArray.length);
-                stream.write(byteArray);
+                if(type[j] == MolapCommonConstants.BYTE_VALUE_MEASURE)
+                {
+                    byte[] byteArray = aggregator[j].getByteArray();
+                    stream.writeInt(byteArray.length);
+                    stream.write(byteArray);
+                }
+                else if(type[j] == MolapCommonConstants.BIG_DECIMAL_MEASURE)
+                {
+                    BigDecimal val = aggregator[j].getBigDecimalValue();
+                    byte[] byteArray = DataTypeUtil.bigDecimalToByte(val);
+                    stream.writeInt(byteArray.length);
+                    stream.write(byteArray);
+                }
+                else
+                {
+                    // if measure value is null than aggregator will return
+                    // first time true as no record has been added, so writing
+                    // null value
+                    if(aggregator[j].isFirstTime())
+                    {
+                        stream.writeByte(MolapCommonConstants.MEASURE_NULL_VALUE);
+                    }
+                    else
+                    {
+                        // else writing not null value followed by data
+                        stream.writeByte(MolapCommonConstants.MEASURE_NOT_NULL_VALUE);
+                        if(type[j] == MolapCommonConstants.BIG_INT_MEASURE)
+                        {
+                            stream.writeLong(aggregator[j].getLongValue());
+                        }
+                        // add by ggin
+                        else if(type[j] == MolapCommonConstants.BIG_DECIMAL_MEASURE)
+                        {
+                            stream.writeUTF(aggregator[j].getBigDecimalValue().toString());
+                        }
+                        else
+                        {
+                            stream.writeDouble(aggregator[j].getDoubleValue());
+                        }
+                    }
+
+                }
             }
             stream.writeDouble((Double)row[this.mdKeyIndex - 1]);
             // write mdkye
@@ -527,40 +568,6 @@ public class IntermediateFileMerger implements Callable<Void>
             {
                 stream.write((byte[])row[row.length - 1]);
             }
-            // write measure value first
-//            for(int m = 0;m < measureCount;m++)	
-//            {
-//                if(type[m]!='c')
-//                {
-//                    // check if row is null or not
-//                    if(null != row[m])
-//                    {
-//                        // if not null than write 1 byte with value 1 to
-//                        // check
-//                        // whether that measure value is null or not
-//                        stream.write(1);
-//                        // than write measure value
-//                        stream.writeDouble((Double)row[m]);
-//                    }
-//                    else
-//                    {
-//                        // other wise write 0 for null check
-//                        stream.write(0);
-//                        stream.writeDouble(0.0);
-//                    }
-//                }
-//                else
-//                {
-//                    stream.writeInt(((byte[])row[m]).length);
-//                    stream.write((byte[])row[m]);
-//                }
-//                // write mdkye
-//            }
-//            stream.write((byte[])row[this.mdKeyIndex]);
-//            if(this.isFactMdkeyInInputRow)
-//            {
-//                stream.write((byte[])row[row.length-1]);
-//            }
         }
         catch(IOException e)
         {
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/MolapSortKeyAggregator.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/MolapSortKeyAggregator.java
index 342c57c..75b530e 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/MolapSortKeyAggregator.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/MolapSortKeyAggregator.java
@@ -66,7 +66,7 @@ public class MolapSortKeyAggregator
 
     private int resultSize;
     
-    private double[] mergedMinValue;
+    private Object[] mergedMinValue;
     
     
 
@@ -78,7 +78,7 @@ public class MolapSortKeyAggregator
      * @param type
      */
     public MolapSortKeyAggregator(String[] aggType, String[] aggClassName,
-            KeyGenerator factKeyGenerator, char[] type, double[] mergedMinValue)
+            KeyGenerator factKeyGenerator, char[] type, Object[] mergedMinValue)
     {
         this.keyIndex = aggType.length;
         this.aggType = aggType;
@@ -152,8 +152,20 @@ public class MolapSortKeyAggregator
             {
                 if(isNotNullValue[i])
                 {
-                    out[i] = aggregators[i].getValue();
+                    switch (AggUtil.getMeasureType(AggUtil.measureOrdinal[i]))
+                    {
+                        case BIGINT:
 
+                            out[i] = aggregators[i].getLongValue();
+                            break;
+                        case DECIMAL:
+
+                            out[i] = aggregators[i].getBigDecimalValue();
+                            break;
+                        default:
+
+                            out[i] = aggregators[i].getDoubleValue();
+                    }
                 }
                 else
                 {
@@ -201,8 +213,7 @@ public class MolapSortKeyAggregator
             if(null != row[i])
             {
                 double value = (Double)row[i];
-                aggregators[i].agg(value, (byte[])row[row.length - 1], 0,
-                        ((byte[])row[row.length - 1]).length);
+                aggregators[i].agg(value);
             }
         }
 
@@ -222,8 +233,7 @@ public class MolapSortKeyAggregator
             {
                 this.isNotNullValue[i] = true;
                 double value = (Double)row[i];
-                aggregators[i].agg(value, (byte[])row[row.length - 1], 0,
-                        ((byte[])row[row.length - 1]).length);
+                aggregators[i].agg(value);
             }
         }
         prvKey = (byte[])row[this.keyIndex];
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/MolapSortKeyHashbasedAggregator.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/MolapSortKeyHashbasedAggregator.java
index ab3c50a..f0e456a 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/MolapSortKeyHashbasedAggregator.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/MolapSortKeyHashbasedAggregator.java
@@ -57,7 +57,7 @@ public class MolapSortKeyHashbasedAggregator
     
     protected ByteArrayWrapper dimensionsRowWrapper;
     
-    private double[] mergedMinValue;
+    private Object[] mergedMinValue;
 
     /**
      * constructer.
@@ -67,7 +67,7 @@ public class MolapSortKeyHashbasedAggregator
      * @param type
      */
     public MolapSortKeyHashbasedAggregator(String[] aggType, String[] aggClassName,
-            KeyGenerator factKeyGenerator, char[] type, int numberOfRows, double[] mergedMinValue)
+            KeyGenerator factKeyGenerator, char[] type, int numberOfRows, Object[] mergedMinValue)
     {
         this.keyIndex = aggType.length;
         this.aggType = aggType;
@@ -202,8 +202,17 @@ public class MolapSortKeyHashbasedAggregator
 	            {
 	                if(!value[i].isFirstTime())
 	                {
-	                	row[i] = value[i].getValue();
-
+                        switch(AggUtil.getMeasureType(AggUtil.measureOrdinal[i]))
+                        {
+                            case BIGINT:
+                                row[i] = value[i].getLongValue();
+                                break;
+                            case  DECIMAL:
+                                row[i] = value[i].getBigDecimalValue();
+                                break;
+                            default:
+                                row[i] = value[i].getDoubleValue();
+                        }
 	                }
 	                else
 	                {
@@ -245,21 +254,18 @@ public class MolapSortKeyHashbasedAggregator
             	if(type[i]!='c')
             	{
             		double value = (Double)row[i];
-	                aggregators[i].agg(value, (byte[])row[row.length - 1], 0,
-	                        ((byte[])row[row.length - 1]).length);
+	                aggregators[i].agg(value);
             	}
             	else
             	{
             		if(row[i] instanceof byte[])
             		{
-            			  aggregators[i].agg(row[i], (byte[])row[row.length - 1], 0,
-      	                        ((byte[])row[row.length - 1]).length);
+            			  aggregators[i].agg(row[i]);
             		}
             		else
             		{
             			double value = (Double)row[i];
-            			aggregators[i].agg(value, (byte[])row[row.length - 1], 0,
-    	                        ((byte[])row[row.length - 1]).length);
+            			aggregators[i].agg(value);
             		}
             	}
             }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/MolapSortKeys.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/MolapSortKeys.java
index 732e110..161beb5 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/MolapSortKeys.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/MolapSortKeys.java
@@ -24,6 +24,7 @@ import java.io.File;
 import java.io.FileFilter;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.math.BigDecimal;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
@@ -46,12 +47,12 @@ import com.huawei.unibi.molap.keygenerator.KeyGenerator;
 import com.huawei.unibi.molap.keygenerator.factory.KeyGeneratorFactory;
 import com.huawei.unibi.molap.schema.metadata.SortObserver;
 import com.huawei.unibi.molap.sortandgroupby.exception.MolapSortKeyAndGroupByException;
+import com.huawei.unibi.molap.util.DataTypeUtil;
 import com.huawei.unibi.molap.util.MolapDataProcessorLogEvent;
 import com.huawei.unibi.molap.util.MolapDataProcessorUtil;
 import com.huawei.unibi.molap.util.MolapProperties;
 import com.huawei.unibi.molap.util.MolapUtil;
 import com.huawei.unibi.molap.util.MolapUtilException;
-import com.huawei.unibi.molap.util.RemoveDictionaryUtil;
 
 /**
  * Project Name NSE V3R7C00 
@@ -238,7 +239,7 @@ public class MolapSortKeys
     
     private MolapSortKeyHashbasedAggregator hashedBasedAgg;
     
-    private double[] mergedMinValue;
+    private Object[] mergedMinValue;
     
     
     public MolapSortKeys(String tabelName, int measureCount, int mdkeyIndex,
@@ -246,7 +247,7 @@ public class MolapSortKeys
 			SortObserver observer, boolean autoAggRequest,
 			boolean isFactMdkeyInInputRow, int factMdkeyLength, 
             String[] aggregators, String[] aggregatorClass, int[] factDims,
-            String schemaName, String cubeName, boolean isUpdateMemberRequest)
+            String schemaName, String cubeName, boolean isUpdateMemberRequest, char[] type)
     {
         // set table name
         this.tableName = tabelName;
@@ -273,13 +274,7 @@ public class MolapSortKeys
         }
 
         this.aggregators = aggregators;
-        type = new char[measureCount];
-        Arrays.fill(type, MolapCommonConstants.BYTE_VALUE_MEASURE);
-        for (int i = 0; i < type.length; i++) 
-        {
-        	this.type[i]=MolapUtil.getType(this.aggregators [i]);
-		}
-        type[type.length -1] = 'n';
+        this.type = type;
         this.aggregatorClass = aggregatorClass;
         this.factKetGenerator = KeyGeneratorFactory.getKeyGenerator(factDims);
         this.isUpdateMemberRequest=isUpdateMemberRequest;
@@ -372,8 +367,22 @@ public class MolapSortKeys
                     "Compression will be used for writing the sort temp File");
         }
         
-        prefetch = MolapCommonConstants.MOLAP_PREFETCH_IN_MERGE_VALUE;
-        bufferSize=MolapCommonConstants.MOLAP_PREFETCH_BUFFERSIZE;
+        prefetch = Boolean.parseBoolean(molapProperties
+                .getProperty("molap.prefetch.in.merge", "false"));
+        try
+        {
+            bufferSize = Integer.parseInt(molapProperties
+                    .getProperty("molap.prefetch.bufferSize", "1000"));
+        }
+        catch(NumberFormatException e)
+        {
+            SORTKEYLOGGER.error(
+                    MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG,
+                    "Invalid value for: "
+                            + "molap.prefetch.bufferSize"
+                            + ": Only Positive Integer value(greater than zero) is allowed.Default value will be used");
+            bufferSize = 1000;
+        }
 //        isGroupByInSort = Boolean.parseBoolean(molapProperties.getProperty(
 //                MolapCommonConstants.MOLAP_IS_GROUPBY_IN_SORT,
 //                MolapCommonConstants.MOLAP_IS_GROUPBY_IN_SORT_DEFAULTVALUE));
@@ -391,10 +400,10 @@ public class MolapSortKeys
         updateAggTypeForDistinctCount(useHashBasedAggWhileSorting);
         updateAggTypeForCustom();
         
-        if(isAutoAggRequest && !isUpdateMemberRequest)
-        {
-            mergedMinValue=MolapDataProcessorUtil.updateMergedMinValue(schemaName, cubeName, tableName,this.aggregators.length, MolapCommonConstants.FILE_INPROGRESS_STATUS, currentRestructNumber);
-        }
+//        if(isAutoAggRequest && !isUpdateMemberRequest)
+//        {
+//            mergedMinValue=MolapDataProcessorUtil.updateMergedMinValue(schemaName, cubeName, tableName,this.aggregators.length, MolapCommonConstants.FILE_INPROGRESS_STATUS, currentRestructNumber);
+//        }
         if(isAutoAggRequest && useHashBasedAggWhileSorting && !isUpdateMemberRequest)
         {
         	SORTKEYLOGGER.info(
@@ -1092,6 +1101,13 @@ public class MolapSortKeys
 	                    stream.writeInt(byteArray.length);
 	                    stream.write(byteArray);
                 	}
+                	else if(type[j] == MolapCommonConstants.BIG_DECIMAL_MEASURE)
+                	{
+                	    BigDecimal val = aggregator[j].getBigDecimalValue();
+                	    byte[] byteArray = DataTypeUtil.bigDecimalToByte(val);
+                	    stream.writeInt(byteArray.length);
+                        stream.write(byteArray);
+                	}
                 	else
                 	{
 						// if measure value is null than aggregator will return
@@ -1104,23 +1120,25 @@ public class MolapSortKeys
                 		{
                 			// else writing not null value followed by data
                 			stream.writeByte(MolapCommonConstants.MEASURE_NOT_NULL_VALUE);
-                			stream.writeDouble(aggregator[j].getValue());
+                			if(type[j] == MolapCommonConstants.BIG_INT_MEASURE)
+                			{
+                			    stream.writeLong(aggregator[j].getLongValue());
+                			}
+                            // add by ggin
+                            else if(type[j] == MolapCommonConstants.BIG_DECIMAL_MEASURE)
+                            {
+                                stream.writeUTF(aggregator[j].getBigDecimalValue().toString());
+                            }
+                			else
+                			{
+                			    stream.writeDouble(aggregator[j].getDoubleValue());
+                			}
                 		}
                 		
                 	}
                 }
-                stream.writeDouble((Double)row[aggregatorIndexInRowObject + 1]);
-                
-                // write the high cardinality if present.
-                
-                int highCardIndex = this.mdKeyIndex-1;
-                if(null != row[highCardIndex])
-                {
-                byte[] singleHighCardArr = (byte[])row[highCardIndex];
-                   stream.write(singleHighCardArr);
-                }
-                
-                // write mdkey
+                stream.writeDouble((Double)row[this.mdKeyIndex - 1]);
+                // write mdkye
                 stream.write((byte[])row[this.mdKeyIndex]);
                 if(isAutoAggRequest && isFactMdkeyInInputRow)
                 {
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/MolapSortTempFileChunkHolder.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/MolapSortTempFileChunkHolder.java
index 60335d1..82a3968 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/MolapSortTempFileChunkHolder.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/sortKey/MolapSortTempFileChunkHolder.java
@@ -24,7 +24,6 @@ import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
-import java.nio.ByteBuffer;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -150,11 +149,6 @@ public class MolapSortTempFileChunkHolder
     
     private String[] aggregator;
     
-    /**
-     * highCardCount
-     */
-    private int highCardCount;
-    
 
     /**
      * MolapSortTempFileChunkHolder Constructor
@@ -169,7 +163,7 @@ public class MolapSortTempFileChunkHolder
      */
     public MolapSortTempFileChunkHolder(File tempFile, int measureCount,
             int mdKeyLength, int fileBufferSize,boolean isFactMdkeyInInputRow,
-            int factMdkeyLength,String[] aggregator)
+            int factMdkeyLength,String[] aggregator, char[] type)
     {
         // set temp file
         this.tempFile = tempFile;
@@ -187,32 +181,7 @@ public class MolapSortTempFileChunkHolder
             this.outRecSize+=1;
         }
         this.aggregator = aggregator;
-        this.type = new char[aggregator.length];
-		for (int i = 0; i < aggregator.length; i++)
-		{
-			this.type[i]=MolapUtil.getType(aggregator[i]);
-		}
-    }
-
-    /**
-     * This constructor is used in case of high card dims  needed to be set.
-     * @param tmpFile
-     * @param measureCount2
-     * @param mdkeyLength2
-     * @param fileBufferSize2
-     * @param isFactMdkeyInInputRow2
-     * @param factMdkeyLength2
-     * @param aggregators
-     * @param highCardCount
-     */
-    public MolapSortTempFileChunkHolder(File tmpFile, int measureCount2,
-            int mdkeyLength2, int fileBufferSize2,
-            boolean isFactMdkeyInInputRow2, int factMdkeyLength2,
-            String[] aggregators, int highCardCount)
-    {
-        this(tmpFile, measureCount2, mdkeyLength2, fileBufferSize2,
-                isFactMdkeyInInputRow2, factMdkeyLength2, aggregators);
-       this.highCardCount = highCardCount;
+        this.type = type;
     }
 
     /**
@@ -228,7 +197,8 @@ public class MolapSortTempFileChunkHolder
         // new FileInputStream(tempFile),this.fileBufferSize));
         // read enrty count;
 
-        prefetch = MolapCommonConstants.MOLAP_PREFETCH_IN_MERGE_VALUE;
+        prefetch = Boolean.parseBoolean(MolapProperties.getInstance()
+                .getProperty("molap.prefetch.in.merge", "false"));
         this.isSortTempFileCompressionEnabled = Boolean
                 .parseBoolean(MolapProperties
                         .getInstance()
@@ -241,7 +211,15 @@ public class MolapSortTempFileChunkHolder
                     MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG,
                     "Compression was used while writing the sortTempFile");
         }
-        bufferSize=MolapCommonConstants.MOLAP_PREFETCH_BUFFERSIZE;
+        try
+        {
+            bufferSize = Integer.parseInt(MolapProperties.getInstance()
+                    .getProperty("molap.prefetch.bufferSize", "1000"));
+        }
+        catch(NumberFormatException e)
+        {
+            bufferSize = 1000;
+        }
 
         try
         {
@@ -450,12 +428,9 @@ public class MolapSortTempFileChunkHolder
      */
     private Object[] getRowFromStream() throws MolapSortKeyAndGroupByException
     {
-        Object[] holder = null;
-        byte[] finalByteArr = null;
-        // added one for high cardinlaity dims.  
-            holder = new Object[this.outRecSize+1];
-            
-            
+        // create new out row of size number of measures + one for mdkey
+
+        Object[] holder = new Object[this.outRecSize];
         byte[] byteArray = null;
 //        int readInt=0;
 //        MeasureAggregator aggregator = null;
@@ -464,7 +439,8 @@ public class MolapSortTempFileChunkHolder
         {
             for(int i=0; i<this.aggregator.length-1; i++)
             {
-                if(type[i]==MolapCommonConstants.BYTE_VALUE_MEASURE)
+                if(type[i] == MolapCommonConstants.BYTE_VALUE_MEASURE
+                        || type[i] == MolapCommonConstants.BIG_DECIMAL_MEASURE)
                 {
                     int length = stream.readInt();
                     byteArray = new byte[length];
@@ -475,28 +451,18 @@ public class MolapSortTempFileChunkHolder
                 {
                 	if(stream.readByte()==MolapCommonConstants.MEASURE_NOT_NULL_VALUE)
                 	{
-                		holder[i] = stream.readDouble();
+                	    if(type[i] == MolapCommonConstants.BIG_INT_MEASURE)
+                	    {
+                	        holder[i] = stream.readLong();
+                	    }
+                	    else
+                	    {
+                	        holder[i] = stream.readDouble();
+                	    }
                 	}
                 }
             }
             holder[this.aggregator.length - 1] = stream.readDouble();
-            
-            //Read byte [] of high cardinality from stream.
-            if(highCardCount > 0)
-            {
-                    short lengthOfByteArray = stream.readShort();
-                    ByteBuffer buff = ByteBuffer.allocate(lengthOfByteArray+2);
-                    buff.putShort(lengthOfByteArray);
-                    byte[] byteArr = new byte[lengthOfByteArray];
-                    stream.readFully(byteArr);
-                    
-                    buff.put(byteArr);
-                    finalByteArr = buff.array();
-                    
-            }
-            holder[measureCount] = finalByteArr;
-            
-            
             byteArray = new byte[mdKeyLength];
             // read mdkey
             if(stream.read(byteArray) < 0)
@@ -505,7 +471,7 @@ public class MolapSortTempFileChunkHolder
                         MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG,
                         "Problme while reading the mdkey fom sort temp file");
             }
-            holder[measureCount+1] = byteArray;
+            holder[measureCount] = byteArray;
             if(isFactMdkeyInInputRow)
             {
                 byteArray = new byte[this.factMdkeyLength];
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/step/MolapSortKeyAndGroupByStep.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/step/MolapSortKeyAndGroupByStep.java
index 86d9471..ce5b4f82 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/step/MolapSortKeyAndGroupByStep.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/step/MolapSortKeyAndGroupByStep.java
@@ -20,6 +20,7 @@ package com.huawei.unibi.molap.sortandgroupby.step;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.math.BigDecimal;
 import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
 import java.util.Arrays;
@@ -45,10 +46,14 @@ import com.huawei.unibi.molap.csvreader.checkpoint.CheckPointInterface;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 import com.huawei.unibi.molap.exception.MolapDataProcessorException;
 import com.huawei.unibi.molap.keygenerator.factory.KeyGeneratorFactory;
+import com.huawei.unibi.molap.metadata.MolapMetadata;
+import com.huawei.unibi.molap.metadata.MolapMetadata.Cube;
+import com.huawei.unibi.molap.metadata.MolapMetadata.Measure;
 import com.huawei.unibi.molap.metadata.SliceMetaData;
 import com.huawei.unibi.molap.schema.metadata.SortObserver;
 import com.huawei.unibi.molap.sortandgroupby.exception.MolapSortKeyAndGroupByException;
 import com.huawei.unibi.molap.sortandgroupby.sortKey.MolapSortKeys;
+import com.huawei.unibi.molap.util.DataTypeUtil;
 import com.huawei.unibi.molap.util.MolapDataProcessorLogEvent;
 import com.huawei.unibi.molap.util.MolapDataProcessorUtil;
 import com.huawei.unibi.molap.util.MolapProperties;
@@ -126,12 +131,12 @@ public class MolapSortKeyAndGroupByStep extends BaseStep
     /**
      * minValue
      */
-    private double[] minValue;
+    private Object[] minValue;
     
     /**
      * minValue
      */
-    private double[] maxValue;
+    private Object[] maxValue;
     
     /**
      * minValue
@@ -141,7 +146,7 @@ public class MolapSortKeyAndGroupByStep extends BaseStep
     /**
      * minValue
      */
-    private double[] uniqueValue;
+    private Object[] uniqueValue;
     
     /**
      * minValue
@@ -276,27 +281,19 @@ public class MolapSortKeyAndGroupByStep extends BaseStep
             {
                 factMDkeySize=((byte[])row[row.length-1]).length;
             }
-
-//            msrModel = MolapDataProcessorUtil.getMeasureModelForManual(meta.getFactStorePath(),
-//                    meta.getFactTableName(), meta.getFactMeasure().length, FileFactory.getFileType(meta.getFactStorePath()));
+            initAggregators(row);
+            aggType = getAggtype();
             initializeMeasureIndex(row);
             initialize();
             this.mdkeyIndex = row.length - 1;
             this.mdkeylength = meta.getMdkeyLength();
-//          this.molapSortKeys = new MolapSortKeys(meta.getTabelName(),
-//                  meta.getMeasureCount(), mdkeyIndex, mdkeylength,
-//                  this.checkpoint, this.observer, meta.isAutoAggRequest(),
-//                  meta.isFactMdKeyInInputRow(), factMDkeySize,
-//                  meta.getAggregators(), meta.getAggregatorClass(),
-//                  MolapDataProcessorUtil.getDimLens(meta
-//                          .getFactDimLensString()),meta.getSchemaName(),meta.getCubeName(), meta.isUpdateMemberRequest());
             this.molapSortKeys = new MolapSortKeys(meta.getTabelName(),
                     aggregators.length, mdkeyIndex, mdkeylength,
                     this.checkpoint, this.observer, meta.isAutoAggRequest(),
                     meta.isFactMdKeyInInputRow(), factMDkeySize,
                     this.aggregators, meta.getAggregatorClass(),
                     MolapDataProcessorUtil.getDimLens(meta
-                            .getFactDimLensString()),meta.getSchemaName(),meta.getCubeName(), meta.isUpdateMemberRequest());
+                            .getFactDimLensString()),meta.getSchemaName(),meta.getCubeName(), meta.isUpdateMemberRequest(), aggType);
             
             try {
                 // initialize sort
@@ -307,7 +304,9 @@ public class MolapSortKeyAndGroupByStep extends BaseStep
             {
                 throw new KettleException(e);
             }
-            this.logCounter = Integer.parseInt(MolapCommonConstants.DATA_LOAD_LOG_COUNTER_DEFAULT_COUNTER);
+            this.logCounter = Integer.parseInt(MolapProperties.getInstance().getProperty(
+                    MolapCommonConstants.DATA_LOAD_LOG_COUNTER,
+                    MolapCommonConstants.DATA_LOAD_LOG_COUNTER_DEFAULT_COUNTER));
         }
         readCounter++;
         if(readCounter%logCounter==0)
@@ -331,6 +330,30 @@ public class MolapSortKeyAndGroupByStep extends BaseStep
         
         return true;
     }
+    
+    private char[] getAggtype()
+    {
+        String[] aggMeasures = meta.getAggregateMeasuresColumnNameString()
+                .split(MolapCommonConstants.HASH_SPC_CHARACTER);
+        char[] aggType = new char[aggMeasures.length];
+        Arrays.fill(aggType, MolapCommonConstants.SUM_COUNT_VALUE_MEASURE);
+        Cube cube = MolapMetadata.getInstance().getCube(
+                meta.getSchemaName() + '_' + meta.getCubeName());
+        for(int i = 0;i < aggMeasures.length - 1;i++)
+        {
+            Measure measure = cube.getMeasure(cube.getFactTableName(),
+                    aggMeasures[i]);
+            if(null == measure)
+            {
+                aggType[i] = MolapUtil.getType(this.aggregators[i]);
+            }
+            else
+            {
+                aggType[i] = DataTypeUtil.getAggType(measure.getDataType());
+            }
+        }
+        return aggType;
+    }
 
     /**
      * Below method will be used to process data to next step 
@@ -405,62 +428,118 @@ public class MolapSortKeyAndGroupByStep extends BaseStep
      */
     private void initializeMeasureIndex(Object[] row)
     {
-//      measureIndex = new int[meta.getAggregateMeasures().length];
         MeasureAggregator[] aggregator = (MeasureAggregator[])row[0];
-        minValue = new double[aggregator.length + 1];
-        maxValue = new double[aggregator.length + 1];
-        uniqueValue = new double[aggregator.length + 1];
+        minValue = new Object[aggregator.length + 1];
+        maxValue = new Object[aggregator.length + 1];
+        uniqueValue = new Object[aggregator.length + 1];
         decimalLength = new int[aggregator.length + 1];
-        aggType = new char[aggregator.length + 1];
-        Arrays.fill(aggType, 'c');
-        this.aggregators = new String[aggregator.length + 1];
         for(int i = 0;i < aggregator.length;i++)
         {
-            String agg = MolapDataProcessorUtil.getAggType(aggregator[i]);
-            this.aggregators[i] = agg;
-            aggType[i]=MolapUtil.getType(agg);
-            maxValue[i] = -Double.MAX_VALUE;
-            minValue[i] = Double.MAX_VALUE;
+            if(aggType[i] == MolapCommonConstants.BIG_INT_MEASURE)
+            {
+                maxValue[i] = Long.MIN_VALUE;
+            }
+            else if(aggType[i] == MolapCommonConstants.SUM_COUNT_VALUE_MEASURE)
+            {
+                maxValue[i] = -Double.MAX_VALUE;
+            }
+            else
+            {
+                maxValue[i] = 0.0;
+            }
+            if(aggType[i] == MolapCommonConstants.BIG_INT_MEASURE)
+            {
+                minValue[i] = Long.MAX_VALUE;
+            }
+            else if(aggType[i] == MolapCommonConstants.SUM_COUNT_VALUE_MEASURE)
+            {
+                minValue[i] = Double.MAX_VALUE;
+            }
+            else
+            {
+                minValue[i] = 0.0;
+            }
             decimalLength[i] = 0;
         }
-        this.aggregators[aggregators.length - 1] = MolapCommonConstants.COUNT;
-        this.aggType[aggregators.length - 1] = 'n';
-        minValue[minValue.length - 1] = 1;
+        minValue[minValue.length - 1] = 1.0;
+        maxValue[maxValue.length - 1] = 1.0;
+        uniqueValue[minValue.length - 1] = 0.0;
+        decimalLength[decimalLength.length - 1] = 0;
         calculateMaxMinUnique(row);
     }
     
+    private void initAggregators(Object[] row)
+    {
+        MeasureAggregator[] aggregator = (MeasureAggregator[])row[0];
+        this.aggregators = new String[aggregator.length + 1];
+        for(int i = 0;i < aggregator.length;i++)
+        {
+            this.aggregators[i] = MolapDataProcessorUtil
+                    .getAggType(aggregator[i]);
+        }
+        this.aggregators[aggregators.length - 1] = MolapCommonConstants.COUNT;
+    }
     
     /**
      * This method will be used to update the max value for each measure
      * 
      * @param currentMeasures
-     * 
+     *
      */
-    protected void calculateMaxMinUnique(Object[] row)
+    private void calculateMaxMinUnique(Object[] row)
     {
         MeasureAggregator[] aggregator = (MeasureAggregator[])row[0];
         for(int i = 0;i < aggregator.length;i++)
         {
-        	if(MolapCommonConstants.BYTE_VALUE_MEASURE == aggType[i])
-        	{
-        		continue;
-        	}
-        	
-            double value = (Double)aggregator[i].getValue();
-            maxValue[i] = (maxValue[i] > value ? maxValue[i] : value);
-            minValue[i] = (minValue[i] < value ? minValue[i] : value);
-            uniqueValue[i] = minValue[i] - 1;
-            int num = (value % 1 == 0) ? 0 : decimalPointers;
-            decimalLength[i] = (decimalLength[i] > num ? decimalLength[i] : num);
+            if(aggType[i] == MolapCommonConstants.SUM_COUNT_VALUE_MEASURE)
+            {
+                double prevMaxVal = (double)maxValue[i];
+                double prevMinVal = (double)minValue[i];
+                double value = aggregator[i].getDoubleValue();
+                maxValue[i] = (prevMaxVal > value ? maxValue[i] : value);
+                minValue[i] = (prevMinVal < value ? minValue[i] : value);
+                uniqueValue[i] = (double)minValue[i] - 1;
+                int num = (value % 1 == 0) ? 0 : decimalPointers;
+                decimalLength[i] = (decimalLength[i] > num ? decimalLength[i]
+                        : num);
+            }
+            // add by ggin
+            else if(aggType[i] == MolapCommonConstants.BIG_DECIMAL_MEASURE)
+            {
+                BigDecimal prevMaxVal = new BigDecimal(maxValue[i].toString());
+                BigDecimal prevMinVal =  new BigDecimal(minValue[i].toString());
+                BigDecimal value = aggregator[i].getBigDecimalValue();
+                maxValue[i] = (prevMaxVal.compareTo(value) == 1 ? maxValue[i] : value);
+                minValue[i] = (prevMinVal.compareTo(value) == -1 ? minValue[i] : value);
+                uniqueValue[i] = (long)minValue[i] - 1;
+                int num = (value.doubleValue() % 1 == 0) ? 0 : decimalPointers;
+                decimalLength[i] = (decimalLength[i] > num ? decimalLength[i]
+                        : num);
+            }
+            else if(aggType[i] == MolapCommonConstants.BIG_INT_MEASURE)
+            {
+                long prevMaxVal = (long)maxValue[i];
+                long prevMinVal = (long)minValue[i];
+                long value = aggregator[i].getLongValue();
+                maxValue[i] = (prevMaxVal > value ? maxValue[i] : value);
+                minValue[i] = (prevMinVal < value ? minValue[i] : value);
+                uniqueValue[i] = (long)minValue[i] - 1;
+                int num = (value % 1 == 0) ? 0 : decimalPointers;
+                decimalLength[i] = (decimalLength[i] > num ? decimalLength[i]
+                        : num);
+            }
+            else
+            {
+                uniqueValue[i] = 0.0;
+            }
         }
+        // below code for calculating min and max value for count aggregator
         double value = (Double)row[1];
         row[1] = 1.0d;
-        minValue[minValue.length - 1] = (minValue[minValue.length - 1] < value ? minValue[minValue.length - 1] : value);
-        maxValue[maxValue.length - 1] = (maxValue[maxValue.length - 1] > value ? maxValue[maxValue.length - 1] : value);
-        uniqueValue[minValue.length - 1] = minValue[minValue.length - 1] - 1;
-        int num = (value % 1 == 0) ? 0 : decimalPointers;
-        decimalLength[decimalLength.length - 1] = (decimalLength[decimalLength.length - 1] > num ? decimalLength[decimalLength.length - 1]
-                : num);
+        minValue[minValue.length - 1] = ((double)minValue[minValue.length - 1] < value ? minValue[minValue.length - 1]
+                : value);
+        maxValue[maxValue.length - 1] = ((double)maxValue[maxValue.length - 1] > value ? maxValue[maxValue.length - 1]
+                : value);
     }
     
     /**
@@ -473,7 +552,7 @@ public class MolapSortKeyAndGroupByStep extends BaseStep
         String[] aggreateLevels = meta.getAggregateLevels();
         String[] factLevels = meta.getFactLevels();
         int[] cardinality = meta.getFactDimLens();
-        int[] aggCardinality = new int[aggreateLevels.length-meta.getHighCardinalityCount()];
+        int[] aggCardinality = new int[aggreateLevels.length];
         Arrays.fill(aggCardinality, -1);
         for(int k = 0;k < aggreateLevels.length;k++) 
         {
@@ -643,12 +722,6 @@ public class MolapSortKeyAndGroupByStep extends BaseStep
                     uniqueValue,
                     aggType,
                     new byte[minValue.length], measureMetaDataFileLocation);
-//            MolapDataProcessorUtil.writeMeasureMetaDataToFile(
-//                    new double[measureIndex.length], minValue,
-//                    new int[measureIndex.length],
-//                    new double[measureIndex.length],
-//                    new char[measureIndex.length],
-//                    new byte[measureIndex.length], measureMetaDataFileLocation);
         }
         catch(MolapDataProcessorException e)
         {
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/step/MolapSortKeyAndGroupByStepMeta.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/step/MolapSortKeyAndGroupByStepMeta.java
index ccb7b6d..b38e8b7 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/step/MolapSortKeyAndGroupByStepMeta.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/sortandgroupby/step/MolapSortKeyAndGroupByStepMeta.java
@@ -202,11 +202,6 @@ public class MolapSortKeyAndGroupByStepMeta extends BaseStepMeta implements Step
     private String mdkeyLength;
 
     /**
-     * 
-     */
-    private int highCardinalityCount;
-
-    /**
      * set the default value for all the properties
      * 
      */
@@ -236,7 +231,6 @@ public class MolapSortKeyAndGroupByStepMeta extends BaseStepMeta implements Step
         factDimLensString="";
         factStorePath = "";
         currentRestructNumber = -1;
-        highCardinalityCount = -1;
         mdkeyLength = "";
     }
     
@@ -329,9 +323,6 @@ public class MolapSortKeyAndGroupByStepMeta extends BaseStepMeta implements Step
                 XMLHandler.addTagValue("currentRestructNumber", 
                         currentRestructNumber));
         strBuffValue.append("    ").append(
-                XMLHandler.addTagValue("highCardinalityCount", 
-                        highCardinalityCount));
-        strBuffValue.append("    ").append(
                 XMLHandler.addTagValue("mdkeyLength", 
                         mdkeyLength));
         return strBuffValue.toString();
@@ -387,8 +378,6 @@ public class MolapSortKeyAndGroupByStepMeta extends BaseStepMeta implements Step
                     stepnode, "isManualAutoAggRequest");
             currentRestructNumber = Integer.parseInt(XMLHandler.getTagValue(
                     stepnode, "currentRestructNumber"));
-            highCardinalityCount = Integer.parseInt(XMLHandler.getTagValue(
-                    stepnode, "highCardinalityCount"));
             mdkeyLength = XMLHandler.getTagValue(stepnode, "mdkeyLength");
         }
         catch(Exception e)
@@ -455,8 +444,6 @@ public class MolapSortKeyAndGroupByStepMeta extends BaseStepMeta implements Step
             rep.saveStepAttribute(idTransformation, idStep, 
                     "currentRestructNumber", currentRestructNumber);
             rep.saveStepAttribute(idTransformation, idStep, 
-                    "highCardinalityCount", highCardinalityCount);
-            rep.saveStepAttribute(idTransformation, idStep, 
                     "mdkeyLength", mdkeyLength);
         }
         catch(Exception e)
@@ -520,8 +507,6 @@ public class MolapSortKeyAndGroupByStepMeta extends BaseStepMeta implements Step
                     idStep, "isManualAutoAggRequest");
             currentRestructNumber = (int)rep.getStepAttributeInteger(idStep, 
                     "currentRestructNumber");
-            highCardinalityCount = (int)rep.getStepAttributeInteger(idStep, 
-                    "highCardinalityCount");
             mdkeyLength = rep.getStepAttributeString(
                     idStep, "mdkeyLength");
         }
@@ -1152,21 +1137,4 @@ public class MolapSortKeyAndGroupByStepMeta extends BaseStepMeta implements Step
         this.mdkeyLength = mdkeyLength;
     }
 
-    /**
-     * 
-     * @return
-     */
-    public int getHighCardinalityCount()
-    {
-        return highCardinalityCount;
-    }
-
-    /**
-     * @param highCardinalityCount the highCardinalityCount to set
-     */
-    public void setHighCardinalityCount(int highCardinalityCount)
-    {
-        this.highCardinalityCount = highCardinalityCount;
-    }
-
 }
\ No newline at end of file
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapDataWriterStep.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapDataWriterStep.java
index 6c60738..f7fcb1d 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapDataWriterStep.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapDataWriterStep.java
@@ -19,7 +19,6 @@ package com.huawei.unibi.molap.store;
 import java.io.File;
 import java.io.FileFilter;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -39,6 +38,7 @@ import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.csvreader.checkpoint.CheckPointHanlder;
+import com.huawei.unibi.molap.datastorage.store.compression.ValueCompressionModel;
 import com.huawei.unibi.molap.metadata.SliceMetaData;
 import com.huawei.unibi.molap.store.writer.exception.MolapDataWriterException;
 import com.huawei.unibi.molap.threadbasedmerger.consumer.ConsumerThread;
@@ -49,6 +49,7 @@ import com.huawei.unibi.molap.util.MolapDataProcessorUtil;
 import com.huawei.unibi.molap.util.MolapProperties;
 import com.huawei.unibi.molap.util.MolapUtil;
 import com.huawei.unibi.molap.util.MolapUtilException;
+import com.huawei.unibi.molap.util.ValueCompressionUtil;
 
 
 
@@ -329,11 +330,16 @@ public class MolapDataWriterStep extends BaseStep implements StepInterface
         String[] measures = sliceMetaData.getMeasures();
         this.aggregators = sliceMetaData.getMeasuresAggregator();
         this.measureCount = measures.length;
-        int highCardIndex = measureCount;
-        // incremented the index of mdkey by 1 so that the earlier one is high card index.
-        this.mdKeyIndex = highCardIndex + 1;
-        bufferSize=MolapCommonConstants.MOLAP_PREFETCH_BUFFERSIZE;
-        
+        this.mdKeyIndex = measureCount;
+        try
+        {
+            bufferSize = Integer.parseInt(MolapProperties.getInstance()
+                    .getProperty("molap.prefetch.bufferSize", "1000"));
+        }
+        catch (NumberFormatException e)
+        {
+            bufferSize=1000;
+        }
         try
         {
             numberOfConsumerThreads = Integer.parseInt(instance.getProperty(
@@ -361,38 +367,11 @@ public class MolapDataWriterStep extends BaseStep implements StepInterface
                                 MolapCommonConstants.IS_PRODUCERCONSUMER_BASED_SORTING,
                                 MolapCommonConstants.PRODUCERCONSUMER_BASED_SORTING_ENABLED_DEFAULTVALUE));
         String [] aggType = sliceMetaData.getMeasuresAggregator();
-
+        ValueCompressionModel compressionModel = getValueCompressionModel(storeLocation);
         type = new char[measureCount];
-        Arrays.fill(type, 'c'); 
-        type[measureCount - 1] = 'n';
-//        boolean isGroupByInSort = Boolean
-//                .parseBoolean(MolapProperties
-//                        .getInstance()
-//                        .getProperty(
-//                                MolapCommonConstants.MOLAP_IS_GROUPBY_IN_SORT,
-//                                MolapCommonConstants.MOLAP_IS_GROUPBY_IN_SORT_DEFAULTVALUE));
-//        
-////        isGroupByInSort = updateStepConfForGroupByInSort(aggType, isGroupByInSort);
-        boolean isByteArrayInMeasure=true;
-        
-//        if(meta.isGroupByEnabled()
-//                && (isGroupByInSort || meta.isUpdateMemberRequest()))
-//        {
-//            aggType = MolapDataProcessorUtil.getUpdatedAggregator(meta
-//                    .getAggregators());
-//            for(int i = 0;i < aggType.length;i++)
-//            {
-//                if(aggType[i].equals(MolapCommonConstants.DISTINCT_COUNT)
-//                        || aggType[i].equals(MolapCommonConstants.AVERAGE))
-//                {
-//                    type[i] = 'c';
-//                    isByteArrayInMeasure = true;
-//                }
-//            }
-//        }
-//        
-//        isByteArrayInMeasure = updateStepConfForByteArrInMeasure(aggType, isByteArrayInMeasure);
+        type = compressionModel.getType();
         
+        boolean isByteArrayInMeasure=true;
         String levelCardinalityFilePath = storeLocation + File.separator + 
 				MolapCommonConstants.LEVEL_METADATA_FILE + meta.getTabelName() + ".metadata";
         int[] dimLens;
@@ -406,7 +385,7 @@ public class MolapDataWriterStep extends BaseStep implements StepInterface
         			"Problem while reading the cardinality from level metadata file", e1);
         }
         
-        updateFactHandler(isByteArrayInMeasure, aggType, dimLens, storeLocation);
+        updateFactHandler(isByteArrayInMeasure, aggType, dimLens, storeLocation, compressionModel);
         try
         {
             dataHandler.initialise();
@@ -530,7 +509,7 @@ public class MolapDataWriterStep extends BaseStep implements StepInterface
         SingleThreadFinalMerger finalMergerThread = new SingleThreadFinalMerger(
                 tempFileLocation, tableName, mdkeyLength, measureCount,
                 mdKeyIndex, meta.isFactMdKeyInInputRow(),
-                meta.getFactMdkeyLength(), type, this.aggregators,this.meta.gethighCardCount());
+                meta.getFactMdkeyLength(), type, this.aggregators);
         finalMergerThread.startFinalMerge();
         int recordCounter=0;
       //CHECKSTYLE:OFF    Approval No:Approval-V3R8C00_018
@@ -547,6 +526,16 @@ public class MolapDataWriterStep extends BaseStep implements StepInterface
       //CHECKSTYLE:ON
     }
     
+    private ValueCompressionModel getValueCompressionModel(String storeLocation)
+    {
+        String measureMetaDataFileLoc = storeLocation
+                + MolapCommonConstants.MEASURE_METADATA_FILE_NAME 
+                + this.tableName
+                + MolapCommonConstants.MEASUREMETADATA_FILE_EXT;
+        return ValueCompressionUtil.getValueCompressionModel(
+                measureMetaDataFileLoc, this.measureCount);
+    }
+    
     /**
      * below method will be used to producer consumer based sorting 
      */
@@ -715,18 +704,21 @@ public class MolapDataWriterStep extends BaseStep implements StepInterface
         }
     }
     
-    private void updateFactHandler(boolean isByteArrayInMeasure, String[] aggType, int[] dimLens, String storeLocation)
+    private void updateFactHandler(boolean isByteArrayInMeasure, String[] aggType, int[] dimLens, String storeLocation, ValueCompressionModel compressionModel)
     {
         boolean isColumnar=Boolean.parseBoolean(MolapCommonConstants.IS_COLUMNAR_STORAGE_DEFAULTVALUE);
         
         if(isColumnar)
         {
-            dataHandler = new MolapFactDataHandlerColumnar(meta.getSchemaName(),
-                    meta.getCubeName(), this.tableName, meta.isGroupByEnabled(),
-                    measureCount, mdkeyLength, mdKeyIndex, aggType,
-                    meta.getAggregatorClass(), storeLocation,
-                    MolapDataProcessorUtil.getDimLens(meta.getFactDimLensString()),
-                    isByteArrayInMeasure, meta.isUpdateMemberRequest(),dimLens,meta.getFactLevels(),meta.getAggregateLevels(), true, meta.getCurrentRestructNumber(),this.meta.gethighCardCount());
+            dataHandler = new MolapFactDataHandlerColumnar(
+                    meta.getSchemaName(), meta.getCubeName(), this.tableName,
+                    meta.isGroupByEnabled(), measureCount, mdkeyLength,
+                    mdKeyIndex, aggType, meta.getAggregatorClass(),
+                    storeLocation, MolapDataProcessorUtil.getDimLens(meta
+                            .getFactDimLensString()), isByteArrayInMeasure,
+                    meta.isUpdateMemberRequest(), dimLens,
+                    meta.getFactLevels(), meta.getAggregateLevels(), true,
+                    meta.getCurrentRestructNumber(), compressionModel);
         }
         else
         {
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapDataWriterStepMeta.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapDataWriterStepMeta.java
index bf5c861..e7c6923 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapDataWriterStepMeta.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapDataWriterStepMeta.java
@@ -141,7 +141,6 @@ public class MolapDataWriterStepMeta extends BaseStepMeta implements
     
     private int currentRestructNumber;
     
-    private int highCardCount;
     /**
      * 
      * MolapDataWriterStepMeta constructor to initialize this class
@@ -176,7 +175,6 @@ public class MolapDataWriterStepMeta extends BaseStepMeta implements
         factLevelsString="";
         mdkeyLength="";
         currentRestructNumber = -1;
-        highCardCount = -1;
     }
 
     /**
@@ -223,8 +221,6 @@ public class MolapDataWriterStepMeta extends BaseStepMeta implements
         		XMLHandler.addTagValue("mdkeyLength", mdkeyLength));
         retval.append("    ").append(
                 XMLHandler.addTagValue("currentRestructNumber", currentRestructNumber));
-        retval.append("    ").append(
-                XMLHandler.addTagValue("highCardCount", highCardCount));
         return retval.toString();
     }
 
@@ -264,8 +260,6 @@ public class MolapDataWriterStepMeta extends BaseStepMeta implements
             mdkeyLength = XMLHandler.getTagValue(stepnode, "mdkeyLength");
             currentRestructNumber = Integer.parseInt(XMLHandler.getTagValue(stepnode, 
                     "currentRestructNumber"));
-            highCardCount = Integer.parseInt(XMLHandler.getTagValue(stepnode, 
-                    "highCardCount"));
         }
         catch(Exception e)
         {
@@ -350,8 +344,6 @@ public class MolapDataWriterStepMeta extends BaseStepMeta implements
             		mdkeyLength);
             rep.saveStepAttribute(idTransformation, idStep, "currentRestructNumber", 
                     currentRestructNumber);
-            rep.saveStepAttribute(idTransformation, idStep, "highCardCount", 
-                    highCardCount);
        
         }
         catch(Exception e)
@@ -406,7 +398,6 @@ public class MolapDataWriterStepMeta extends BaseStepMeta implements
             factLevelsString = rep.getStepAttributeString(idStep, "factLevelsString");
             mdkeyLength = rep.getStepAttributeString(idStep, "mdkeyLength");
             currentRestructNumber = (int)rep.getStepAttributeInteger(idStep, "currentRestructNumber");
-            highCardCount = (int)rep.getStepAttributeInteger(idStep, "highCardCount");
         }
         catch(Exception ex3) 
         {
@@ -787,20 +778,4 @@ public class MolapDataWriterStepMeta extends BaseStepMeta implements
     {
         this.currentRestructNumber = currentRestructNum;
     }
-    
-    /**
-     * @return the highCardCount
-     */
-    public int gethighCardCount()
-    {
-        return highCardCount;
-    }
-
-    /**
-     * @param highCardCount the highCardCount to set
-     */
-    public void sethighCardCount(int highCardCount)
-    {
-        this.highCardCount = highCardCount;
-    }
 }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapFactDataHandler.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapFactDataHandler.java
index 14f7573..3a764c8 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapFactDataHandler.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapFactDataHandler.java
@@ -113,7 +113,7 @@ public class MolapFactDataHandler implements MolapFactHandler
     /**
      * uniqueValue
      */
-    private double[] uniqueValue;
+    private Object[] uniqueValue;
     
     /**
      * leaf node size
@@ -417,13 +417,13 @@ public class MolapFactDataHandler implements MolapFactHandler
         {
             if(null == row[otherMeasureIndex[i]])
             {
-                dataHolder[otherMeasureIndex[i]].setWritableDoubleValueByIndex(
+                dataHolder[otherMeasureIndex[i]].setWritableValueByIndex(
                         entryCount, uniqueValue[otherMeasureIndex[i]]);
             }
             else
             {
-                dataHolder[otherMeasureIndex[i]].setWritableDoubleValueByIndex(
-                        entryCount, (Double)row[otherMeasureIndex[i]]);
+                dataHolder[otherMeasureIndex[i]].setWritableValueByIndex(
+                        entryCount, row[otherMeasureIndex[i]]);
             }
         }
         for(int i = 0;i < customMeasureIndex.length;i++)
@@ -664,7 +664,7 @@ public class MolapFactDataHandler implements MolapFactHandler
         for(int i = 0;i < otherMeasureIndex.length;i++)
         {
             this.dataHolder[otherMeasureIndex[i]]=new MolapWriteDataHolder();
-            this.dataHolder[otherMeasureIndex[i]].initialiseDoubleValues(this.leafNodeSize);
+            this.dataHolder[otherMeasureIndex[i]].initialiseValues(this.leafNodeSize);
         }
         for(int i = 0;i < customMeasureIndex.length;i++)
         {
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapFactDataHandlerColumnar.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapFactDataHandlerColumnar.java
index a6a70f5..7ac508c 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapFactDataHandlerColumnar.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapFactDataHandlerColumnar.java
@@ -12,18 +12,17 @@
 package com.huawei.unibi.molap.store;
 
 import java.io.File;
+import java.math.BigDecimal;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.Map;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
-import com.huawei.datasight.molap.datatypes.GenericDataType;
 import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
@@ -31,7 +30,9 @@ import com.huawei.unibi.molap.datastorage.store.NodeMeasureDataStore;
 import com.huawei.unibi.molap.datastorage.store.columnar.BlockIndexerStorageForInt;
 import com.huawei.unibi.molap.datastorage.store.columnar.IndexStorage;
 import com.huawei.unibi.molap.datastorage.store.compression.ValueCompressionModel;
+import com.huawei.unibi.molap.datastorage.store.dataholder.AbstractWriteDataHolder;
 import com.huawei.unibi.molap.datastorage.store.dataholder.MolapWriteDataHolder;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapWriteLongDataHolder;
 import com.huawei.unibi.molap.datastorage.util.StoreFactory;
 import com.huawei.unibi.molap.engine.cache.QueryExecutorUtil;
 import com.huawei.unibi.molap.file.manager.composite.FileData;
@@ -51,12 +52,11 @@ import com.huawei.unibi.molap.store.writer.MolapFactDataWriterImplForIntIndex;
 import com.huawei.unibi.molap.store.writer.MolapFactDataWriterImplForIntIndexAndAggBlock;
 import com.huawei.unibi.molap.store.writer.MolapFactDataWriterImplForIntIndexAndAggBlockCompressed;
 import com.huawei.unibi.molap.store.writer.exception.MolapDataWriterException;
+import com.huawei.unibi.molap.util.DataTypeUtil;
 import com.huawei.unibi.molap.util.MolapDataProcessorLogEvent;
 import com.huawei.unibi.molap.util.MolapDataProcessorUtil;
 import com.huawei.unibi.molap.util.MolapProperties;
 import com.huawei.unibi.molap.util.MolapUtil;
-import com.huawei.unibi.molap.util.RemoveDictionaryUtil;
-import com.huawei.unibi.molap.util.ValueCompressionUtil;
 
 
 /**
@@ -111,23 +111,16 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
      * data store which will hold the measure data
      */
     private NodeMeasureDataStore dataStore;
-    
-    private Map<Integer,GenericDataType> complexIndexMap;
-
-	/**
-     * measure count
-     */
-    private int measureCount;
 
     /**
      * measure count
      */
-    private int dimensionCount;
+    private int measureCount;
     
-	/**
+    /**
      * uniqueValue
      */
-    private double[] uniqueValue;
+    private Object[] uniqueValue;
     
     /**
      * index of mdkey in incoming rows
@@ -188,7 +181,7 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
     /**
      * MolapWriteDataHolder
      */
-    private MolapWriteDataHolder[] dataHolder;
+    private AbstractWriteDataHolder[] dataHolder;
     
     /**
      * factDimLens
@@ -233,8 +226,6 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
     
     private boolean[] aggKeyBlock;
     
-    private boolean[] isNoDictionary;
-    
     private boolean isAggKeyBlock;
     
     private long processedDataCount;
@@ -272,13 +263,11 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
     
     private Object lock = new Object();
     
-    private MolapWriteDataHolder keyDataHolder;
-    
-    private MolapWriteDataHolder highCardkeyDataHolder;
+    private AbstractWriteDataHolder keyDataHolder;
     
     private int currentRestructNumber;
-
-    private int highCardCount;
+    
+    private char[] type;
     
 //    private String[] aggregator;
  
@@ -294,7 +283,6 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
      * @param mdKeyIndex
      * @param aggregators
      * @param aggregatorClass
-     * @param highCardCount 
      * @param extension
      */
     public MolapFactDataHandlerColumnar(String schemaName, String cubeName,
@@ -302,63 +290,7 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
             int mdkeyLength, int mdKeyIndex, String[] aggregators,
             String[] aggregatorClass, String storeLocation, int[] factDimLens,
             boolean isMergingRequestForCustomAgg, boolean isUpdateMemberRequest,  int[] dimLens, String[] factLevels,
-            String[] aggLevels, boolean isDataWritingRequest, int currentRestructNum, int highCardCount, 
-            int dimensionCount, Map<Integer,GenericDataType> complexIndexMap)
-    {
-    	this(schemaName, cubeName, tableName, isGroupByEnabled, measureCount, 
-    			mdkeyLength, mdKeyIndex, aggregators, aggregatorClass, storeLocation, 
-    			factDimLens, isMergingRequestForCustomAgg, isUpdateMemberRequest, 
-    			dimLens, factLevels, aggLevels, isDataWritingRequest, currentRestructNum, highCardCount);
-    	this.dimensionCount = dimensionCount;
-    	this.complexIndexMap = complexIndexMap;
-    	
-    	this.aggKeyBlock = new boolean[dimLens.length];
-        this.isAggKeyBlock = Boolean
-        		.parseBoolean(MolapProperties.getInstance().getProperty(
-                MolapCommonConstants.AGGREAGATE_COLUMNAR_KEY_BLOCK,
-                MolapCommonConstants.AGGREAGATE_COLUMNAR_KEY_BLOCK_DEFAULTVALUE));
-        if(isAggKeyBlock)
-        {
-            int highCardinalityValue = Integer.parseInt(MolapProperties.getInstance().getProperty(
-                MolapCommonConstants.HIGH_CARDINALITY_VALUE,
-                MolapCommonConstants.HIGH_CARDINALITY_VALUE_DEFAULTVALUE));
-            for(int i = 0;i < dimLens.length;i++)
-            {
-                if(dimLens[i]<highCardinalityValue)
-                {
-                    this.aggKeyBlock[i]=true;
-                }
-            }
-            if(dimensionCount < dimLens.length)
-            {
-            	int allColsCount = getColsCount();
-            	List<Boolean> aggKeyBlockWithComplex = new ArrayList<Boolean>(allColsCount);
-                for(int i = 0;i < dimensionCount;i++)
-                {
-                	GenericDataType complexDataType = complexIndexMap.get(i);
-            		if(complexDataType != null)
-            		{
-            			complexDataType.fillAggKeyBlock(aggKeyBlockWithComplex, this.aggKeyBlock);
-            		}
-            		else
-            		{
-            			aggKeyBlockWithComplex.add(this.aggKeyBlock[i]);
-            		}
-                }
-                this.aggKeyBlock = new boolean[allColsCount];
-                for(int i=0;i<allColsCount;i++)
-                {
-                	this.aggKeyBlock[i] = aggKeyBlockWithComplex.get(i);
-                }
-            }
-        }
-    }
-    public MolapFactDataHandlerColumnar(String schemaName, String cubeName,
-            String tableName, boolean isGroupByEnabled, int measureCount,
-            int mdkeyLength, int mdKeyIndex, String[] aggregators,
-            String[] aggregatorClass, String storeLocation, int[] factDimLens,
-            boolean isMergingRequestForCustomAgg, boolean isUpdateMemberRequest,  int[] dimLens, String[] factLevels,
-            String[] aggLevels, boolean isDataWritingRequest, int currentRestructNum, int highCardCount)
+            String[] aggLevels, boolean isDataWritingRequest, int currentRestructNum, ValueCompressionModel compressionModel)
     {
         this.schemaName = schemaName;
         this.cubeName = cubeName;
@@ -371,25 +303,14 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
         this.aggregators=aggregators;
         this.aggregatorClass=aggregatorClass;
         this.factDimLens=factDimLens;
-        this.highCardCount = highCardCount;
         this.isMergingRequestForCustomAgg=isMergingRequestForCustomAgg;
 //        this.isUpdateMemberRequest=isUpdateMemberRequest;
         this.dimLens=dimLens;
-        
-        boolean [] noDict = new boolean[dimLens.length+this.highCardCount];
-        // setting true value for dims of high card
-        for(int i = dimLens.length;i < noDict.length ; i++)
-        {
-            noDict[i] = true;
-        }
-        
-        this.isNoDictionary = noDict;
-        
-        this.aggKeyBlock= new boolean[dimLens.length+highCardCount];
+        this.aggKeyBlock= new boolean[dimLens.length];
         this.currentRestructNumber = currentRestructNum;
         isIntBasedIndexer = Boolean
                 .parseBoolean(MolapCommonConstants.IS_INT_BASED_INDEXER_DEFAULTVALUE);
-        
+        this.compressionModel = compressionModel;
         this.isAggKeyBlock = Boolean
         .parseBoolean(MolapCommonConstants.AGGREAGATE_COLUMNAR_KEY_BLOCK_DEFAULTVALUE);
         if(isAggKeyBlock)
@@ -413,7 +334,7 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
        
         if(this.isGroupByEnabled && isDataWritingRequest && !isUpdateMemberRequest)
         {
-            surrogateIndex = new int[aggLevels.length-highCardCount];
+            surrogateIndex = new int[aggLevels.length];
             Arrays.fill(surrogateIndex, -1);
             for(int k = 0;k < aggLevels.length;k++) 
             {
@@ -510,11 +431,6 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
     private void addToStore(Object[] row) throws MolapDataWriterException
     {
         byte[] mdkey = (byte[])row[this.mdKeyIndex];
-        byte[] highCardKey = null;
-        if(highCardCount > 0 || complexIndexMap.size() > 0)
-        {
-             highCardKey = (byte[])row[this.mdKeyIndex - 1];
-        }
         ByteBuffer byteBuffer = null;
         byte[] b = null;
         if(this.entryCount == 0)
@@ -523,46 +439,43 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
         }
         this.endKey = mdkey;
         // add to key store
-        if(mdkey.length > 0)
-        {
-            keyDataHolder.setWritableByteArrayValueByIndex(entryCount, mdkey);
-        }
-        
-        // for storing the byte [] for high card.
-        if(highCardCount > 0)
-        {
-            highCardkeyDataHolder.setWritableByteArrayValueByIndex(entryCount, highCardKey);
-        }
-        //Add all columns to keyDataHolder
-        keyDataHolder.setWritableByteArrayValueByIndex(entryCount, this.mdKeyIndex, row);
-        
+        keyDataHolder.setWritableByteArrayValueByIndex(entryCount, mdkey);
+        		
      // CHECKSTYLE:OFF Approval No:Approval-351
         for(int k = 0;k < otherMeasureIndex.length;k++) 
         {
             if(null == row[otherMeasureIndex[k]])
             {
-                dataHolder[otherMeasureIndex[k]].setWritableDoubleValueByIndex(
+                dataHolder[otherMeasureIndex[k]].setWritableValueByIndex(
                         entryCount, uniqueValue[otherMeasureIndex[k]]);
             }
             else
             {
-                dataHolder[otherMeasureIndex[k]].setWritableDoubleValueByIndex(
-                        entryCount, (Double)row[otherMeasureIndex[k]]);
+                dataHolder[otherMeasureIndex[k]].setWritableValueByIndex(
+                        entryCount, row[otherMeasureIndex[k]]);
             }
         }
         for(int i = 0;i < customMeasureIndex.length;i++) 
         {
-            b= (byte[])row[customMeasureIndex[i]];
-//            if(isUpdateMemberRequest)
-//            {
-                byteBuffer=ByteBuffer.allocate(b.length+MolapCommonConstants.INT_SIZE_IN_BYTE);
-                byteBuffer.putInt(b.length);
-                byteBuffer.put(b);
-                byteBuffer.flip();
-                b=byteBuffer.array();
-//            }
-            dataHolder[customMeasureIndex[i]].setWritableByteArrayValueByIndex(
-                    entryCount,b);
+            if(null == row[customMeasureIndex[i]]
+                    && type[customMeasureIndex[i]] == MolapCommonConstants.BIG_DECIMAL_MEASURE)
+            {
+                BigDecimal val = new BigDecimal(
+                        (double)uniqueValue[customMeasureIndex[i]]);
+                b = DataTypeUtil.bigDecimalToByte(val);
+            }
+            else
+            {
+                b = (byte[])row[customMeasureIndex[i]];
+            }
+            byteBuffer = ByteBuffer.allocate(b.length
+                    + MolapCommonConstants.INT_SIZE_IN_BYTE);
+            byteBuffer.putInt(b.length);
+            byteBuffer.put(b);
+            byteBuffer.flip();
+            b = byteBuffer.array();
+            dataHolder[customMeasureIndex[i]]
+                    .setWritableByteArrayValueByIndex(entryCount, b);
         }
         // CHECKSTYLE:ON
         this.entryCount++;
@@ -577,17 +490,13 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
 //                data[i]=keyBlockHolder[i].getKeyBlock().clone();
 //            }
             byte[][] byteArrayValues = keyDataHolder.getByteArrayValues().clone();
-            byte[][][] columnByteArrayValues = keyDataHolder.getColumnByteArrayValues().clone();
-            //TODO need to handle high card also here
-            
             byte[][] writableMeasureDataArray = this.dataStore.getWritableMeasureDataArray(dataHolder).clone();
             int entryCountLocal=entryCount;
             byte[] startKeyLocal=startKey;
             byte[] endKeyLocal=endKey;
             startKey= new byte[mdkeyLength];
             endKey= new byte[mdkeyLength];
-//            writerExecutorService.submit(new DataWriterThread(byteArrayValues,writableMeasureDataArray,entryCountLocal,startKeyLocal,endKeyLocal));
-            writerExecutorService.submit(new DataWriterThread(byteArrayValues,writableMeasureDataArray,columnByteArrayValues,entryCountLocal,startKeyLocal,endKeyLocal));
+            writerExecutorService.submit(new DataWriterThread(byteArrayValues,writableMeasureDataArray,entryCountLocal,startKeyLocal,endKeyLocal));
 //            writeDataToFile(data,writableMeasureDataArray,entryCount,startKey,endKey);
             // set the entry count to zero
             processedDataCount+=entryCount;
@@ -599,169 +508,63 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
         }
     }
 
-//    private void writeDataToFile(byte[][] data,
-//            byte[][] dataHolderLocal, int entryCountLocal,
-//            byte[] startkeyLocal, byte[] endKeyLocal)
-//            throws MolapDataWriterException
-//    {
-//        ExecutorService executorService= Executors.newFixedThreadPool(5);
-//        List<Future<IndexStorage>> submit = new ArrayList<Future<IndexStorage>>(numberOfColumns);
-//        byte[][][] columnsData = new byte[numberOfColumns][data.length][];
-//        for(int i = 0;i < data.length;i++)
-//        {
-//            byte[][] splitKey = columnarSplitter.splitKey(data[i]);
-//            for(int j = 0;j < splitKey.length;j++)
-//            {
-//                columnsData[j][i]=splitKey[j];
-//            }
-//        }
-//        for(int i = 0;i < numberOfColumns;i++)
-//        {
-//            submit.add(executorService.submit(new BlockSortThread(i,columnsData[i])));
-//        }
-//        executorService.shutdown();
-//        try
-//        {
-//            executorService.awaitTermination(1, TimeUnit.DAYS);
-//        }
-//        catch(InterruptedException ex) 
-//        { 
-//            // TODO Auto-generated catch block
-//         //   e.printStackTrace();
-//            LOGGER.info(MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG, ex, ex.getMessage());
-//        }
-//        IndexStorage[] blockStorage = new IndexStorage[numberOfColumns];
-//        try
-//        {
-//            for(int i = 0;i < blockStorage.length;i++)
-//            {
-//                blockStorage[i]=submit.get(i).get();
-//            }
-//        }
-//        catch(Exception exception) 
-//        {
-//            // TODO Auto-generated catch block
-////            e.printStackTrace();
-//        	 LOGGER.info(MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG, exception, exception.getMessage());
-//        }
-//        synchronized(lock)
-//        {
-//            this.dataWriter.writeDataToFile(
-//                    blockStorage,
-//                    dataHolderLocal,
-//                    entryCountLocal, startkeyLocal, endKeyLocal);
-//        }
-//    }
-    
     private void writeDataToFile(byte[][] data,
-    		byte[][] dataHolderLocal, byte[][][] columnData, int entryCountLocal,
-    		byte[] startkeyLocal, byte[] endKeyLocal)
-    				throws MolapDataWriterException
-    				{
-//    	for(int i = 0;i < data.length;i++)
-//    	{
-//    		byte[][] splitKey = columnarSplitter.splitKey(data[i]);
-//    		for(int j = 0;j < splitKey.length;j++)
-//    		{
-//    			columnsData[j][i]=splitKey[j];
-//    		}
-//    	}
-    	int allColsCount = getColsCount();
-    	List<ArrayList<byte[]>> colsAndValues = new ArrayList<ArrayList<byte[]>>();
-        for(int i=0;i<allColsCount;i++)
+            byte[][] dataHolderLocal, int entryCountLocal,
+            byte[] startkeyLocal, byte[] endKeyLocal)
+            throws MolapDataWriterException
+    {
+        ExecutorService executorService= Executors.newFixedThreadPool(5);
+        List<Future<IndexStorage>> submit = new ArrayList<Future<IndexStorage>>(numberOfColumns);
+        byte[][][] columnsData = new byte[numberOfColumns][data.length][];
+        for(int i = 0;i < data.length;i++)
         {
-        	colsAndValues.add(new ArrayList<byte[]>());
+            byte[][] splitKey = columnarSplitter.splitKey(data[i]);
+            for(int j = 0;j < splitKey.length;j++)
+            {
+                columnsData[j][i]=splitKey[j];
+            }
         }
-        
-        for(int i =0;i<columnData.length;i++)
+        for(int i = 0;i < numberOfColumns;i++)
         {
-        	int l=0;
-        	for(int j=0;j<dimensionCount;j++)
-        	{
-        		GenericDataType complexDataType = complexIndexMap.get(j);
-        		if(complexDataType != null)
-        		{
-        			List<ArrayList<byte[]>> columnsArray = new ArrayList<ArrayList<byte[]>>();
-        			for(int k=0;k<complexDataType.getColsCount();k++)
-        			{
-        				columnsArray.add(new ArrayList<byte[]>());
-        			}
-        			complexDataType.getColumnarDataForComplexType(columnsArray, ByteBuffer.wrap(columnData[i][j]));
-        			for(ArrayList<byte[]> eachColumn : columnsArray)
-        			{
-        				colsAndValues.get(l++).addAll(eachColumn);
-        			}
-        		}
-        		else
-        		{
-        			colsAndValues.get(l++).add(columnData[i][j]);
-        		}
-        	}
+            submit.add(executorService.submit(new BlockSortThread(i,columnsData[i])));
         }
-        
-//    	for(int i = 0;i < numberOfColumns;i++)
-//    	{
-//    		submit.add(executorService.submit(new BlockSortThread(i,columnsData[i])));
-//    	}
-        
-        ExecutorService executorService= Executors.newFixedThreadPool(5);
-        List<Future<IndexStorage>> submit = new ArrayList<Future<IndexStorage>>(allColsCount);
-        int l=0;
-    	for(int j=0;j<dimensionCount;j++)
-    	{
-    		GenericDataType complexDataType = complexIndexMap.get(j);
-    		if(complexDataType != null)
-    		{
-    			for(int k=0;k<complexDataType.getColsCount();k++)
-    			{
-    				submit.add(executorService.submit(new BlockSortThread(l, colsAndValues.get(l).toArray(new byte[colsAndValues.get(l++).size()][]), false)));
-    			}
-    		}
-    		else
-    		{
-    			submit.add(executorService.submit(new BlockSortThread(l, colsAndValues.get(l).toArray(new byte[colsAndValues.get(l++).size()][]), true)));
-    		}
-    	}
-        
-    	executorService.shutdown();
-    	try
-    	{
-    		executorService.awaitTermination(1, TimeUnit.DAYS);
-    	}
-    	catch(InterruptedException ex) 
-    	{ 
-    		// TODO Auto-generated catch block
-    		//   e.printStackTrace();
-    		LOGGER.info(MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG, ex, ex.getMessage());
-    	}
-    	IndexStorage[] blockStorage = new IndexStorage[numberOfColumns];
-    	try
-    	{
-    		for(int i = 0;i < blockStorage.length;i++)
-    		{
-    			blockStorage[i]=submit.get(i).get();
-    		}
-    	}
-    	catch(Exception exception) 
-    	{
-    		// TODO Auto-generated catch block
+        executorService.shutdown();
+        try
+        {
+            executorService.awaitTermination(1, TimeUnit.DAYS);
+        }
+        catch(InterruptedException ex) 
+        { 
+            // TODO Auto-generated catch block
+         //   e.printStackTrace();
+            LOGGER.info(MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG, ex, ex.getMessage());
+        }
+        IndexStorage[] blockStorage = new IndexStorage[numberOfColumns];
+        try
+        {
+            for(int i = 0;i < blockStorage.length;i++)
+            {
+                blockStorage[i]=submit.get(i).get();
+            }
+        }
+        catch(Exception exception) 
+        {
+            // TODO Auto-generated catch block
 //            e.printStackTrace();
-    		LOGGER.info(MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG, exception, exception.getMessage());
-    	}
-    	synchronized(lock)
-    	{
-    		this.dataWriter.writeDataToFile(
-    				blockStorage,
-    				dataHolderLocal,
-    				entryCountLocal, startkeyLocal, endKeyLocal);
-    	}
-    				}
+        	 LOGGER.info(MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG, exception, exception.getMessage());
+        }
+        synchronized(lock)
+        {
+            this.dataWriter.writeDataToFile(
+                    blockStorage,
+                    dataHolderLocal,
+                    entryCountLocal, startkeyLocal, endKeyLocal);
+        }
+    }
     
     private final class DataWriterThread implements Callable<IndexStorage>
     {
         private byte[][] data;
-
-        private byte[][][] columnData;
         
         private byte[][] dataHolderLocal;
         
@@ -778,21 +581,10 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
             this.endKeyLocal=endKey;
             this.dataHolderLocal=dataHolderLocal;
         }
-        
-        private DataWriterThread(byte[][] data,byte[][] dataHolderLocal, byte[][][] columnData, int entryCountLocal, byte[] startKey, byte[] endKey)
-        {
-        	this.data=data;
-        	this.columnData = columnData;
-        	this.entryCountLocal=entryCountLocal;
-        	this.startkeyLocal=startKey;
-        	this.endKeyLocal=endKey;
-        	this.dataHolderLocal=dataHolderLocal;
-        }
         @Override
         public IndexStorage call() throws Exception
         {
-//            writeDataToFile(this.data,dataHolderLocal, entryCountLocal,startkeyLocal,endKeyLocal);
-            writeDataToFile(this.data,dataHolderLocal,columnData, entryCountLocal,startkeyLocal,endKeyLocal);
+            writeDataToFile(this.data,dataHolderLocal,entryCountLocal,startkeyLocal,endKeyLocal);
             return null;
         }
         
@@ -802,37 +594,19 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
         private int index;
         
         private byte[][] data;
-		private boolean isSortRequired;
-        private boolean isCompressionReq;
-        
-        private boolean isHighCardinality;
-        
-        
-        private BlockSortThread(int index, byte[][] data, boolean isSortRequired)
+        private BlockSortThread(int index, byte[][] data)
         {
             this.index=index;
             this.data=data;
-            isCompressionReq = aggKeyBlock[this.index];
-            this.isSortRequired = isSortRequired;
-        }
-        public BlockSortThread(int index, byte[][] data, boolean b, boolean isHighCardinality, boolean isSortRequired)
-        {
-            this.index = index;
-            this.data = data;
-            isCompressionReq = b;
-            this.isHighCardinality = isHighCardinality;
-            this.isSortRequired = isSortRequired;
         }
         @Override
         public IndexStorage call() throws Exception
         {
-            return new BlockIndexerStorageForInt(this.data,isCompressionReq,isHighCardinality, isSortRequired);
+            return new BlockIndexerStorageForInt(this.data,aggKeyBlock[this.index]);
             
         }
         
     }
-    
-    
     /**
      * below method will be used to finish the data handler
      * @throws MolapDataWriterException
@@ -886,8 +660,6 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
 //            }
             
             byte[][] data = keyDataHolder.getByteArrayValues();
-            
-            
             byte[][][] columnsData = new byte[numberOfColumns][data.length][];
             for(int i = 0;i < data.length;i++)
             {
@@ -897,81 +669,12 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
                     columnsData[j][i]=splitKey[j];
                 }
             }
-            
-            byte[][][] highCardColumnsData = null;
-            byte[][][] complexColumnsData = null;
-            List<ArrayList<byte[]>> colsAndValues = new ArrayList<ArrayList<byte[]>>();
-            int complexColCount = complexIndexMap.size();
-            
-            for(int i=0;i<complexColCount;i++)
-            {
-                colsAndValues.add(new ArrayList<byte[]>());
-            }
-            
-            if(highCardCount > 0)
-            {
-                byte[][] highCardData = highCardkeyDataHolder
-                        .getByteArrayValues();
-
-                highCardColumnsData = new byte[highCardCount][highCardData.length][];
-                complexColumnsData = new byte[complexColCount][highCardData.length][];
-                
-                for(int i = 0;i < highCardData.length;i++)
-                {
-
-                    byte[][] splitKey = RemoveDictionaryUtil.splitHighCardKey(
-                            highCardData[i], highCardCount+complexIndexMap.size());
-                    
-                    int complexTypeIndex = 0;
-                    for(int j = 0;j < splitKey.length;j++)
-                    {
-                        //nodictionary Columns
-                        if(j < highCardCount)
-                        {
-                            highCardColumnsData[j][i] = splitKey[j];
-                        }
-                        //complex types
-                        else
-                        {
-                            //Need to write columnar block from complex byte array
-                            GenericDataType complexDataType = complexIndexMap.get(numberOfColumns+j);
-                            if(complexDataType != null)
-                            {
-                                List<ArrayList<byte[]>> columnsArray = new ArrayList<ArrayList<byte[]>>();
-                                for(int k=0;k<complexDataType.getColsCount();k++)
-                                {
-                                    columnsArray.add(new ArrayList<byte[]>());
-                                }
-                                complexDataType.getColumnarDataForComplexType(columnsArray, ByteBuffer.wrap(splitKey[j]));
-                                for(ArrayList<byte[]> eachColumn : columnsArray)
-                                {
-                                    colsAndValues.get(complexTypeIndex++).addAll(eachColumn);
-                                }
-                            }
-                            else
-                            {
-                                // This case not possible as ComplexType is the last columns
-                            }
-                        }
-                    }
-                }
-            }
             ExecutorService executorService= Executors.newFixedThreadPool(7);
-            List<Future<IndexStorage>> submit = new ArrayList<Future<IndexStorage>>(numberOfColumns+highCardCount);
-            int i = 0;
-            for( i = 0;i < numberOfColumns;i++)
+            List<Future<IndexStorage>> submit = new ArrayList<Future<IndexStorage>>(numberOfColumns);
+            for(int i = 0;i < numberOfColumns;i++)
             {
-                submit.add(executorService.submit(new BlockSortThread(i, columnsData[i], true)));
+                submit.add(executorService.submit(new BlockSortThread(i, columnsData[i])));
             }
-            for(int j  = 0;j < highCardCount;j++)
-            {
-                submit.add(executorService.submit(new BlockSortThread(i++, highCardColumnsData[j],false,true, true)));
-            }
-            for(int k  = 0;k < complexColCount;k++)
-            {
-                submit.add(executorService.submit(new BlockSortThread(i++, colsAndValues.get(k).toArray(new byte[colsAndValues.get(k).size()][]), false)));
-            }
-            
             executorService.shutdown();
             try
             {
@@ -983,19 +686,19 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
 //                e.printStackTrace();
                 LOGGER.info(MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG, e, e.getMessage());
             }
-            IndexStorage[] blockStorage = new IndexStorage[numberOfColumns+highCardCount+complexColCount];
+            IndexStorage[] blockStorage = new IndexStorage[numberOfColumns];
             try
             {
-                for(int k = 0;k < blockStorage.length;k++)
-                {
-                    blockStorage[k] = submit.get(k).get();
-                }
+            for(int i = 0;i < blockStorage.length;i++)
+            {
+                blockStorage[i]=submit.get(i).get();
+            }
             }
             catch(Exception e)
             {
                 // TODO Auto-generated catch block
 //                e.printStackTrace();
-                 LOGGER.info(MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG, e, e.getMessage());
+            	 LOGGER.info(MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG, e, e.getMessage());
             }
             
             writerExecutorService.shutdown();
@@ -1007,7 +710,7 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
             {
                 // TODO Auto-generated catch block
 //                e.printStackTrace();
-                 LOGGER.info(MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG, e, e.getMessage());
+            	 LOGGER.info(MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG, e, e.getMessage());
             }
             this.dataWriter.writeDataToFile(
                     blockStorage,
@@ -1025,7 +728,6 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
             this.dataWriter.writeleafMetaDataToFile();
         }
     }
-    
     //TODO SIMIAN
     private byte[] getAggregateTableMdkey(byte[] maksedKey) throws MolapDataWriterException
     {
@@ -1048,22 +750,6 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
         }
     }
     
-    private int getColsCount()
-    {
-    	int count=0;
-    	for(int i=0;i<dimensionCount;i++)
-    	{
-    		GenericDataType complexDataType = complexIndexMap.get(i);
-    		if(complexDataType != null)
-    		{
-    			count += complexDataType.getColsCount();
-    		}
-    		else
-    			count++;
-    	}
-    	return count;
-    }
-    
     /**
      * below method will be used to close the handler
      */
@@ -1126,15 +812,15 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
     private void setWritingConfiguration(int mdkeySize)
             throws MolapDataWriterException
     {
-        String measureMetaDataFileLoc = this.storeLocation
-                + MolapCommonConstants.MEASURE_METADATA_FILE_NAME 
-                + this.tableName
-                + MolapCommonConstants.MEASUREMETADATA_FILE_EXT;
+//        String measureMetaDataFileLoc = this.storeLocation
+//                + MolapCommonConstants.MEASURE_METADATA_FILE_NAME 
+//                + this.tableName
+//                + MolapCommonConstants.MEASUREMETADATA_FILE_EXT;
         // get the compression model
         // this will used max, min and decimal point value present in the
         // and the measure count to get the compression for each measure
-        this.compressionModel = ValueCompressionUtil.getValueCompressionModel(
-                measureMetaDataFileLoc, this.measureCount);
+//        this.compressionModel = ValueCompressionUtil.getValueCompressionModel(
+//                measureMetaDataFileLoc, this.measureCount);
         this.uniqueValue = compressionModel.getUniqueValue();
         // get leaf node size
         this.leafNodeSize = Integer.parseInt(MolapProperties.getInstance().getProperty(
@@ -1153,22 +839,9 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
 //        {
 //        	dimSet=dimLens.length;
 //        }
-        // if atleast one dimension is present then initialize column splitter otherwise null
-        
-        int[] keyBlockSize = null;
-        if(dimLens.length > 0)
-        {
-            this.columnarSplitter= new MultiDimKeyVarLengthEquiSplitGenerator(MolapUtil.getIncrementedCardinalityFullyFilled(dimLens.clone()),(byte)dimSet);
-            this.keyBlockHolder= new MolapKeyBlockHolder [this.columnarSplitter.getBlockKeySize().length];
-            keyBlockSize = columnarSplitter.getBlockKeySize();
-        }
-        else
-        {
-            keyBlockSize = new int[0];
-            this.keyBlockHolder= new MolapKeyBlockHolder [0];
-        }
-        
+        this.columnarSplitter= new MultiDimKeyVarLengthEquiSplitGenerator(MolapUtil.getIncrementedCardinalityFullyFilled(dimLens.clone()),(byte)dimSet);
          
+        this.keyBlockHolder= new MolapKeyBlockHolder [this.columnarSplitter.getBlockKeySize().length];
         
         for(int i =0;i <keyBlockHolder.length;i++)
         {
@@ -1181,12 +854,14 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
         // create data store
         this.dataStore = StoreFactory.createDataStore(compressionModel);
         // agg type
-        char[]type=compressionModel.getType();
+        type=compressionModel.getType();
         List<Integer> otherMeasureIndexList = new ArrayList<Integer>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
         List<Integer> customMeasureIndexList = new ArrayList<Integer>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
         for(int j = 0;j < type.length;j++)
         {
-            if(type[j]!='c')
+        	// TODO: - check for 'b' ad big decimal and put it into custom measure list
+            if(type[j] != MolapCommonConstants.BYTE_VALUE_MEASURE
+                    && type[j] != MolapCommonConstants.BIG_DECIMAL_MEASURE)
             {
                 otherMeasureIndexList.add(j); 
             }
@@ -1206,11 +881,18 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
             customMeasureIndex[i]=customMeasureIndexList.get(i);
         }
         
-        this.dataHolder= new MolapWriteDataHolder[this.measureCount];
+        this.dataHolder= new AbstractWriteDataHolder[this.measureCount];
          for(int i = 0;i < otherMeasureIndex.length;i++)
           {
-              this.dataHolder[otherMeasureIndex[i]]=new MolapWriteDataHolder();
-              this.dataHolder[otherMeasureIndex[i]].initialiseDoubleValues(this.leafNodeSize);
+             if(type[otherMeasureIndex[i]] == MolapCommonConstants.BIG_INT_MEASURE)
+             {
+                 this.dataHolder[otherMeasureIndex[i]]=new MolapWriteLongDataHolder();
+             }
+             else
+             {
+                 this.dataHolder[otherMeasureIndex[i]]=new MolapWriteDataHolder();
+             }
+             this.dataHolder[otherMeasureIndex[i]].initialiseValues(this.leafNodeSize);
           }
           for(int i = 0;i < customMeasureIndex.length;i++)
           {
@@ -1220,17 +902,13 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
           
           keyDataHolder = new MolapWriteDataHolder();
           keyDataHolder.initialiseByteArrayValues(leafNodeSize);
-          highCardkeyDataHolder = new MolapWriteDataHolder();
-          highCardkeyDataHolder.initialiseByteArrayValues(leafNodeSize);
-          
         initialisedataHolder();
         // create data writer instance
 //        this.dataWriter = new MolapFactDataWriterImpl(this.storeLocation,
 //                this.measureCount, this.mdkeyLength, this.tableName,true,fileManager, this.columnarSplitter.getBlockKeySize());
         
         this.dataWriter=getFactDataWriter(this.storeLocation,
-                this.measureCount, this.mdkeyLength, this.tableName,true,fileManager, keyBlockSize);
-        this.dataWriter.setIsNoDictionary(isNoDictionary);
+                this.measureCount, this.mdkeyLength, this.tableName,true,fileManager, this.columnarSplitter.getBlockKeySize());
         // initialize the channel;
         this.dataWriter.initializeWriter();
         
@@ -1276,7 +954,7 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
         else if(isIntBasedIndexer && isAggKeyBlock)
         {
             LOGGER.info(MolapDataProcessorLogEvent.UNIBI_MOLAPDATAPROCESSOR_MSG, "*************************************aggregated and int");
-            return new MolapFactDataWriterImplForIntIndexAndAggBlock(storeLocation, measureCount, mdKeyLength, tableName, isNodeHolder, fileManager, keyBlockSize,aggKeyBlock,false, isComplexTypes());
+            return new MolapFactDataWriterImplForIntIndexAndAggBlock(storeLocation, measureCount, mdKeyLength, tableName, isNodeHolder, fileManager, keyBlockSize,aggKeyBlock,false);
         }
         else if(isIntBasedIndexer)
         {
@@ -1289,58 +967,4 @@ public class MolapFactDataHandlerColumnar implements MolapFactHandler
             return new MolapFactDataWriterImpl(storeLocation, measureCount, mdKeyLength, tableName, isNodeHolder, fileManager, keyBlockSize,false);
         }
     }
-    private int[] getBlockKeySizeWithComplexTypes(int[] primitiveBlockKeySize)
-    {
-    	int allColsCount = getColsCount();
-    	int[] blockKeySizeWithComplexTypes = new int[allColsCount];
-    	
-    	List<Integer> blockKeySizeWithComplex = new ArrayList<Integer>(allColsCount);
-        for(int i = 0;i < dimensionCount;i++)
-        {
-        	GenericDataType complexDataType = complexIndexMap.get(i);
-    		if(complexDataType != null)
-    		{
-    			complexDataType.fillBlockKeySize(blockKeySizeWithComplex, primitiveBlockKeySize);
-    		}
-    		else
-    		{
-    			blockKeySizeWithComplex.add(primitiveBlockKeySize[i]);
-    		}
-        }
-        for(int i=0;i<allColsCount;i++)
-        {
-        	blockKeySizeWithComplexTypes[i] = blockKeySizeWithComplex.get(i);
-        }
-    	
-    	return blockKeySizeWithComplexTypes;
-    }
-    private boolean[] isComplexTypes()
-    {
-    	int allColsCount = getColsCount();
-    	boolean[] isComplexType = new boolean[allColsCount];
-    	
-    	List<Boolean> complexTypesList = new ArrayList<Boolean>(allColsCount);
-    	for(int i = 0;i < dimensionCount;i++)
-    	{
-    		GenericDataType complexDataType = complexIndexMap.get(i);
-    		if(complexDataType != null)
-    		{
-    			int count = complexDataType.getColsCount();
-    			for(int j=0;j<count;j++)
-    			{
-    				complexTypesList.add(true);
-    			}
-    		}
-    		else
-    		{
-    			complexTypesList.add(false);
-    		}
-    	}
-    	for(int i=0;i<allColsCount;i++)
-    	{
-    		isComplexType[i] = complexTypesList.get(i);
-    	}
-    	
-    	return isComplexType;
-    }
 }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapFactDataHandlerColumnarMerger.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapFactDataHandlerColumnarMerger.java
index 59f7de4..f8469f3 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapFactDataHandlerColumnarMerger.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/MolapFactDataHandlerColumnarMerger.java
@@ -92,7 +92,7 @@ public class MolapFactDataHandlerColumnarMerger implements MolapFactHandler
     /**
      * uniqueValue
      */
-    private double[] uniqueValue;
+    private Object[] uniqueValue;
 
     /**
      * leaf node size
@@ -303,13 +303,13 @@ public class MolapFactDataHandlerColumnarMerger implements MolapFactHandler
         {
             if(null == row[otherMeasureIndex[i]])
             {
-                dataHolder[otherMeasureIndex[i]].setWritableDoubleValueByIndex(
+                dataHolder[otherMeasureIndex[i]].setWritableValueByIndex(
                         entryCount, uniqueValue[otherMeasureIndex[i]]);
             }
             else
             {
-                dataHolder[otherMeasureIndex[i]].setWritableDoubleValueByIndex(
-                        entryCount, (Double)row[otherMeasureIndex[i]]);
+                dataHolder[otherMeasureIndex[i]].setWritableValueByIndex(
+                        entryCount, row[otherMeasureIndex[i]]);
             }
         }
         for(int i = 0;i < customMeasureIndex.length;i++)
@@ -459,7 +459,7 @@ public class MolapFactDataHandlerColumnarMerger implements MolapFactHandler
         public IndexStorage call() throws Exception
         {
             return new BlockIndexerStorageForInt(this.data,
-                    aggKeyBlock[this.index], true);
+                    aggKeyBlock[this.index]);
 
         }
 
@@ -712,7 +712,7 @@ public class MolapFactDataHandlerColumnarMerger implements MolapFactHandler
                 MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
         for(int i = 0;i < type.length;i++)
         {
-            if(type[i] != 'c')
+            if(type[i] != 'c' && type[i] != 'b')
             {
                 otherMeasureIndexList.add(i);
             }
@@ -738,7 +738,7 @@ public class MolapFactDataHandlerColumnarMerger implements MolapFactHandler
         {
             this.dataHolder[otherMeasureIndex[i]] = new MolapWriteDataHolder();
             this.dataHolder[otherMeasureIndex[i]]
-                    .initialiseDoubleValues(this.leafNodeSize);
+                    .initialiseValues(this.leafNodeSize);
         }
         for(int i = 0;i < customMeasureIndex.length;i++)
         {
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/SingleThreadFinalMerger.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/SingleThreadFinalMerger.java
index 0ebf097..04e3467 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/SingleThreadFinalMerger.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/SingleThreadFinalMerger.java
@@ -114,14 +114,10 @@ public class SingleThreadFinalMerger
     private char[] type;
     
     private String[] aggregators;
-    /**
-     * highCardCount
-     */
-    private int highCardCount;
     
     public SingleThreadFinalMerger(String tempFileLocation, String tableName,
             int mdkeyLength, int measureCount, int mdKeyIndex,boolean isFactMdkeyInInputRow,
-            int factMdkeyLength,char[] type, String[] aggregators, int highCardCount)
+            int factMdkeyLength,char[] type, String[] aggregators)
     {
         this.tempFileLocation = tempFileLocation;
         this.tableName = tableName;
@@ -132,7 +128,6 @@ public class SingleThreadFinalMerger
         this.factMdkeyLength=factMdkeyLength;
         this.type=type;
         this.aggregators = aggregators;
-        this.highCardCount = highCardCount;
     }
     
     /**
@@ -212,7 +207,7 @@ public class SingleThreadFinalMerger
                     // create chunk holder
                     MolapSortTempFileChunkHolder molapSortTempFileChunkHolder = new MolapSortTempFileChunkHolder(
                             tmpFile, measureCount, mdkeyLength,
-                            fileBufferSize,isFactMdkeyInInputRow,factMdkeyLength, aggregators,highCardCount);
+                            fileBufferSize,isFactMdkeyInInputRow,factMdkeyLength, aggregators, type);
                   //CHECKSTYLE:ON
                     // initialize
                     molapSortTempFileChunkHolder.initialize();
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/SingleThreadFinalSortFilesMerger.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/SingleThreadFinalSortFilesMerger.java
index f790c05..2b801b4 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/SingleThreadFinalSortFilesMerger.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/SingleThreadFinalSortFilesMerger.java
@@ -30,7 +30,6 @@ import com.huawei.unibi.molap.store.writer.exception.MolapDataWriterException;
 import com.huawei.unibi.molap.util.MolapDataProcessorLogEvent;
 import com.huawei.unibi.molap.util.MolapDataProcessorUtil;
 import com.huawei.unibi.molap.util.MolapProperties;
-import com.huawei.unibi.molap.util.RemoveDictionaryUtil;
 
 /**
  * Project Name 	: Carbon 
@@ -80,35 +79,26 @@ public class SingleThreadFinalSortFilesMerger
     private int measureCount;
     
     /**
-     * dimensionCount
-     */
-    private int dimensionCount;
-    
-    /**
      * measure count
      */
-    private int highCardinalityCount;
-    
-    /**
-     * complexDimensionCount
-     */
-    private int complexDimensionCount;
+    private int dimensionCount;
     
     /**
      * tempFileLocation
      */
     private String tempFileLocation;
     
+    private char[] aggType;
+    
     
     public SingleThreadFinalSortFilesMerger(String tempFileLocation, String tableName,
-            int dimensionCount, int complexDimensionCount, int measureCount, int highCardinalityCount)
+            int dimensionCount, int measureCount, char[] aggType)
     {
         this.tempFileLocation = tempFileLocation;
         this.tableName = tableName;
         this.dimensionCount = dimensionCount;
-        this.complexDimensionCount = complexDimensionCount;
         this.measureCount = measureCount;
-        this.highCardinalityCount = highCardinalityCount;
+        this.aggType = aggType;
     }
     
     /**
@@ -191,7 +181,7 @@ public class SingleThreadFinalSortFilesMerger
                 {
                     // create chunk holder
                 	SortTempFileChunkHolder sortTempFileChunkHolder = new SortTempFileChunkHolder(
-                            tempFile, dimensionCount, complexDimensionCount, measureCount, fileBufferSize,highCardinalityCount);
+                            tempFile, dimensionCount, measureCount, fileBufferSize, aggType);
                     
                 	// initialize
                 	sortTempFileChunkHolder.initialize();
@@ -247,8 +237,8 @@ public class SingleThreadFinalSortFilesMerger
 
                         for(int i = 0; i < dimensionCount; i++)
                         {
-                            int dimFieldA = (Integer)RemoveDictionaryUtil.getDimension(i, rowA);
-                            int dimFieldB = (Integer)RemoveDictionaryUtil.getDimension(i, rowB);
+                            int dimFieldA = (Integer)rowA[i];
+                            int dimFieldB = (Integer)rowB[i];
                             
                             diff = dimFieldA - dimFieldB;
                             if(diff != 0)
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/writer/AbstractFactDataWriter.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/writer/AbstractFactDataWriter.java
index 8d558d3..2f63d2e 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/writer/AbstractFactDataWriter.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/writer/AbstractFactDataWriter.java
@@ -111,16 +111,6 @@ public abstract class AbstractFactDataWriter<T> implements MolapFactDataWriter<T
      */
     protected int[] keyBlockSize;
     
-    protected boolean[] isNoDictionary;
-    
-    /**
-     * @param isNoDictionary the isNoDictionary to set
-     */
-    public void setIsNoDictionary(boolean[] isNoDictionary)
-    {
-        this.isNoDictionary = isNoDictionary;
-    }
-
     /**
      * mdkeySize
      */
@@ -160,7 +150,10 @@ public abstract class AbstractFactDataWriter<T> implements MolapFactDataWriter<T
                 *1L;
       //CHECKSTYLE:OFF    Approval No:Approval-323
         this.isNodeHolderRequired = Boolean
-                .valueOf(MolapCommonConstants.WRITE_ALL_NODE_IN_SINGLE_TIME_DEFAULT_VALUE);
+                .valueOf(propInstance
+                        .getProperty(
+                                MolapCommonConstants.WRITE_ALL_NODE_IN_SINGLE_TIME,
+                                MolapCommonConstants.WRITE_ALL_NODE_IN_SINGLE_TIME_DEFAULT_VALUE));
         this.fileManager=fileManager;	
     
         /**
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/writer/MolapDataWriter.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/writer/MolapDataWriter.java
index 4c59c2b..8bbb345 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/writer/MolapDataWriter.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/writer/MolapDataWriter.java
@@ -183,7 +183,10 @@ public class MolapDataWriter
                 *1L;
       //CHECKSTYLE:OFF    Approval No:Approval-323
         this.isNodeHolderRequired = Boolean
-                .valueOf(MolapCommonConstants.WRITE_ALL_NODE_IN_SINGLE_TIME_DEFAULT_VALUE);
+                .valueOf(instance
+                        .getProperty(
+                                MolapCommonConstants.WRITE_ALL_NODE_IN_SINGLE_TIME,
+                                MolapCommonConstants.WRITE_ALL_NODE_IN_SINGLE_TIME_DEFAULT_VALUE));
       //CHECKSTYLE:ON
         
         this.isNodeHolderRequired = this.isNodeHolderRequired && isNodeHolder;
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/writer/MolapFactDataWriter.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/writer/MolapFactDataWriter.java
index d50e596..32bce10 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/writer/MolapFactDataWriter.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/writer/MolapFactDataWriter.java
@@ -59,11 +59,5 @@ public interface MolapFactDataWriter<T>
 	 * @return
 	 */
 	String getTempStoreLocation();
-	
-	/**
-	 * 
-	 * @param isNoDictionary
-	 */
-	void setIsNoDictionary(boolean[] isNoDictionary);
 
 }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/writer/MolapFactDataWriterImplForIntIndexAndAggBlock.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/writer/MolapFactDataWriterImplForIntIndexAndAggBlock.java
index 160f969..67935f0 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/writer/MolapFactDataWriterImplForIntIndexAndAggBlock.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/store/writer/MolapFactDataWriterImplForIntIndexAndAggBlock.java
@@ -21,22 +21,11 @@ public class MolapFactDataWriterImplForIntIndexAndAggBlock extends AbstractFactD
 {
     private NumberCompressor numberCompressor;
     
-    private boolean[] isComplexType;
-    
     protected boolean[] aggBlocks;
     
     private static final LogService LOGGER = LogServiceFactory
           .getLogService(MolapFactDataWriterImplForIntIndexAndAggBlock.class.getName());
 
-    public MolapFactDataWriterImplForIntIndexAndAggBlock(String storeLocation, int measureCount,
-            int mdKeyLength, String tableName, boolean isNodeHolder,
-            IFileManagerComposite fileManager, int[] keyBlockSize, 
-            boolean[] aggBlocks, boolean isUpdateFact, boolean[] isComplexType)
-    {
-    	this(storeLocation, measureCount, mdKeyLength, tableName, 
-    			isNodeHolder,fileManager, keyBlockSize, aggBlocks, isUpdateFact);
-    	this.isComplexType = isComplexType;
-    }
     
     public MolapFactDataWriterImplForIntIndexAndAggBlock(String storeLocation, int measureCount,
             int mdKeyLength, String tableName, boolean isNodeHolder,IFileManagerComposite fileManager, int[] keyBlockSize, boolean[] aggBlocks, boolean isUpdateFact)
@@ -81,25 +70,12 @@ public class MolapFactDataWriterImplForIntIndexAndAggBlock extends AbstractFactD
                 
             }
             totalKeySize+=keyLengths[i];
-            
-            if(isNoDictionary[i])
-            {
-                columnMinMaxData[i]=new byte[keyStorageArray[i].getKeyBlock()[0].length + keyStorageArray[i].getKeyBlock()[keyStorageArray[i].getKeyBlock().length-1].length ];
-                
-                byte[] minVal=keyStorageArray[i].getKeyBlock()[0];
-                byte[] maxVal=keyStorageArray[i].getKeyBlock()[keyStorageArray[i].getKeyBlock().length-1];
-                System.arraycopy(minVal, 0, columnMinMaxData[i], 0, minVal.length);
-                System.arraycopy(maxVal, 0, columnMinMaxData[i],minVal.length, maxVal.length);
-            }
-            else
-            {
             //for column min max value
             columnMinMaxData[i]=new byte[this.keyBlockSize[i]*2];
         	byte[] minVal=keyStorageArray[i].getKeyBlock()[0];
         	byte[] maxVal=keyStorageArray[i].getKeyBlock()[keyStorageArray[i].getKeyBlock().length-1];
         	System.arraycopy(minVal, 0, columnMinMaxData[i], 0, this.keyBlockSize[i]);
         	System.arraycopy(maxVal, 0, columnMinMaxData[i], this.keyBlockSize[i], this.keyBlockSize[i]);
-            }
         }
         int[] keyBlockIdxLengths= new int[keyBlockSize];
         byte[][] dataAfterCompression= new byte[keyBlockSize][];
@@ -219,55 +195,22 @@ public class MolapFactDataWriterImplForIntIndexAndAggBlock extends AbstractFactD
         for(int i =0;i<keyStorageArray.length;i++)
         {
             destPos=0;
-            //handling for high card dims
-            if(i >= keyBlockSize.length && !isComplexType[i])
+            if(aggBlocks[i])
             {
-                int totalLength = 0;
-                // calc size of the total bytes in all the colmns.
-                for(int k = 0 ; k < keyStorageArray[i].getKeyBlock().length ;k++ )
+                keyBlockData[i]= new byte[keyStorageArray[i].getTotalSize()];
+                for(int j=0;j<keyStorageArray[i].getKeyBlock().length;j++)
                 {
-                    byte [] colValue = keyStorageArray[i].getKeyBlock()[k];
-                    totalLength+= colValue.length;
-                }
-                keyBlockData[i] = new byte[totalLength];
-                
-                for(int j = 0;j < keyStorageArray[i].getKeyBlock().length;j++)
-                {
-                    int length = keyStorageArray[i].getKeyBlock()[j].length;
-                    System.arraycopy(keyStorageArray[i].getKeyBlock()[j], 0,
-                            keyBlockData[i], destPos,length);
-                    destPos += length;
+                    System.arraycopy(keyStorageArray[i].getKeyBlock()[j], 0, keyBlockData[i], destPos, keyStorageArray[i].getKeyBlock()[j].length);
+                    destPos+=keyStorageArray[i].getKeyBlock()[j].length;
                 }
             }
             else
             {
-            	if(aggBlocks[i])
-                {
-                    keyBlockData[i] = new byte[keyStorageArray[i]
-                            .getTotalSize()];
-                    for(int j = 0;j < keyStorageArray[i].getKeyBlock().length;j++)
-                    {
-                        System.arraycopy(keyStorageArray[i].getKeyBlock()[j],
-                                0, keyBlockData[i], destPos,
-                                keyStorageArray[i].getKeyBlock()[j].length);
-                        destPos += keyStorageArray[i].getKeyBlock()[j].length;
-                    }
-                }
-                else
+                keyBlockData[i]= new byte[entryCount* keyBlockSize[i]];
+                for(int j=0;j<keyStorageArray[i].getKeyBlock().length;j++)
                 {
-                	if(isComplexType[i])
-	            	{
-	            		keyBlockData[i]= new byte[keyStorageArray[i].getKeyBlock().length* keyBlockSize[i]];
-	            	}
-	            	else
-	            	{
-	            		keyBlockData[i]= new byte[entryCount* keyBlockSize[i]];
-	            	}
-	                for(int j=0;j<keyStorageArray[i].getKeyBlock().length;j++)
-	                {
-	                    System.arraycopy(keyStorageArray[i].getKeyBlock()[j], 0, keyBlockData[i], destPos, keyBlockSize[i]);
-	                    destPos+=keyBlockSize[i];
-	                }
+                    System.arraycopy(keyStorageArray[i].getKeyBlock()[j], 0, keyBlockData[i], destPos, keyBlockSize[i]);
+                    destPos+=keyBlockSize[i];
                 }
             }
             keyBlockData[i]=SnappyByteCompression.INSTANCE.compress(keyBlockData[i]);
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/surrogatekeysgenerator/csvbased/MolapCSVBasedDimSurrogateKeyGen.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/surrogatekeysgenerator/csvbased/MolapCSVBasedDimSurrogateKeyGen.java
index d99a45c..cd9efa1 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/surrogatekeysgenerator/csvbased/MolapCSVBasedDimSurrogateKeyGen.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/surrogatekeysgenerator/csvbased/MolapCSVBasedDimSurrogateKeyGen.java
@@ -23,10 +23,8 @@ import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import java.io.File;
 import java.io.OutputStream;
 import java.sql.Connection;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
@@ -35,7 +33,6 @@ import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 import org.pentaho.di.core.exception.KettleException;
 
-import com.huawei.datasight.molap.datatypes.GenericDataType;
 import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
@@ -698,35 +695,14 @@ public abstract class MolapCSVBasedDimSurrogateKeyGen
     
     private void setDimensionTables(String[] dimeFileNames)
     {
-//        this.dimsFiles = dimeFileNames;
-//        max = new int[dimeFileNames.length];
-        int noOfPrimitiveDims = 0;
-        List<String> dimFilesForPrimitives = new ArrayList<String>();
+        this.dimsFiles = dimeFileNames;
+        max = new int[dimeFileNames.length];
+
         memberCache = new ConcurrentHashMap<String, Map<String, Integer>>();
         for(int i = 0;i < dimeFileNames.length;i++)
         {
-        	GenericDataType complexType = molapInfo.getComplexTypesMap().get(dimeFileNames[i].substring(molapInfo.getTableName().length() + 1));
-        	if(complexType != null)
-        	{
-        		List<GenericDataType> primitiveChild = new ArrayList<GenericDataType>();
-        		complexType.getAllPrimitiveChildren(primitiveChild);
-        		for(GenericDataType eachPrimitive: primitiveChild)
-        		{
-        			memberCache.put(molapInfo.getTableName()+"_"+eachPrimitive.getName(), new ConcurrentHashMap<String, Integer>());
-        			dimFilesForPrimitives.add(molapInfo.getTableName()+"_"+eachPrimitive.getName());
-        			eachPrimitive.setSurrogateIndex(noOfPrimitiveDims);
-        			noOfPrimitiveDims++;
-        		}
-        	}
-        	else
-        	{
-        		memberCache.put(dimeFileNames[i], new ConcurrentHashMap<String, Integer>());
-        		dimFilesForPrimitives.add(dimeFileNames[i]);
-        		noOfPrimitiveDims++;
-        	}
+            memberCache.put(dimeFileNames[i], new ConcurrentHashMap<String, Integer>());
         }
-        max = new int[noOfPrimitiveDims];
-        this.dimsFiles = dimFilesForPrimitives.toArray(new String[dimFilesForPrimitives.size()]);
 
        // checkDimTableCreated();
         createRespectiveDimFilesForDimTables();
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/surrogatekeysgenerator/csvbased/MolapCSVBasedSeqGenMeta.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/surrogatekeysgenerator/csvbased/MolapCSVBasedSeqGenMeta.java
index 0bf8c60..2f89a17 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/surrogatekeysgenerator/csvbased/MolapCSVBasedSeqGenMeta.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/surrogatekeysgenerator/csvbased/MolapCSVBasedSeqGenMeta.java
@@ -22,7 +22,6 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Iterator;
-import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -48,10 +47,6 @@ import org.pentaho.di.trans.step.StepMeta;
 import org.pentaho.di.trans.step.StepMetaInterface;
 import org.w3c.dom.Node;
 
-import com.huawei.datasight.molap.datatypes.ArrayDataType;
-import com.huawei.datasight.molap.datatypes.GenericDataType;
-import com.huawei.datasight.molap.datatypes.PrimitiveDataType;
-import com.huawei.datasight.molap.datatypes.StructDataType;
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.schema.metadata.HierarchiesInfo;
 import com.huawei.unibi.molap.util.MolapDataProcessorUtil;
@@ -110,7 +105,6 @@ public class MolapCSVBasedSeqGenMeta extends BaseStepMeta implements StepMetaInt
      * molapTime
      */
     private String molapTime;
-    private String  highCardinalityDims;
 
 //    /**
 //     * storeLocation
@@ -193,56 +187,13 @@ public class MolapCSVBasedSeqGenMeta extends BaseStepMeta implements StepMetaInt
      * checkPointFileExits
      */
     private String checkPointFileExits;
-    
-    private String complexDelimiterLevel1;
-    
-	private String complexDelimiterLevel2;
 
     /**
      * dims
      */
     protected int[] dims;
- 
-    /**
-     * dims
-     */
-    protected Map<String, GenericDataType> complexTypes = new HashMap<String, GenericDataType>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
-    
-    private String complexTypeString;
-
-    public Map<String, GenericDataType> getComplexTypes() {
-		return complexTypes;
-	}
-
-	public void setComplexTypes(Map<String, GenericDataType> complexTypes) {
-		this.complexTypes = complexTypes;
-	}
-	
-	public String getComplexDelimiterLevel1() {
-		return complexDelimiterLevel1;
-	}
-
-	public void setComplexDelimiterLevel1(String complexDelimiterLevel1) {
-		this.complexDelimiterLevel1 = complexDelimiterLevel1;
-	}
-
-	public String getComplexDelimiterLevel2() {
-		return complexDelimiterLevel2;
-	}
-
-	public void setComplexDelimiterLevel2(String complexDelimiterLevel2) {
-		this.complexDelimiterLevel2 = complexDelimiterLevel2;
-	}
-	
-	public String getComplexTypeString() {
-		return complexTypeString;
-	}
-
-	public void setComplexTypeString(String complexTypeString) {
-		this.complexTypeString = complexTypeString;
-	}
 
-	/**
+    /**
      * dimLens
      */
     protected int[] dimLens;
@@ -321,11 +272,6 @@ public class MolapCSVBasedSeqGenMeta extends BaseStepMeta implements StepMetaInt
      * dimColNames
      */
     protected String[] dimColNames;
-    
-    /**
-     * 
-     */
-    protected String[] highCardCols;
 
     /**
      * propColumns
@@ -733,13 +679,9 @@ public class MolapCSVBasedSeqGenMeta extends BaseStepMeta implements StepMetaInt
         metaHeirSQLQuery="";
         molapMetaHier="";
         dimesionTableNames="";
-        highCardinalityDims="";
         tableName="";
         molaphierColumn="";
         foreignKeyHierarchyString="";
-        complexTypeString="";
-        complexDelimiterLevel1 = "";
-        complexDelimiterLevel2 = "";
         primaryKeysString="";
         molapMeasureNames = "";
         actualDimNames = "";
@@ -798,9 +740,6 @@ public class MolapCSVBasedSeqGenMeta extends BaseStepMeta implements StepMetaInt
         retval.append("    ").append(XMLHandler.addTagValue("metadataFilePath", metaHeirSQLQuery));
         retval.append("    ").append(XMLHandler.addTagValue("molapMetaHier", molapMetaHier));
         retval.append("    ").append(XMLHandler.addTagValue("foreignKeyHierarchyString", foreignKeyHierarchyString));
-        retval.append("    ").append(XMLHandler.addTagValue("complexTypeString", complexTypeString));
-        retval.append("    ").append(XMLHandler.addTagValue("complexDelimiterLevel1", complexDelimiterLevel1));
-        retval.append("    ").append(XMLHandler.addTagValue("complexDelimiterLevel2", complexDelimiterLevel2));
         retval.append("    ").append(XMLHandler.addTagValue("primaryKeysString", primaryKeysString));
         retval.append("    ").append(XMLHandler.addTagValue("molapMeasureNames", molapMeasureNames));
         retval.append("    ").append(XMLHandler.addTagValue("actualDimNames", actualDimNames));
@@ -808,7 +747,6 @@ public class MolapCSVBasedSeqGenMeta extends BaseStepMeta implements StepMetaInt
         
         
         retval.append("    ").append(XMLHandler.addTagValue("dimHierReleation", dimesionTableNames));
-        retval.append("    ").append(XMLHandler.addTagValue("dimHighCardinality", highCardinalityDims));
         retval.append("    ").append(XMLHandler.addTagValue("factOrAggTable", tableName));
         retval.append("    ").append(XMLHandler.addTagValue("molaphierColumn", molaphierColumn));
         retval.append("    ").append(XMLHandler.addTagValue("normHiers", normHiers));
@@ -848,9 +786,6 @@ public class MolapCSVBasedSeqGenMeta extends BaseStepMeta implements StepMetaInt
             molapMetaHier = XMLHandler.getTagValue(stepnode, "molapMetaHier");
             molaphierColumn = XMLHandler.getTagValue(stepnode, "molaphierColumn");
             foreignKeyHierarchyString = XMLHandler.getTagValue(stepnode, "foreignKeyHierarchyString");
-            complexTypeString = XMLHandler.getTagValue(stepnode, "complexTypeString");
-            complexDelimiterLevel1 = XMLHandler.getTagValue(stepnode, "complexDelimiterLevel1");
-            complexDelimiterLevel2 = XMLHandler.getTagValue(stepnode, "complexDelimiterLevel2");
             primaryKeysString = XMLHandler.getTagValue(stepnode, "primaryKeysString");
             molapMeasureNames = XMLHandler.getTagValue(stepnode, "molapMeasureNames");
             actualDimNames = XMLHandler.getTagValue(stepnode, "actualDimNames");
@@ -862,7 +797,6 @@ public class MolapCSVBasedSeqGenMeta extends BaseStepMeta implements StepMetaInt
             measureDataType = XMLHandler.getTagValue(stepnode, "measureDataType");
             columnAndTableNameColumnMapForAggString=XMLHandler.getTagValue(stepnode, "columnAndTableName_ColumnMapForAggString");
             dimesionTableNames = XMLHandler.getTagValue(stepnode, "dimHierReleation");
-            highCardinalityDims=XMLHandler.getTagValue(stepnode, "dimHighCardinality");
             tableName = XMLHandler.getTagValue(stepnode, "factOrAggTable");
 			cubeName = XMLHandler.getTagValue(stepnode, "cubeName");
             schemaName = XMLHandler.getTagValue(stepnode, "schemaName");
@@ -901,18 +835,14 @@ public class MolapCSVBasedSeqGenMeta extends BaseStepMeta implements StepMetaInt
     
     public void initialize() throws KettleException
     {
-        if(null != complexTypeString)
-        {
-            complexTypes = getComplexTypesMap(complexTypeString);
-        }
-        updateDimensions(molapdim,molapmsr,highCardinalityDims);
+        
+        updateDimensions(molapdim,molapmsr);
         
         hirches = getHierarichies(molaphier);
 
         hierColumnMap = getHierarchiesColumnMap(molaphierColumn);
         
         foreignKeyHierarchyMap = getForeignKeyHierMap(foreignKeyHierarchyString);
-
         
         primaryKeyMap = updatePrimaryKeyMap(primaryKeysString);
         
@@ -1019,21 +949,22 @@ public class MolapCSVBasedSeqGenMeta extends BaseStepMeta implements StepMetaInt
      */
     private Map<String, Boolean> getMeasureDatatypeMap(String measureDataType)
     {
-        if(measureDataType == null
-                || "".equals(measureDataType))
-        {
-            return new HashMap<String, Boolean>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
-        }
-        Map<String, Boolean> resultMap = new HashMap<String, Boolean>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
-
-        String[] measures = measureDataType.split(MolapCommonConstants.AMPERSAND_SPC_CHARACTER);
-
-        for(int i = 0;i < measures.length;i++)
-        {
-            String[] measureValue = measures[i].split(MolapCommonConstants.COLON_SPC_CHARACTER);
-            resultMap.put(measureValue[0], Boolean.valueOf(measureValue[1]));
-        }
-        return resultMap;
+        return new HashMap<String, Boolean>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
+//        if(measureDataType == null
+//                || "".equals(measureDataType))
+//        {
+//            return new HashMap<String, Boolean>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
+//        }
+//        Map<String, Boolean> resultMap = new HashMap<String, Boolean>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
+//
+//        String[] measures = measureDataType.split(MolapCommonConstants.AMPERSAND_SPC_CHARACTER);
+//
+//        for(int i = 0;i < measures.length;i++)
+//        {
+//            String[] measureValue = measures[i].split(MolapCommonConstants.COLON_SPC_CHARACTER);
+//            resultMap.put(measureValue[0], Boolean.valueOf(measureValue[1]));
+//        }
+//        return resultMap;
     }
 
     /**
@@ -1171,36 +1102,6 @@ public class MolapCSVBasedSeqGenMeta extends BaseStepMeta implements StepMetaInt
         hierNames = actualHierList.toArray(new String[actualHierList.size()]);
     }
 
-    
-    private Map<String,GenericDataType> getComplexTypesMap(String complexTypeString)
-    {
-    	Map<String,GenericDataType> complexTypesMap = new LinkedHashMap<String,GenericDataType>();
-    	String[] hierarchies = complexTypeString.split(MolapCommonConstants.SEMICOLON_SPC_CHARACTER);
-        for(int i = 0;i < hierarchies.length;i++)
-        {
-            String[] levels = hierarchies[i].split(MolapCommonConstants.HASH_SPC_CHARACTER);
-            String[] levelInfo = levels[0].split(MolapCommonConstants.COLON_SPC_CHARACTER);
-			GenericDataType g = levelInfo[1].equals("Array")?
-						new ArrayDataType(levelInfo[0], ""):new StructDataType(levelInfo[0], "");
-			complexTypesMap.put(levelInfo[0], g);
-            for(int j = 1;j < levels.length;j++)
-            {
-            	levelInfo = levels[j].split(MolapCommonConstants.COLON_SPC_CHARACTER);
-				switch(levelInfo[1])
-				{
-					case "Array" : 
-						g.addChildren(new ArrayDataType(levelInfo[0], levelInfo[2]));
-						break;
-					case "Struct" : 
-						g.addChildren(new StructDataType(levelInfo[0], levelInfo[2]));
-						break;
-					default :
-						g.addChildren(new PrimitiveDataType(levelInfo[0], levelInfo[2]));
-				}
-            }
-        }
-        return complexTypesMap;
-    }
     /**
      * 
      * @param foreignKeyHierarchyString2
@@ -1503,17 +1404,9 @@ public class MolapCSVBasedSeqGenMeta extends BaseStepMeta implements StepMetaInt
     }
     
 
-    private void updateDimensions(String ds,String msr,String highCardinalityDims)
+    private void updateDimensions(String ds,String msr)
     {
-        String [] sp = null;
-        if(null != ds)
-        {
-            sp = ds.split(MolapCommonConstants.COMA_SPC_CHARACTER);
-        }
-        else
-        {
-            sp = new String[0];
-        }
+        String [] sp = ds.split(MolapCommonConstants.COMA_SPC_CHARACTER);
         int[] dimsLocal = new int[sp.length];
         int[] lens = new int[sp.length];
         List<String> list = new ArrayList<String>(MolapCommonConstants.CONSTANT_SIZE_TEN);
@@ -1536,27 +1429,7 @@ public class MolapCSVBasedSeqGenMeta extends BaseStepMeta implements StepMetaInt
         dimLens = lens;
 //      columns.put(DIMENSIONS, list);
         dimColNames = list.toArray(new String[list.size()]);
-        highCardCols= new String[0];
-        //for high card dims
-        if(null != highCardinalityDims)
-        {
-            String[] highCard = highCardinalityDims
-                    .split(MolapCommonConstants.COMA_SPC_CHARACTER);
-            int[] highCardDimsLocal = new int[highCard.length];
-            List<String> list1 = new ArrayList<String>(
-                    MolapCommonConstants.CONSTANT_SIZE_TEN);
-
-            for(int i = 0;i < highCardDimsLocal.length;i++)
-            {
-                String[] dim = highCard[i]
-                        .split(MolapCommonConstants.COLON_SPC_CHARACTER);
-                list1.add(dim[0]);
-                highCardDimsLocal[i] = Integer.parseInt(dim[1]);
-                Integer.parseInt(dim[2]);
-
-            }
-            highCardCols = list1.toArray(new String[list1.size()]);
-        }
+        
         String [] sm = msr.split(MolapCommonConstants.COMA_SPC_CHARACTER);
         int[] m = new int[sm.length];
         Set<String> mlist = new LinkedHashSet<String>();
@@ -1600,7 +1473,6 @@ public class MolapCSVBasedSeqGenMeta extends BaseStepMeta implements StepMetaInt
             msrAggregatorString =  rep.getStepAttributeString(idStep, "msrAggregatorString");
             
             dimesionTableNames = rep.getStepAttributeString(idStep, "dimHierReleation");
-            highCardinalityDims=rep.getStepAttributeString(idStep, "dimHighCardinality");
             normHiers = rep.getStepAttributeString(idStep, "normHiers");
             tableName = rep.getStepAttributeString(idStep, "factOrAggTable");
             batchSize = Integer.parseInt(rep.getStepAttributeString(idStep,
@@ -1651,7 +1523,6 @@ public class MolapCSVBasedSeqGenMeta extends BaseStepMeta implements StepMetaInt
             rep.saveStepAttribute(idTransformation, idStep, "molapMetaHier", molapMetaHier);
             rep.saveStepAttribute(idTransformation, idStep, "batchSize", batchSize);
             rep.saveStepAttribute(idTransformation, idStep, "dimHierReleation", dimesionTableNames);
-            rep.saveStepAttribute(idTransformation, idStep, "dimHighCardinality", highCardinalityDims);
 //            rep.saveStepAttribute(id_transformation, id_step, "primaryKeyColumnNamesString", primaryKeyColumnNamesString);
             rep.saveStepAttribute(idTransformation, idStep, "foreignKeyHierarchyString", foreignKeyHierarchyString);
             rep.saveStepAttribute(idTransformation, idStep, "primaryKeysString", primaryKeysString);
@@ -2153,20 +2024,5 @@ public class MolapCSVBasedSeqGenMeta extends BaseStepMeta implements StepMetaInt
     {
         this.currentRestructNumber = currentRestructNum;
     }
-    /**
-     * 
-     * @return
-     */
-    public String  getHighCardinalityDims() {
-		return highCardinalityDims;
-	}
-
-    /**
-     * 
-     * @param highCardinalityDims
-     */
-	public void setHighCardinalityDims(String highCardinalityDims) {
-		this.highCardinalityDims = highCardinalityDims;
-	}
 }
 
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/surrogatekeysgenerator/csvbased/MolapCSVBasedSeqGenStep.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/surrogatekeysgenerator/csvbased/MolapCSVBasedSeqGenStep.java
index 572cbaf..d9deb10 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/surrogatekeysgenerator/csvbased/MolapCSVBasedSeqGenStep.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/surrogatekeysgenerator/csvbased/MolapCSVBasedSeqGenStep.java
@@ -19,14 +19,10 @@ package com.huawei.unibi.molap.surrogatekeysgenerator.csvbased;
 
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
-import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
-import java.nio.charset.Charset;
 import java.sql.Connection;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -60,7 +56,6 @@ import org.pentaho.di.trans.step.StepDataInterface;
 import org.pentaho.di.trans.step.StepMeta;
 import org.pentaho.di.trans.step.StepMetaInterface;
 
-import com.huawei.datasight.molap.datatypes.GenericDataType;
 import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
 import com.huawei.iweb.platform.logging.impl.StandardLogService;
@@ -88,12 +83,12 @@ import com.huawei.unibi.molap.schema.metadata.MolapInfo;
 import com.huawei.unibi.molap.sortandgroupby.exception.MolapSortKeyAndGroupByException;
 import com.huawei.unibi.molap.surrogatekeysgenerator.lru.LRUCache;
 import com.huawei.unibi.molap.surrogatekeysgenerator.lru.MolapSeqGenCacheHolder;
+import com.huawei.unibi.molap.util.DataTypeUtil;
 import com.huawei.unibi.molap.util.MolapDataProcessorLogEvent;
 import com.huawei.unibi.molap.util.MolapDataProcessorUtil;
 import com.huawei.unibi.molap.util.MolapProperties;
 import com.huawei.unibi.molap.util.MolapUtil;
 import com.huawei.unibi.molap.util.MolapVersion;
-import com.huawei.unibi.molap.util.RemoveDictionaryUtil;
 import com.huawei.unibi.molap.writer.ByteArrayHolder;
 import com.huawei.unibi.molap.writer.HierarchyValueWriterForCSV;
 
@@ -355,6 +350,8 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
     
     private int processed;
     
+    private String[] msrDataType;
+    
 //    private static boolean isDone = false;
     
     static 
@@ -455,7 +452,9 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
 //                updateNullValueComparer();
                 
                 
-                logCounter = Integer.parseInt(MolapCommonConstants.DATA_LOAD_LOG_COUNTER_DEFAULT_COUNTER);
+                logCounter = Integer.parseInt(MolapProperties.getInstance().getProperty(
+                        MolapCommonConstants.DATA_LOAD_LOG_COUNTER,
+                        MolapCommonConstants.DATA_LOAD_LOG_COUNTER_DEFAULT_COUNTER));
                 if(null != getInputRowMeta())
                     {
                         meta.updateHierMappings(getInputRowMeta());
@@ -481,7 +480,12 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
                         measureSurrogateReqMapping = createMeasureSurrogateReqMapping();
                         createForeignKeyMappingColumns();
                         metaColumnNames = createColumnArrayFromMeta();
-    
+                        String msrDatatypes = meta.getMeasureDataType();
+                        if(msrDatatypes.length() > 0)
+                        {
+                            msrDataType = msrDatatypes
+                                    .split(MolapCommonConstants.AMPERSAND_SPC_CHARACTER);
+                        }
                     }
     
                 if(!meta.isAggregate())
@@ -520,7 +524,6 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
                 molapInfo.setTableName(meta.getTableName());
                 molapInfo.setPrimaryKeyMap(meta.getPrimaryKeyMap());
                 molapInfo.setMeasureColumns(meta.measureColumn);
-                molapInfo.setComplexTypesMap(meta.getComplexTypes());
                 
                 updateBagLogFileName();
                 String key = meta.getSchemaName() +'/' +meta.getCubeName()+'_'+meta.getTableName();
@@ -613,25 +616,10 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
                	MolapCSVBasedDimSurrogateKeyGen surrogateKeyGenObj = data.getSurrogateKeyGen();
                	if(null != surrogateKeyGenObj)
                	{
-               		int index=0;
                		for(int j=0; j<meta.dimColNames.length;j++)
                		{
-               			GenericDataType complexType = molapInfo.getComplexTypesMap().get(meta.dimColNames[j].substring(meta.getTableName().length() + 1));
-                    	if(complexType != null)
-                    	{
-                    		List<GenericDataType> primitiveChild = new ArrayList<GenericDataType>();
-                    		complexType.getAllPrimitiveChildren(primitiveChild);
-                    		for(GenericDataType eachPrimitive: primitiveChild)
-                    		{
-                    			surrogateKeyGenObj.generateSurrogateKeys(MolapCommonConstants.MEMBER_DEFAULT_VAL, meta.getTableName()+"_"+eachPrimitive.getName(), index, new Object[0]);
-                    			index++;
-                    		}
-                    	}
-                    	else
-                    	{
-                    		surrogateKeyGenObj.generateSurrogateKeys(MolapCommonConstants.MEMBER_DEFAULT_VAL, meta.dimColNames[j], index, new Object[0]);
-                    		index++;
-                    	}
+               			
+               			surrogateKeyGenObj.generateSurrogateKeys(MolapCommonConstants.MEMBER_DEFAULT_VAL, meta.dimColNames[j], j, new Object[0]);
                		}
                	}
                }
@@ -689,8 +677,7 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
 //            }
 //        }
         updateAndWriteSliceMetadataFile();
-//        MolapUtil.writeLevelCardinalityFile(loadFolderLoc, meta.getTableName(), data.getSurrogateKeyGen().max);
-        MolapUtil.writeLevelCardinalityFile(loadFolderLoc, meta.getTableName(), getUpdatedCardinality(data.getSurrogateKeyGen().max));
+        MolapUtil.writeLevelCardinalityFile(loadFolderLoc, meta.getTableName(), data.getSurrogateKeyGen().max);
         writeDataFileVersion();
         badRecordslogger.closeStreams();
         if(!meta.isAggregate())
@@ -1238,18 +1225,10 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
         return integers;
     }
     
-    private String[] getUpdatedDims(String[] dims,String[] highCardCols,boolean[] presentDims)
+    private String[] getUpdatedDims(String[] dims,boolean[] presentDims)
     {
         int k=0;
-        String[] normDims = null;
-        if(null != meta.highCardCols)
-        {
-            normDims = new String[meta.normLength+meta.highCardCols.length];
-        }
-        else
-        {
-            normDims = new String[meta.normLength];
-        }
+        String[] normDims = new String[meta.normLength];
         for(int i = 0;i < dims.length;i++)
         {
             if(presentDims[i])
@@ -1258,13 +1237,6 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
                 k++;
             }//CHECKSTYLE:ON
         }
-        if( null != highCardCols)
-        {
-            for(int j = 0;j < highCardCols.length;j++)
-            {
-                normDims[k++] = highCardCols[j];
-            }
-        }
         return normDims;
     }
     
@@ -1287,7 +1259,7 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
 
         SliceMetaData sliceMetaData = new SliceMetaData();
         //
-        sliceMetaData.setDimensions(getUpdatedDims(meta.dimColNames,meta.highCardCols,meta.dimPresent));
+        sliceMetaData.setDimensions(getUpdatedDims(meta.dimColNames,meta.dimPresent));
         sliceMetaData.setActualDimensions(meta.dimColNames);
         sliceMetaData.setMeasures(meta.measureColumn);
         sliceMetaData.setActualDimLens(getUpdatedCardinality(meta.dimLens));
@@ -1295,7 +1267,6 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
         sliceMetaData.setMeasuresAggregator(meta.msrAggregators);
         sliceMetaData.setHeirAnKeySize(meta.getHeirKeySize());
         sliceMetaData.setTableNamesToLoadMandatory(null);
-        sliceMetaData.setComplexTypeString(meta.getComplexTypeString());
 //        int measureOrdinal =0;
 //        for(String agg : meta.msrAggregators)
 //        {
@@ -1345,32 +1316,11 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
     private int[] getUpdatedCardinality(int[] dimCardinality)
     {
     	int[] maxSurrogateKeyArray = data.getSurrogateKeyGen().max;
+    	int length = dimCardinality.length;
     	
-    	List<Integer> dimCardWithComplex = new ArrayList<Integer>();
-    	
-    	for(int i=0;i<meta.dimColNames.length;i++)
-    	{
-    		GenericDataType complexDataType = meta.complexTypes.get(meta.dimColNames[i].substring(meta.getTableName().length() + 1));
-    		if(complexDataType != null)
-    		{
-    			complexDataType.fillCardinalityAfterDataLoad(dimCardWithComplex, maxSurrogateKeyArray);
-    		}
-    		else
-    		{
-    			dimCardWithComplex.add(maxSurrogateKeyArray[i]);
-    		}
-    	}
+    	System.arraycopy(maxSurrogateKeyArray, 0, dimCardinality, 0, length);
     	
-//    	int length = dimCardinality.length;
-//    	System.arraycopy(maxSurrogateKeyArray, 0, dimCardinality, 0, length);
-//    	
-//    	return dimCardinality;
-    	int[] complexDimCardinality = new int[dimCardWithComplex.size()]; 
-    	for(int i=0;i<dimCardWithComplex.size();i++)
-    	{
-    		complexDimCardinality[i] = dimCardWithComplex.get(i);
-    	}
-    	return complexDimCardinality;
+    	return dimCardinality;
     }
     
 	/**
@@ -1924,9 +1874,9 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
                 
                 for (int i = 0; i < meta.normLength;i++)
                 {
-                    if (null == RemoveDictionaryUtil.getDimension(i, out))
+                    if (null == out[i])
                     {
-                        RemoveDictionaryUtil.setDimension(i,1,out);
+                        out[i] = 1;
                     }
                 }
             }
@@ -1993,7 +1943,7 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
 //        int[] dimMapping = meta.dimMapping;
         // Copy the dimension String values to output
         int [] memberMapping = meta.memberMapping;
-        int inputColumnsSize = metaColumnNames.length;
+        int inputRowSize = metaColumnNames.length;
         boolean isGenerated=false;
         int generatedSurrogate=-1;
         
@@ -2006,46 +1956,29 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
         
         if(null == r[1])
         {
-            badRecordslogger.addBadRecordsToBilder(r, inputColumnsSize,
+            badRecordslogger.addBadRecordsToBilder(r, inputRowSize,
                     "Column Names are coming NULL", "null");
             return null;
         }
         
-       
+       // TODO: - check to put objects based on datatype here (bigdecimal, long or double), can write a utility
         Map<String, Map<String, Integer>> allMemberCache = surrogateKeyGen.getMemberCache();
-		Object[] out = new Object[meta.normLength + meta.msrs.length + checkPoint.getCheckPointInfoFieldCount()];
-        int dimLen = meta.dims.length;        
+        Object[] out = new Object[meta.normLength + meta.msrs.length + checkPoint.getCheckPointInfoFieldCount()];
+        int dimLen = meta.dims.length;
 
-        Object[] newArray = new Object[MolapCommonConstants.ARRAYSIZE];
-
-        ByteBuffer[] byteBufferArr = null;
-        if(null != meta.highCardCols)
-        {
-            byteBufferArr = new ByteBuffer[meta.highCardCols.length + meta.complexTypes.size()];
-        }
         int i = 0;
         int n=0;
         int index = 0;
         int l = 0;
+        int msrCount = 0;
         boolean isNull=false;
       //CHECKSTYLE:OFF    Approval No:Approval-367
-        int complexIndex = meta.highCardCols.length;
-        for(int j = 0;j < inputColumnsSize;j++)
+        for(int j = 0;j < inputRowSize;j++)
         {
             String columnName = metaColumnNames[j];
             String foreignKeyColumnName = foreignKeyMappingColumns[j];
             
             
-            // TODO check if it is ignore dictionary dimension or not . if yes directly write byte buffer
-            
-          //  if(isDimentionHighCardinality)
-            if(null != meta.highCardCols && isDimensionHighCardinality(meta.highCardCols,columnName) && !measurePresentMapping[j])
-            {
-            	processhighCardinalityDim(getIndexOfHighCardDims(meta.highCardCols,columnName),(String)r[j],byteBufferArr);
-            	continue;
-            }
-            
-            
             // There is a possibility that measure can be referred as dimensions also 
             // so in that case we need to just copy the value into the measure column index.
             //if it enters here means 3 possibility 
@@ -2088,18 +2021,23 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
 
                     try
                     {
-                        out[memberMapping[dimLen + index]] = (isNull || msr == null || msr.length() == 0) ? null
-                                        : Double.valueOf(msr);
+                        out[memberMapping[dimLen + index]] = (isNull
+                                || msr == null || msr.length() == 0) ? null
+                                : DataTypeUtil
+                                        .getMeasureValueBasedOnDataType(msr,
+                                                msrDataType[msrCount]);
                     }
                     catch (NumberFormatException e) 
                     {
                     	try {
                         	msr = msr.replaceAll(",", "");
-                        	out[memberMapping[dimLen + index]] =  Double.valueOf(msr);
+                            out[memberMapping[dimLen + index]] = DataTypeUtil
+                                    .getMeasureValueBasedOnDataType(msr,
+                                            msrDataType[msrCount]);
                     	}
                     	catch(NumberFormatException ex)
                     	{
-                            badRecordslogger.addBadRecordsToBilder(r, inputColumnsSize,
+                            badRecordslogger.addBadRecordsToBilder(r, inputRowSize,
                                     "Measure should be number",valueToCheckAgainst);
                             return null;
                     	}
@@ -2107,6 +2045,7 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
                 }
                 
                 index++;
+                msrCount++;
                 if(presentColumnMapIndex[j] < 0 && null == foreignKeyColumnName)
                 {
                     continue;
@@ -2173,7 +2112,7 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
                             }
                             else
                             {
-                                addMemberNotExistEntry(r, inputColumnsSize, j,
+                                addMemberNotExistEntry(r, inputRowSize, j,
 										columnName);
                                 return null;
                             }
@@ -2184,7 +2123,7 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
                             // in bad records
                             if(null == surrogateKeyForHierarchy)
                             {
-                                addCardinalityExcededEntry(r, inputColumnsSize, j,
+                                addCardinalityExcededEntry(r, inputRowSize, j,
 										columnName);
                                 return null;
 
@@ -2229,140 +2168,111 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
             //If it refers to single hierarchy
             else
             {
-            	String complexDataTypeName = foreignKeyColumnName.substring(meta.getTableName().length() + 1);
-            	GenericDataType complexType = meta.getComplexTypes().get(complexDataTypeName);
-            	if(complexType != null)
-	            {
-            		try {
-            			ByteArrayOutputStream byteArray = new ByteArrayOutputStream();
-            			DataOutputStream dataOutputStream = new DataOutputStream(byteArray);
-//						complexType.parseStringAndWriteByteArray(meta.getTableName(), (String)r[j], new String[]{"\\$","\\:"}, 0, dataOutputStream, surrogateKeyGen);
-						complexType.parseStringAndWriteByteArray(meta.getTableName(), (String)r[j], 
-								new String[]{meta.getComplexDelimiterLevel1(),meta.getComplexDelimiterLevel2()}, 
-								0, dataOutputStream, surrogateKeyGen);
-//						out[memberMapping[i]] = byteArray.toByteArray();
-						byteBufferArr[complexIndex++] = ByteBuffer.wrap(byteArray.toByteArray());
-						if(null != byteArray)
-						{
-							byteArray.close();
-						}
-					} catch (IOException e1) {
-						throw new KettleException("Parsing complex string and generating surrogates/ByteArray failed. ", e1);
-					}
-            		i++;
-	            }
-            	else
-            	{
-	                Map<String, Integer> memberCache = allMemberCache.get(foreignKeyColumnName);
-	                
-	                String actualHierName = null;
-	                if(!isPresentInSchema)
-	                {
-	                    actualHierName = meta.hierNames[l++];
-	                    
-	                }
-	                
-	                Int2ObjectMap<int[]> cache = surrogateKeyGen.getHierCache()
-	                        .get(actualHierName);
-	                int[] surrogateKeyForHrrchy = null;
-	                if(null != cache)
-	                {
-	                    Integer keyFromCsv = memberCache.get(((String)r[j]));    
-	                    
-	                    if(null != keyFromCsv)
-	                    {
-	                        surrogateKeyForHrrchy = cache.get(keyFromCsv);
-	                    }
-	                    else
-	                    {
-	                        addMemberNotExistEntry(r, inputColumnsSize, j, columnName);
-	                        return null;
-	                    }
-	                    // If cardinality exceeded for some levels then for that hierarchy will not be their 
-	                    // so while joining with fact table if we are getting this scenerio we will log it 
-	                    // in bad records
-	                    if(null == surrogateKeyForHrrchy)
-	                    {
-	                        addCardinalityExcededEntry(r, inputColumnsSize, j,
-									columnName);
-	                        return null;
-	
-	                    }
-	                }
-	                else
-	                {
-	                    int[] propIndex = propMap.get(foreignKeyColumnName);
-	                    Object []properties;
-	                    if(null == propIndex)
-	                    {
-	                        properties = new Object[0]; 
-	                    }
-	                    else
-	                    {
-	                        properties = new Object[propIndex.length];
-	                        for(int ind = 0; ind < propIndex.length; ind++)
-	                        {
-	                            properties[ind]= r[propIndex[ind]];
-	                        }
-	                    }
-	                    surrogateKeyForHrrchy = new int[1];
-	                    if(isGenerated && !isNull)
-	                    {
-	                        surrogateKeyForHrrchy[0]=generatedSurrogate;
-	                        isGenerated=false;
-	                        generatedSurrogate=-1;
-	                    }
-	                    else
-	                    {
-	                        surrogateKeyForHrrchy[0] = surrogateKeyGen
-	                                .generateSurrogateKeys(((String)r[j]),
-	                                        foreignKeyColumnName,
-	                                        n,
-	                                        properties);
-	                    }
-	                    if(surrogateKeyForHrrchy[0] == -1)
-	                    {
-	                        addCardinalityExcededEntry(r, inputColumnsSize, j,
-									columnName);
-	                        return null;
-	                    }
-	                }
-	                for(int k = 0;k < surrogateKeyForHrrchy.length;k++)
-	                {
-	                    if(dimPresentCsvOrder[i])
-	                    {
-	                        if(duplicateColMapping[j] != null)
-	                        {
-	                            for (int m = 0; m < duplicateColMapping[j].length; m++) 
-	                            {
-	                                out[duplicateColMapping[j][m]] = Integer.valueOf(
-	                                        surrogateKeyForHrrchy[k]);
-	                            }
-	                        }
-	                        else
-	                        {
-	                            out[memberMapping[i]] = Integer.valueOf(
-	                                    surrogateKeyForHrrchy[k]);
-	                        }
-	                    }
-	                    
-	                    i++;
-	                }
-	                
-	            }
+                Map<String, Integer> memberCache = allMemberCache.get(foreignKeyColumnName);
+                
+                String actualHierName = null;
+                if(!isPresentInSchema)
+                {
+                    actualHierName = meta.hierNames[l++];
+                    
+                }
+                
+                Int2ObjectMap<int[]> cache = surrogateKeyGen.getHierCache()
+                        .get(actualHierName);
+                int[] surrogateKeyForHrrchy = null;
+                if(null != cache)
+                {
+                    Integer keyFromCsv = memberCache.get(((String)r[j]));    
+                    
+                    if(null != keyFromCsv)
+                    {
+                        surrogateKeyForHrrchy = cache.get(keyFromCsv);
+                    }
+                    else
+                    {
+                        addMemberNotExistEntry(r, inputRowSize, j, columnName);
+                        return null;
+                    }
+                    // If cardinality exceeded for some levels then for that hierarchy will not be their 
+                    // so while joining with fact table if we are getting this scenerio we will log it 
+                    // in bad records
+                    if(null == surrogateKeyForHrrchy)
+                    {
+                        addCardinalityExcededEntry(r, inputRowSize, j,
+								columnName);
+                        return null;
+
+                    }
+                }
+                else
+                {
+                    int[] propIndex = propMap.get(foreignKeyColumnName);
+                    Object []properties;
+                    if(null == propIndex)
+                    {
+                        properties = new Object[0]; 
+                    }
+                    else
+                    {
+                        properties = new Object[propIndex.length];
+                        for(int ind = 0; ind < propIndex.length; ind++)
+                        {
+                            properties[ind]= r[propIndex[ind]];
+                        }
+                    }
+                    surrogateKeyForHrrchy = new int[1];
+                    if(isGenerated && !isNull)
+                    {
+                        surrogateKeyForHrrchy[0]=generatedSurrogate;
+                        isGenerated=false;
+                        generatedSurrogate=-1;
+                    }
+                    else
+                    {
+                        surrogateKeyForHrrchy[0] = surrogateKeyGen
+                                .generateSurrogateKeys(((String)r[j]),
+                                        foreignKeyColumnName,
+                                        n,
+                                        properties);
+                    }
+                    if(surrogateKeyForHrrchy[0] == -1)
+                    {
+                        addCardinalityExcededEntry(r, inputRowSize, j,
+								columnName);
+                        return null;
+                    }
+                }
+                for(int k = 0;k < surrogateKeyForHrrchy.length;k++)
+                {
+                    if(dimPresentCsvOrder[i])
+                    {
+                        if(duplicateColMapping[j] != null)
+                        {
+                            for (int m = 0; m < duplicateColMapping[j].length; m++) 
+                            {
+                                out[duplicateColMapping[j][m]] = Integer.valueOf(
+                                        surrogateKeyForHrrchy[k]);
+                            }
+                        }
+                        else
+                        {
+                            out[memberMapping[i]] = Integer.valueOf(
+                                    surrogateKeyForHrrchy[k]);
+                        }
+                    }
+                    
+                    i++;
+                }
+                
             }
         }
-        
-        //CHECKSTYLE:ON
+      //CHECKSTYLE:ON
         insertHierIfRequired(out);
-        
-        RemoveDictionaryUtil.prepareOut(newArray, byteBufferArr, out, dimLen);
-        
             
-        return newArray;
+        return out;
     }
 
-    /**
+	/**
 	 * @param r
 	 * @param inputRowSize
 	 * @param j
@@ -2632,18 +2542,15 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
                 int[] levelsIndxs = meta.hirches.get(hierName);
                 int[] levelSKeys = new int[levelsIndxs.length];
 
-                if(meta.complexTypes.get(meta.hierColumnMap.get(hierName)[0]) == null)
+                for(int i = 0;i < levelSKeys.length;i++)
                 {
-	                for(int i = 0;i < levelSKeys.length;i++)
-	                {
-	                    levelSKeys[i] = (Integer)rowWithKeys[levelsIndxs[i]];
-	                }
-	
-	                if(levelSKeys.length > 1)
-	                {
-	                    data.getSurrogateKeyGen().checkNormalizedHierExists(
-	                            levelSKeys, hierName, hierWriter);
-	                }
+                    levelSKeys[i] = (Integer)rowWithKeys[levelsIndxs[i]];
+                }
+
+                if(levelSKeys.length > 1)
+                {
+                    data.getSurrogateKeyGen().checkNormalizedHierExists(
+                            levelSKeys, hierName, hierWriter);
                 }
             }
         }
@@ -3148,11 +3055,6 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
             else
             {
                 String[] columns = meta.hierColumnMap.get(name);
-                
-                if(meta.getComplexTypes().get(columns[0]) != null)
-                {
-                	continue;
-                }
                 //
                 for(int i = 0;i < a.length;i++)
                 {
@@ -3178,19 +3080,7 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
             keyGenerators.put(name, generator);
         
         }
-        
-        Iterator<Entry<String,GenericDataType>> complexMap = meta.getComplexTypes().entrySet().iterator();
-        while(complexMap.hasNext())
-        {
-            Entry<String,GenericDataType> complexDataType = complexMap.next();
-            List<GenericDataType> primitiveTypes = new ArrayList<GenericDataType>();
-            complexDataType.getValue().getAllPrimitiveChildren(primitiveTypes);
-            for(GenericDataType eachPrimitive : primitiveTypes)
-            {
-            	KeyGenerator generator = KeyGeneratorFactory.getKeyGenerator(new int[]{-1});
-            	keyGenerators.put(eachPrimitive.getName(), generator);
-            }
-        }
+                
     }
 
     /**
@@ -3350,60 +3240,6 @@ public class MolapCSVBasedSeqGenStep extends BaseStep
 			}
 		}
 	}
-	
-	
-	private void processhighCardinalityDim(int index,String dimension, ByteBuffer[] out)
-	{
-		 
-         	String dimensionValue = dimension;
-         	ByteBuffer buffer = ByteBuffer.allocate(dimensionValue.length());
-//         	buffer.putShort((short)dimensionValue.length());
-         	buffer.put(dimensionValue.getBytes(Charset.forName("UTF-8")));
-         	buffer.rewind();
-         	out[index] = buffer;
-         	
-	}
-	
-	/**
-	 * 
-	 * @param highCardDims
-	 * @param columnName
-	 * @return true if the dimension is high cardinality.
-	 */
-	   private boolean isDimensionHighCardinality(String[] highCardDims,
-	            String columnName)
-	    {
-	       for(String colName : highCardDims)
-	       {
-	           if(colName.equalsIgnoreCase(meta.getTableName()+MolapCommonConstants.UNDERSCORE+columnName))
-	           {
-	               return true;
-	           }
-	       }
-	        return false;
-	    }
-	   
-	   /**
-	    * This method will give the correct index where to place the high card dims
-	    * 
-	    * @param highCardCols
-	    * @param columnName
-	    * @return
-	    */
-	    private int getIndexOfHighCardDims(String[] highCardCols, String columnName)
-	    {
-	        for(int i = 0 ; i < highCardCols.length ; i++)
-	           {
-	               if(highCardCols[i].equalsIgnoreCase(meta.getTableName()+MolapCommonConstants.UNDERSCORE+columnName))
-	               {
-	                   // if found return index of high card dims
-	                   return i;
-	               }
-	           }
-	        
-	        // this case will not occur as the check is done earlier.
-	            return -1;
-	    }
 
 }
 
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/surrogatekeysgenerator/dbbased/MolapSeqGenStep.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/surrogatekeysgenerator/dbbased/MolapSeqGenStep.java
index c9b9dad..8dab59a 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/surrogatekeysgenerator/dbbased/MolapSeqGenStep.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/surrogatekeysgenerator/dbbased/MolapSeqGenStep.java
@@ -236,7 +236,9 @@ public class MolapSeqGenStep extends BaseStep implements StepInterface
             
             data.setInputSize(getInputRowMeta().size());
 
-            logCounter = Integer.parseInt(MolapCommonConstants.DATA_LOAD_LOG_COUNTER_DEFAULT_COUNTER);
+            logCounter = Integer.parseInt(MolapProperties.getInstance().getProperty(
+                    MolapCommonConstants.DATA_LOAD_LOG_COUNTER,
+                    MolapCommonConstants.DATA_LOAD_LOG_COUNTER_DEFAULT_COUNTER));
             if(!meta.isAggregate())
             {
                 updateHierarchyKeyGenerators(data.getKeyGenerators(),
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/threadbasedmerger/producer/ProducerThread.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/threadbasedmerger/producer/ProducerThread.java
index a004202..36626b9 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/threadbasedmerger/producer/ProducerThread.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/threadbasedmerger/producer/ProducerThread.java
@@ -317,7 +317,7 @@ public class ProducerThread implements Callable<Void>
             // create chunk holder
             molapSortTempFileChunkHolder = new MolapSortTempFileChunkHolder(
                     tempFile, this.measureCount, this.mdKeyLength,
-                    this.fileBufferSize,isFactMdkeyInInputRow,factMdkeyLength,new String[0]);
+                    this.fileBufferSize,isFactMdkeyInInputRow,factMdkeyLength,new String[0], new char[0]);
             // initialize
             molapSortTempFileChunkHolder.initialize();
             molapSortTempFileChunkHolder.readRow();
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/LevelSortIndexWriterThread.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/LevelSortIndexWriterThread.java
index b882425..4f50556 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/LevelSortIndexWriterThread.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/LevelSortIndexWriterThread.java
@@ -61,7 +61,7 @@ public class LevelSortIndexWriterThread implements Callable<Void>
     public LevelSortIndexWriterThread(String levelFilePath, String dataType)
     {
         this.levelFilePath = levelFilePath;
-        if(dataType.equalsIgnoreCase("Numeric") ||dataType.equalsIgnoreCase("Integer"))
+        if(dataType.equalsIgnoreCase("Numeric") || dataType.equalsIgnoreCase("Integer") || dataType.equalsIgnoreCase("BigInt"))
         {//CHECKSTYLE:ON
             memberDataType = DataType.NUMBER;
         }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/MolapDataProcessorUtil.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/MolapDataProcessorUtil.java
index cad5999..a37f6e8 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/MolapDataProcessorUtil.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/MolapDataProcessorUtil.java
@@ -60,13 +60,19 @@ import com.huawei.unibi.molap.datastorage.store.filesystem.MolapFileFilter;
 import com.huawei.unibi.molap.datastorage.store.impl.FileFactory;
 import com.huawei.unibi.molap.datastorage.store.impl.FileFactory.FileType;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
-import com.huawei.unibi.molap.engine.aggregator.impl.AvgAggregator;
+import com.huawei.unibi.molap.engine.aggregator.impl.AvgDoubleAggregator;
+import com.huawei.unibi.molap.engine.aggregator.impl.AvgLongAggregator;
+import com.huawei.unibi.molap.engine.aggregator.impl.AvgBigDecimalAggregator;
 import com.huawei.unibi.molap.engine.aggregator.impl.CountAggregator;
 import com.huawei.unibi.molap.engine.aggregator.impl.DistinctCountAggregator;
 import com.huawei.unibi.molap.engine.aggregator.impl.MaxAggregator;
 import com.huawei.unibi.molap.engine.aggregator.impl.MinAggregator;
-import com.huawei.unibi.molap.engine.aggregator.impl.SumAggregator;
-import com.huawei.unibi.molap.engine.aggregator.impl.SumDistinctAggregator;
+import com.huawei.unibi.molap.engine.aggregator.impl.SumDoubleAggregator;
+import com.huawei.unibi.molap.engine.aggregator.impl.SumLongAggregator;
+import com.huawei.unibi.molap.engine.aggregator.impl.SumBigDecimalAggregator;
+import com.huawei.unibi.molap.engine.aggregator.impl.SumDistinctDoubleAggregator;
+import com.huawei.unibi.molap.engine.aggregator.impl.SumDistinctLongAggregator;
+import com.huawei.unibi.molap.engine.aggregator.impl.SumDistinctBigDecimalAggregator;
 import com.huawei.unibi.molap.engine.datastorage.InMemoryCube;
 import com.huawei.unibi.molap.engine.datastorage.InMemoryCubeStore;
 import com.huawei.unibi.molap.exception.MolapDataProcessorException;
@@ -108,8 +114,8 @@ public final class MolapDataProcessorUtil
      * @throws IOException
      * 
      */
-    private static void writeMeasureMetaDataToFileLocal(double[] maxValue,
-            double[] minValue, int[] decimalLength, double[] uniqueValue,
+    private static void writeMeasureMetaDataToFileLocal(Object[] maxValue,
+            Object[] minValue, int[] decimalLength, Object[] uniqueValue,
             char[] aggType, byte[] dataTypeSelected,double[] minValueFact,String measureMetaDataFileLocation)
             throws MolapDataProcessorException
     {
@@ -126,16 +132,24 @@ public final class MolapDataProcessorUtil
         }
         ByteBuffer byteBuffer = ByteBuffer.allocate(totalSize);
 
+        if(null != aggType)
+        {
+        	for(int j = 0;j < aggType.length;j++)
+            {
+                byteBuffer.putChar(aggType[j]);
+            }
+        }
+        
         // add all the max
         for(int j = 0;j < maxValue.length;j++)
         {
-            byteBuffer.putDouble(maxValue[j]);
+            writeValue(byteBuffer, maxValue[j], aggType[j]);
         }
 
         // add all the min
         for(int j = 0;j < minValue.length;j++)
         {
-            byteBuffer.putDouble(minValue[j]);
+            writeValue(byteBuffer, minValue[j], aggType[j]);
         }
 
         // add all the decimal
@@ -146,15 +160,7 @@ public final class MolapDataProcessorUtil
         
         for(int j = 0;j < uniqueValue.length;j++)
         {
-            byteBuffer.putDouble(uniqueValue[j]);
-        }
-        
-        if(null != aggType)
-        {
-        	for(int j = 0;j < aggType.length;j++)
-            {
-                byteBuffer.putChar(aggType[j]);
-            }
+            writeValue(byteBuffer, uniqueValue[j], aggType[j]);
         }
         
         for(int j = 0;j < dataTypeSelected.length;j++)
@@ -192,16 +198,28 @@ public final class MolapDataProcessorUtil
         }
     }
     
-    public static void writeMeasureMetaDataToFile(double[] maxValue,
-            double[] minValue, int[] decimalLength, double[] uniqueValue,
+    private static void writeValue(ByteBuffer byteBuffer, Object value, char type)
+    {
+        if(type == 'l')
+        {
+            byteBuffer.putLong((long)value);
+        }
+        else
+        {
+            byteBuffer.putDouble((double)value);
+        }
+    }
+    
+    public static void writeMeasureMetaDataToFile(Object[] maxValue,
+            Object[] minValue, int[] decimalLength, Object[] uniqueValue,
             char[] aggType, byte[] dataTypeSelected,String measureMetaDataFileLocation)
             throws MolapDataProcessorException
     {
     	writeMeasureMetaDataToFileLocal(maxValue, minValue, decimalLength, uniqueValue, aggType, dataTypeSelected,null, measureMetaDataFileLocation);
     }
     
-    public static void writeMeasureMetaDataToFileForAgg(double[] maxValue,
-            double[] minValue, int[] decimalLength, double[] uniqueValue,
+    public static void writeMeasureMetaDataToFileForAgg(Object[] maxValue,
+            Object[] minValue, int[] decimalLength, Object[] uniqueValue,
             char[] aggType, byte[] dataTypeSelected,double[] minValueAgg, String measureMetaDataFileLocation)
             throws MolapDataProcessorException
     {
@@ -1351,11 +1369,7 @@ public final class MolapDataProcessorUtil
         	sb.append(dimlens[i]);
             sb.append(MolapCommonConstants.COMA_SPC_CHARACTER);
         }
-        // in case where there is no dims present but high card dims are present.
-        if(dimlens.length > 0)
-        {
-            sb.append(dimlens[dimlens.length-1]);
-        }
+        sb.append(dimlens[dimlens.length-1]);
         return sb.toString();
     }
     
@@ -1415,11 +1429,7 @@ public final class MolapDataProcessorUtil
         //
         for(int i = 0;i < factLevelIndex.length;i++)
         {
-			// in case of high card this will be -1
-            if(factLevelIndex[i] == -1)
-            {
-                continue;
-            }
+
             int[] range = generator.getKeyByteOffsets(factLevelIndex[i]);
             for(int j = range[0];j <= range[1];j++)
             {
@@ -1488,7 +1498,7 @@ public final class MolapDataProcessorUtil
 //        return files;
 //    }
     
-    public static double[] updateMergedMinValue(String schemaName, String cubeName, String tableName, int measureCount, String extension, int currentRestructNumber)
+    public static Object[] updateMergedMinValue(String schemaName, String cubeName, String tableName, int measureCount, String extension, int currentRestructNumber)
     {
         // get the table name
         String inputStoreLocation =schemaName + File.separator
@@ -1525,7 +1535,7 @@ public final class MolapDataProcessorUtil
                 + tableName + MolapCommonConstants.MEASUREMETADATA_FILE_EXT;
         String measureMetaDataFileLocation = storeLocation
                 + metaDataFileName;
-		double[] mergedMinValue = ValueCompressionUtil.readMeasureMetaDataFile(
+		Object[] mergedMinValue = ValueCompressionUtil.readMeasureMetaDataFile(
 				measureMetaDataFileLocation, measureCount).getMinValue();
 		return mergedMinValue;
     }
@@ -1834,7 +1844,9 @@ public final class MolapDataProcessorUtil
      */
     public static String getAggType(MeasureAggregator aggregator)
     {
-        if(aggregator instanceof SumAggregator)
+        if(aggregator instanceof SumDoubleAggregator
+                || aggregator instanceof SumLongAggregator
+                || aggregator instanceof SumBigDecimalAggregator)
         {
             return MolapCommonConstants.SUM;
         }
@@ -1846,7 +1858,9 @@ public final class MolapDataProcessorUtil
         {
             return MolapCommonConstants.MIN;
         }
-        else if(aggregator instanceof AvgAggregator)
+        else if(aggregator instanceof AvgDoubleAggregator
+                || aggregator instanceof AvgLongAggregator
+                || aggregator instanceof AvgBigDecimalAggregator)
         {
             return MolapCommonConstants.AVERAGE;
         }
@@ -1858,7 +1872,9 @@ public final class MolapDataProcessorUtil
         {
             return MolapCommonConstants.DISTINCT_COUNT;
         }
-        else if(aggregator instanceof SumDistinctAggregator)
+        else if(aggregator instanceof SumDistinctDoubleAggregator
+                || aggregator instanceof SumDistinctLongAggregator
+                || aggregator instanceof SumDistinctBigDecimalAggregator)
         {
             return MolapCommonConstants.SUM_DISTINCT;
         }
@@ -1928,7 +1944,7 @@ public final class MolapDataProcessorUtil
     public static String[] getReorderedLevels(MolapDef.Schema schema,
             MolapDef.Cube cube, String[] aggreateLevels, String factTableName)
     {
-        String[] factDimensions = MolapSchemaParser.getAllCubeDimensions(cube,
+        String[] factDimensions = MolapSchemaParser.getCubeDimensions(cube,
                 schema);
         String[] reorderedAggregateLevels = new String[aggreateLevels.length];
         int[] reorderIndex = new int[aggreateLevels.length];
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/MolapSchemaParser.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/MolapSchemaParser.java
index eb2b2d3..859379f 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/MolapSchemaParser.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/MolapSchemaParser.java
@@ -35,10 +35,6 @@ import org.eigenbase.xom.Parser;
 import org.eigenbase.xom.XOMException;
 import org.eigenbase.xom.XOMUtil;
 
-import com.huawei.datasight.molap.datatypes.ArrayDataType;
-import com.huawei.datasight.molap.datatypes.GenericDataType;
-import com.huawei.datasight.molap.datatypes.PrimitiveDataType;
-import com.huawei.datasight.molap.datatypes.StructDataType;
 import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
 import com.huawei.unibi.molap.api.dataloader.SchemaInfo;
@@ -52,8 +48,8 @@ import com.huawei.unibi.molap.olap.DimensionType;
 import com.huawei.unibi.molap.olap.LevelType;
 import com.huawei.unibi.molap.olap.MolapDef;
 import com.huawei.unibi.molap.olap.MolapDef.AggLevel;
-import com.huawei.unibi.molap.olap.MolapDef.Annotation;
-import com.huawei.unibi.molap.olap.MolapDef.Annotations;
+//import com.huawei.unibi.molap.olap.MolapDef.Annotation;
+//import com.huawei.unibi.molap.olap.MolapDef.Annotations;
 import com.huawei.unibi.molap.olap.MolapDef.Cube;
 import com.huawei.unibi.molap.olap.MolapDef.CubeDimension;
 import com.huawei.unibi.molap.olap.MolapDef.Dimension;
@@ -386,9 +382,7 @@ public final class MolapSchemaParser
                     
                     for(Level levels : hierarchy.levels)
                     {
-                    	if(levels.parentname != null)
-                    		continue;
-                    	if(foreignKeys.contains(levels.name))
+                        if(foreignKeys.contains(levels.name))
                         {
                             columns.append(levels.name);
                             columns.append(MolapCommonConstants.HASH_SPC_CHARACTER);
@@ -685,8 +679,6 @@ public final class MolapSchemaParser
                 {
                     for(Level level : hierarchy.levels)
                     {
-                    	if(level.parentname != null)
-                    		continue;
                         if(levelColumn.equals(level.column))
                         {
                             if(null != level.nameColumn)
@@ -734,8 +726,6 @@ public final class MolapSchemaParser
                 {
                     for(Level level : hierarchy.levels)
                     {
-                    	if(level.parentname != null)
-                    		continue;
                         if(levelColumn.equals(level.column))
                         {
                             if(null != level.nameColumn)
@@ -1129,8 +1119,6 @@ public final class MolapSchemaParser
                     Level[] levels = hierarchy.levels;
                     for(Level level : levels)
                     {
-                    	if(level.parentname != null)
-                    		continue;
                         query.append(System.getProperty("line.separator"));
                         if(counter!=0)
                         {
@@ -1167,10 +1155,6 @@ public final class MolapSchemaParser
     {
         for(CubeDimension cDimension : dimensions)
         {
-        	if(cDimension.highCardinality)
-        	{
-        		continue;
-        	}
             Hierarchy[] hierarchies =  null;
             hierarchies = extractHierarchies(schema, cDimension);
             for(Hierarchy hierarchy : hierarchies)
@@ -1183,14 +1167,9 @@ public final class MolapSchemaParser
                         : ((Table)hierarchy.relation).name;
                 // String tableName = hierarchy.relation.toString();
                 int i = hierarchy.levels.length;
-                boolean appendComma = true;
+
                 for(Level level : hierarchy.levels)
                 { //Added for Normalized hierarchy AR-UniBI-OLAP-003
-                	if(level.parentname != null)
-                	{
-                		appendComma = false;
-                		continue;
-                	}
                     if(hierarchy.normalized)
                     {
                         if(i==1)
@@ -1231,8 +1210,7 @@ public final class MolapSchemaParser
                     i--;
 
                 }
-                if(appendComma)
-                	dimString.append(MolapCommonConstants.COMA_SPC_CHARACTER);
+                dimString.append(MolapCommonConstants.COMA_SPC_CHARACTER);
             }
         }
 /*
@@ -1306,8 +1284,6 @@ public final class MolapSchemaParser
                 int counter=0;
                 for(Level level : hierarchy.levels)
                 {
-                	if(level.parentname != null)
-                		continue;
                     if(hierarchy.normalized)
                     {
                         if(counter==hierarchy.levels.length-1)
@@ -1365,8 +1341,6 @@ public final class MolapSchemaParser
                 : ((Table)hierarchy.relation).name;
         for(Level level : hierarchy.levels)
         {
-        	if(level.parentname != null)
-        		continue;
             cardinalities.put(tableName + '_' + level.column,
                     level.levelCardinality + "");
         }
@@ -1490,10 +1464,6 @@ public final class MolapSchemaParser
 
         for(CubeDimension cDimension : dimensions)
         {
-            if(cDimension.highCardinality)
-            {
-                continue;
-            }
             Hierarchy[] hierarchies = null;
             hierarchies = extractHierarchies(schema, cDimension);
             String cDimName = cDimension.name; 
@@ -1694,11 +1664,6 @@ public final class MolapSchemaParser
         MolapDef.CubeDimension[] dimensions = cube.dimensions;
         for(CubeDimension cDimension : dimensions)
         {
-        	//Ignoring the dimensions which are high cardinality dimension
-        	if(cDimension.highCardinality)
-        	{
-        		continue;
-        	}
             Hierarchy[] hierarchies = null;
             hierarchies = extractHierarchies(schema, cDimension);
             for(Hierarchy hierarchy : hierarchies)
@@ -1713,39 +1678,6 @@ public final class MolapSchemaParser
         fields= list.toArray(fields);
         return fields;
     }
-    /**
-     * Get the high cardinality dimensions from the cube metadata, for these dims
-     * no metadata will be generated.
-     * @param cube
-     * @param schema
-     * @return String[].
-     */
-    public static String[] getHighCardinalityDimensions(Cube cube,Schema schema)
-    {
-    	 List<String> list = new ArrayList<String>(MolapCommonConstants.CONSTANT_SIZE_TEN);
-    	  MolapDef.CubeDimension[] dimensions = cube.dimensions;
-         for(CubeDimension cDimension : dimensions)
-         {
-         	//Ignoring the dimensions which are high cardinality dimension
-         	if(!cDimension.highCardinality)
-         	{
-         		continue;
-         	}
-             Hierarchy[] hierarchies = null;
-             hierarchies = extractHierarchies(schema, cDimension);
-             for(Hierarchy hierarchy : hierarchies)
-             {
-//                 String dimName = cDimension.name;
-//                 dimName = dimName.replaceAll(" ", "_");
-                 String factTableName = getFactTableName(cube);
-                 list.addAll(getTableNames(factTableName, hierarchy));
-             }
-         }
-         String[] fields = new String[list.size()];
-         fields= list.toArray(fields);
-         return fields;
-       
-    }
     
     /**
      * @param cube
@@ -1850,8 +1782,6 @@ public final class MolapSchemaParser
                 : ((Table)hierarchy.relation).name;
         for(Level level : hierarchy.levels)
         {
-        	if(level.parentname != null)
-        		continue;
             list.add(tableName + '_' + level.column);
 
 //            if(hasOrdinalColumn(level))
@@ -1887,8 +1817,6 @@ public final class MolapSchemaParser
         int counter = 0;
         for(Level level : hierarchy.levels)
         {
-        	if(level.parentname != null)
-        		continue;
         	if(hierarchy.normalized)
         	{
         		if(counter == hierarchy.levels.length-1)
@@ -1929,9 +1857,7 @@ public final class MolapSchemaParser
                         : ((Table)hierarchy.relation).name;
                 for(Level level : hierarchy.levels)
                 {
-                	if(level.parentname != null)
-                		continue;
-                    list.add(tableName + '_' + level.column);
+                        list.add(tableName + '_' + level.column);
                     //
                 }
             }
@@ -1941,59 +1867,6 @@ public final class MolapSchemaParser
         return fields;
     }
     
-    
-    /**
-     * @param cube
-     * @return
-     */
-    public static Map<String,GenericDataType> getComplexDimensions(Cube cube,Schema schema)
-    {  
-    	MolapDef.CubeDimension[] dimensions = cube.dimensions;
-    	Map<String,GenericDataType> complexTypeMap = new HashMap<String,GenericDataType>();
-    	for(CubeDimension cDimension : dimensions)
-    	{
-    		//
-    		Hierarchy[] hierarchies = null;
-    		hierarchies = extractHierarchies(schema, cDimension);
-    		for(Hierarchy hierarchy : hierarchies)
-    		{
-    			if(hierarchy.levels.length > 1 && (hierarchy.levels[0].type.equals("Array") 
-    					|| hierarchy.levels[0].type.equals("Struct")))
-    			{
-    				Level levelZero = hierarchy.levels[0];
-    				GenericDataType g = levelZero.type.equals("Array")?
-    						new ArrayDataType(levelZero.name, ""):new StructDataType(levelZero.name, "");
-    				complexTypeMap.put(levelZero.name, g);
-    				boolean isFirst = true;
-	    			for(Level level : hierarchy.levels)
-	    			{
-	    				if(isFirst)
-	    				{
-	    					isFirst = false;
-	    					continue;
-	    				}
-	    				else
-	    				{
-		    				switch(level.type)
-		    				{
-		    					case "Array" : 
-		    						g.addChildren(new ArrayDataType(level.name, level.parentname));
-		    						break;
-		    					case "Struct" : 
-		    						g.addChildren(new StructDataType(level.name, level.parentname));
-		    						break;
-		    					default :
-		    						g.addChildren(new PrimitiveDataType(level.name, level.parentname));
-		    				}
-	    				}
-	    			}
-    			}
-    		}
-    	}
-    	return complexTypeMap;
-    }
-    
-    
     /**
      * @param cube
      * @return
@@ -2283,8 +2156,6 @@ private static String getDimensionTable(String dimName, String hierName, String
                 {
                     for(Level levels : hierarchy.levels)
                     {
-                    	if(levels.parentname != null)
-                    		continue;
                         if(levelName.equals(levels.name))
                         {
                             RelationOrJoin relation = hierarchy.relation;
@@ -2327,8 +2198,6 @@ private static String getDimensionTable(String dimName, String levelName, Cube c
                 {
                     for(Level levels : hierarchy.levels)
                     {
-                    	if(levels.parentname != null)
-                    		continue;
                         if(levelName.equals(levels.name))
                         {
                             RelationOrJoin relation = hierarchy.relation;
@@ -2388,8 +2257,6 @@ private static String getDimensionTable(String dimName, String levelName, Cube c
     {
         for(Level level : hierarchy.levels)
         {
-        	if(level.parentname != null)
-        		continue;
             boolean levelAdded = false;
 
             // First is ordinal column
@@ -2477,8 +2344,6 @@ private static String getDimensionTable(String dimName, String levelName, Cube c
                 builder.append(dimName+'_'+heirName+".hierarchy");
                 for(Level level : hierarchy.levels)
                 {
-                	if(level.parentname != null)
-                		continue;
                     cardinalityList.add(level.levelCardinality);
                 }
                 for(int i = 0;i < cardinalityList.size();i++)
@@ -2522,8 +2387,6 @@ private static String getDimensionTable(String dimName, String levelName, Cube c
                 {
                     for(Level level : hierarchy.levels)
                     {
-                    	if(level.parentname != null)
-                    		continue;
                         cardinalityList.add(level.levelCardinality);
                     }
                 }
@@ -2620,8 +2483,6 @@ private static String getDimensionTable(String dimName, String levelName, Cube c
         propString.append(MolapCommonConstants.SEMICOLON_SPC_CHARACTER);
         for(Level level : hierarchy.levels)
         {
-        	if(level.parentname != null)
-        		continue;
             String levelType = level.levelType;
             if(LevelType.TimeYears.name().equals(levelType))
             {
@@ -2680,8 +2541,6 @@ private static String getDimensionTable(String dimName, String levelName, Cube c
         propString.append(MolapCommonConstants.COLON_SPC_CHARACTER);
         for(Level level : hierarchy.levels)
         {
-        	if(level.parentname != null)
-        		continue;
             propString.append(tableName + '_' + level.column);
 
             // First is ordinal column
@@ -2749,8 +2608,6 @@ private static String getDimensionTable(String dimName, String levelName, Cube c
                 {
                     for(Level level : hierarchy.levels)
                     {
-                    	if(level.parentname != null)
-                    		continue;
                         if(levelColumn.equals(level.column))
                         {
                             if(level.nameColumn != null
@@ -2858,8 +2715,6 @@ private static String getDimensionTable(String dimName, String levelName, Cube c
                 {
                 for(Level level :  hierarchy.levels)
                 {
-                	if(level.parentname != null)
-                		continue;
                     cardinalityList.add(level.levelCardinality);
                 }
                 }
@@ -2944,8 +2799,6 @@ private static String getDimensionTable(String dimName, String levelName, Cube c
                 heirName = heirName.replaceAll(" ", "_");
                 for(Level level : hierarchy.levels)
                 {
-                	if(level.parentname != null)
-                		continue;
                     cardinalityList.add(level.levelCardinality);
                 }
                 dims = new int[cardinalityList.size()];
@@ -3011,8 +2864,6 @@ private static String getDimensionTable(String dimName, String levelName, Cube c
                     // {
                     for(Level level : hierarchy.levels)
                     {
-                    	if(level.parentname != null)
-                    		continue;
 
                         localString.append(level.column);
 
@@ -3574,12 +3425,6 @@ private static String getDimensionTable(String dimName, String levelName, Cube c
 //        {
             for(CubeDimension cDimension : dimensions)
             {
-                
-                if(cDimension.highCardinality)
-                {
-                    continue;
-                }
-                
                 //
                 Hierarchy[] hierarchies = null;
                 hierarchies = extractHierarchies(schema, cDimension);
@@ -3588,8 +3433,6 @@ private static String getDimensionTable(String dimName, String levelName, Cube c
                 {
                     for(Level level : hierarchy.levels)
                     {
-                    	if(level.parentname != null)
-                    		continue;
                         actualDim.append(level.column);
                     actualDim.append(MolapCommonConstants.AMPERSAND_SPC_CHARACTER);
                     }
@@ -3686,85 +3529,88 @@ private static String getDimensionTable(String dimName, String levelName, Cube c
     {
         StringBuilder measureDataTypeString = new StringBuilder();
         MolapDef.Measure[] measures = cube.measures;
-        
         for(MolapDef.Measure measure : measures)
         {
-           Annotations annotations = measure.annotations;
-           if(null == annotations)
-           {
-               continue;
-           }
-           Annotation[] array = measure.annotations.array;
-           for(int i=0; i< array.length; i++)
-           {
-               if(array[i].name.equals(MolapCommonConstants.MEASURE_SRC_DATA_TYPE))
-               {
-                   measureDataTypeString.append(measure.column);
-                    measureDataTypeString.append(MolapCommonConstants.COLON_SPC_CHARACTER);
-                   if(array[i].cdata.equalsIgnoreCase("String"))
-                   {
-                       if(isMeasureColumnAsSomeOtherAggregator(measure.column, cube))
-                       {
-                           measureDataTypeString.append("false");
-                       }
-                       else
-                       {
-                           measureDataTypeString.append("true");
-                       }
-                   }
-                   else
-                   {
-                       measureDataTypeString.append("false");
-                   }
-                    measureDataTypeString.append(MolapCommonConstants.AMPERSAND_SPC_CHARACTER);
-               }
-           }
+            measureDataTypeString.append(measure.datatype).append(
+                    MolapCommonConstants.AMPERSAND_SPC_CHARACTER);
+//           Annotations annotations = measure.annotations;
+//           if(null == annotations)
+//           {
+//               continue;
+//           }
+//           Annotation[] array = measure.annotations.array;
+//           for(int i=0; i< array.length; i++)
+//           {
+//               if(array[i].name.equals(MolapCommonConstants.MEASURE_SRC_DATA_TYPE))
+//               {
+//                   measureDataTypeString.append(measure.column);
+//                    measureDataTypeString.append(MolapCommonConstants.COLON_SPC_CHARACTER);
+//                   if(array[i].cdata.equalsIgnoreCase("String"))
+//                   {
+//                       if(isMeasureColumnAsSomeOtherAggregator(measure.column, cube))
+//                       {
+//                           measureDataTypeString.append("false");
+//                       }
+//                       else
+//                       {
+//                           measureDataTypeString.append("true");
+//                       }
+//                   }
+//                   else
+//                   {
+//                       measureDataTypeString.append("false");
+//                   }
+//                    measureDataTypeString.append(MolapCommonConstants.AMPERSAND_SPC_CHARACTER);
+//               }
+//           }
         }
         
         String measureTypeString = measureDataTypeString.toString();
 
         if(measureTypeString.length() > 0
-                && measureTypeString.endsWith(MolapCommonConstants.AMPERSAND_SPC_CHARACTER))
+                && measureTypeString
+                        .endsWith(MolapCommonConstants.AMPERSAND_SPC_CHARACTER))
         {
-            measureTypeString = measureTypeString.substring(0,
-                    measureTypeString.length() - MolapCommonConstants.AMPERSAND_SPC_CHARACTER.length());
+            measureTypeString = measureTypeString.substring(
+                    0,
+                    measureTypeString.length()
+                            - MolapCommonConstants.AMPERSAND_SPC_CHARACTER
+                                    .length());
         }
-        
         return measureTypeString;
-    
-    }
-    /**
-     * 
-     * @param column
-     * @param cube
-     * 
-     */
-    private static boolean isMeasureColumnAsSomeOtherAggregator(String msrColumnName,
-            Cube cube)
-    {
-       Measure[] measures = cube.measures;
-       for(Measure measure : measures)
-       {
-           if(msrColumnName.equals(measure.column))
-           {
-               Annotations annotations = measure.annotations;
-               if(null == annotations)
-               {
-                   String aggregator = measure.aggregator;
-                   if(aggregator.equals("count") || aggregator.equals("distinct-count"))
-                   {
-                       continue;
-                   }
-                   else
-                   {
-                       return true;
-                   }
-               }
-           }
-       }
-        
-        return false;
     }
+//    /**
+//     * 
+//     * @param column
+//     * @param cube
+//     * 
+//     */
+//    private static boolean isMeasureColumnAsSomeOtherAggregator(String msrColumnName,
+//            Cube cube)
+//    {
+//       Measure[] measures = cube.measures;
+//       for(Measure measure : measures)
+//       {
+//           if(msrColumnName.equals(measure.column))
+//           {
+//               Annotations annotations = measure.annotations;
+//               if(null == annotations)
+//               {
+//                   String aggregator = measure.aggregator;
+//                   if(aggregator.equals("count") || aggregator.equals("distinct-count"))
+//                   {
+//                       continue;
+//                   }
+//                   else
+//                   {
+//                       return true;
+//                   }
+//               }
+//           }
+//       }
+//        
+//        return false;
+//    }
     
     public static Map<String,Integer> getLevelOrdinals(Cube cube, Schema schema)
     {
@@ -3778,8 +3624,6 @@ private static String getDimensionTable(String dimName, String levelName, Cube c
             {
                 for(Level level:hier.levels)
                 {
-                	if(level.parentname != null)
-                		continue;
                     ordinalMap.put(dim.name+'_'+hier.name+'_'+level.name, count++);
                 }
             }
@@ -3801,8 +3645,6 @@ private static String getDimensionTable(String dimName, String levelName, Cube c
         // CHECKSTYLE:OFF Approval No:V3R8C00_002
         for(Level level:hier.levels)
         {// CHECKSTYLE:ON
-        	if(level.parentname != null)
-        		continue;
             cardinalities[index++]=level.levelCardinality;
         }
         return cardinalities;
@@ -3845,61 +3687,12 @@ private static String getDimensionTable(String dimName, String levelName, Cube c
 
                 for(Level level : hierarchy.levels)
                 { // Added for Normalized hierarchy AR-UniBI-OLAP-003
-                	String levelName = tableName + '_' + level.column;
-                    dimString.append(levelName+MolapCommonConstants.LEVEL_FILE_EXTENSION
+
+                    dimString.append(tableName + '_' + level.column+MolapCommonConstants.LEVEL_FILE_EXTENSION
                             + MolapCommonConstants.COLON_SPC_CHARACTER
-                            + level.type
-                            + MolapCommonConstants.HASH_SPC_CHARACTER);
+                            + level.type);
                 }
-            }
-        }
-        return dimString.toString();
-    }
-    
-    /**
-     * Below method will be used to get the level and its data type string
-     * @param dimensions
-     * @param schema
-     * @param cube
-     * @return String
-     */
-    public static String getLevelDataTypeAndParentMapString(Cube cube, Schema schema)
-    {
-        StringBuilder dimString= new StringBuilder();
-        MolapDef.CubeDimension[] dimensions = cube.dimensions;
-        for(CubeDimension cDimension : dimensions)
-        {
-            Hierarchy[] hierarchies =  null;
-            hierarchies = extractHierarchies(schema, cDimension);
-            for(Hierarchy hierarchy : hierarchies)
-            {
-            	if(hierarchy.levels.length > 1 && (hierarchy.levels[0].type.equals("Array") 
-    					|| hierarchy.levels[0].type.equals("Struct")))
-    			{
-    				Level levelZero = hierarchy.levels[0];
-    				boolean isFirst = true;
-    				dimString.append(levelZero.name
-                            + MolapCommonConstants.COLON_SPC_CHARACTER
-                            + levelZero.type
-                            + MolapCommonConstants.COLON_SPC_CHARACTER
-                            + ""
-                            + MolapCommonConstants.HASH_SPC_CHARACTER);
-	                for(Level level : hierarchy.levels)
-	                { 
-	                	if(isFirst)
-	                	{
-	                		isFirst = false;
-	                		continue;
-	                	}
-	                    dimString.append(level.name
-	                            + MolapCommonConstants.COLON_SPC_CHARACTER
-	                            + level.type
-	                            + MolapCommonConstants.COLON_SPC_CHARACTER
-	                            + level.parentname
-	                            + MolapCommonConstants.HASH_SPC_CHARACTER);
-	                }
-	                dimString.append(MolapCommonConstants.SEMICOLON_SPC_CHARACTER);
-    			}
+                dimString.append(MolapCommonConstants.HASH_SPC_CHARACTER);
             }
         }
         return dimString.toString();
@@ -3922,121 +3715,4 @@ private static String getDimensionTable(String dimName, String levelName, Cube c
         }
     	return null;
     }
-    
-    /**
-     * Get dimension string from a array of CubeDimension,which can be shared
-     * CubeDimension within schema or in a cube.
-     * @param cube 
-     * 
-     * @param dimensions
-     * @return
-     * 
-     */
-    public static int getHighCardinalityDimensionString(Cube cube, CubeDimension[] dimensions,
-            StringBuilder dimString, int counter, Schema schema)
-    {
-        for(CubeDimension cDimension : dimensions)
-        {
-            if(!cDimension.highCardinality)
-            {
-                continue;
-            }
-            Hierarchy[] hierarchies =  null;
-            hierarchies = extractHierarchies(schema, cDimension);
-       
-            for(Hierarchy hierarchy : hierarchies)
-            {
-                RelationOrJoin relation = hierarchy.relation;
-                // String dimName = cDimension.name;
-                // dimName = dimName.replaceAll(" ", "_");
-        
-
-                String tableName = relation == null ? getFactTableName(cube)
-                        : ((Table)hierarchy.relation).name;
-                // String tableName = hierarchy.relation.toString();
-                int i = hierarchy.levels.length;
-
-                for(Level level : hierarchy.levels)
-                { //Added for Normalized hierarchy AR-UniBI-OLAP-003
-                    
-                    if(hierarchy.normalized)
-                    {
-                        if(i==1)
-                        {
-                            dimString.append(tableName + '_' + level.column
-                                    + MolapCommonConstants.COLON_SPC_CHARACTER + counter + MolapCommonConstants.COLON_SPC_CHARACTER
-                                    + level.levelCardinality + MolapCommonConstants.COLON_SPC_CHARACTER + 'Y');
-
-                        }
-                        else
-                        {
-                            dimString.append(tableName + '_' + level.column
-                                    + MolapCommonConstants.COLON_SPC_CHARACTER + counter + MolapCommonConstants.COLON_SPC_CHARACTER
-                                    + level.levelCardinality + MolapCommonConstants.COLON_SPC_CHARACTER + 'N');
-                        }
-                        if(i > 1)
-                        {
-                            dimString.append(MolapCommonConstants.COMA_SPC_CHARACTER);
-
-                        }
-                        counter++;
-                    }
-                    else
-                    {
-
-                        dimString.append(tableName + '_' + level.column + MolapCommonConstants.COLON_SPC_CHARACTER
-                                + counter + MolapCommonConstants.COLON_SPC_CHARACTER + level.levelCardinality + MolapCommonConstants.COLON_SPC_CHARACTER
-                                + 'Y');
-                        counter++;
-                        if(i > 1)
-                        {
-                            dimString.append(MolapCommonConstants.COMA_SPC_CHARACTER);
-
-                    }
-                    
-                   }
-
-                    i--;
-
-                }
-                dimString.append(MolapCommonConstants.COMA_SPC_CHARACTER);
-            }
-        }
-/*
-        String dimstr = dimString.toString();
-        if(dimstr.length() > 0 && dimstr.endsWith(MolapCommonConstants.COMA_SPC_CHARACTER))
-        {
-            dimstr = dimstr.substring(0, dimstr.length()
-                    - MolapCommonConstants.COMA_SPC_CHARACTER.length());
-        }*/
-
-        return counter;
-    }
-    
-    /**
-     * getting all the dimensions irrespective of the high cardinality dimensions.
-     * @param cube
-     * @return
-     */
-    public static String[] getAllCubeDimensions(Cube cube,Schema schema)
-    {
-        List<String> list = new ArrayList<String>(MolapCommonConstants.CONSTANT_SIZE_TEN);
-        MolapDef.CubeDimension[] dimensions = cube.dimensions;
-        for(CubeDimension cDimension : dimensions)
-        {
-            Hierarchy[] hierarchies = null;
-            hierarchies = extractHierarchies(schema, cDimension);
-            for(Hierarchy hierarchy : hierarchies)
-            {
-//                String dimName = cDimension.name;
-//                dimName = dimName.replaceAll(" ", "_");
-                String factTableName = getFactTableName(cube);
-                list.addAll(getTableNames(factTableName, hierarchy));
-            }
-        }
-        String[] fields = new String[list.size()];
-        fields= list.toArray(fields);
-        return fields;
-    }
-
 }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/MolapSliceAndFiles.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/MolapSliceAndFiles.java
index 63a779a..de97fb5 100644
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/MolapSliceAndFiles.java
+++ b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/MolapSliceAndFiles.java
@@ -1,7 +1,6 @@
 package com.huawei.unibi.molap.util;
 
 import com.huawei.unibi.molap.datastorage.store.filesystem.MolapFile;
-import com.huawei.unibi.molap.keygenerator.KeyGenerator;
 
 public class MolapSliceAndFiles
 {
@@ -15,8 +14,6 @@ public class MolapSliceAndFiles
      */
     private MolapFile[] sliceFactFilesList;
     
-    private KeyGenerator keyGen;
-    
     /**
      * This method will return the slice path
      * 
@@ -60,21 +57,4 @@ public class MolapSliceAndFiles
     {
         this.sliceFactFilesList = sliceFactFilesList;
     }
-
-    /**
-     * @return the keyGen
-     */
-    public KeyGenerator getKeyGen()
-    {
-        return keyGen;
-    }
-
-    /**
-     * @param keyGen the keyGen to set
-     */
-    public void setKeyGen(KeyGenerator keyGen)
-    {
-        this.keyGen = keyGen;
-    }
-
 }
diff --git a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/RemoveDictionaryUtil.java b/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/RemoveDictionaryUtil.java
deleted file mode 100644
index c49ce75..0000000
--- a/Molap/Molap-Data-Processor/src/com/huawei/unibi/molap/util/RemoveDictionaryUtil.java
+++ /dev/null
@@ -1,401 +0,0 @@
-/**
- * 
- */
-package com.huawei.unibi.molap.util;
-
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.List;
-
-import com.huawei.unibi.molap.constants.IgnoreDictionary;
-import com.huawei.unibi.molap.constants.MolapCommonConstants;
-
-/**
- * This is the utility class for No Dictionary changes.
- * 
- * @author R00903928
- * 
- */
-public class RemoveDictionaryUtil
-{
-    /**
-     * Here we are dividing one single object [] into 3 arrays. one for
-     * dimensions , one for high card, one for measures.
-     * 
-     * @param out
-     * @param dimArray
-     * @param byteBufferArr
-     * @param measureArray
-     */
-    public static void prepareOut(Object[] newOutArr,
-            ByteBuffer[] byteBufferArr, Object[] out, int dimCount)
-    {
-
-        byte[] nonDictionaryCols = RemoveDictionaryUtil
-                .packByteBufferIntoSingleByteArray(byteBufferArr);
-        Integer[] dimArray = new Integer[dimCount];
-        for(int i = 0;i < dimCount;i++)
-        {
-            dimArray[i] = (Integer)out[i];
-        }
-
-        Double[] measureArray = new Double[out.length - dimCount];
-        int index = 0;
-        for(int j = dimCount;j < out.length;j++)
-        {
-            measureArray[index++] = (Double)out[j];
-        }
-
-        newOutArr[IgnoreDictionary.DIMENSION_INDEX_IN_ROW.getIndex()] = dimArray;
-        newOutArr[IgnoreDictionary.BYTE_ARRAY_INDEX_IN_ROW.getIndex()] = nonDictionaryCols;
-        newOutArr[IgnoreDictionary.MEASURES_INDEX_IN_ROW.getIndex()] = measureArray;
-
-    }
-
-    /**
-     * This method will form one single byte [] for all the high card dims.
-     * 
-     * @param byteBufferArr
-     * @return
-     */
-    public static byte[] packByteBufferIntoSingleByteArray(
-            ByteBuffer[] byteBufferArr)
-    {
-        // for empty array means there is no data to remove dictionary.
-        if(null == byteBufferArr || byteBufferArr.length == 0)
-        {
-            return null;
-        }
-        int noOfCol = byteBufferArr.length;
-        short toDetermineLengthOfByteArr = 2;
-        short offsetLen = (short)(noOfCol * 2 + toDetermineLengthOfByteArr);
-        int totalBytes = calculateTotalBytes(byteBufferArr) + offsetLen;
-
-        ByteBuffer buffer = ByteBuffer.allocate(totalBytes);
-
-        // write the length of the byte [] as first short
-        buffer.putShort((short)(totalBytes - toDetermineLengthOfByteArr));
-        // writing the offset of the first element.
-        buffer.putShort(offsetLen);
-
-        // prepare index for byte []
-        for(int index = 0;index < byteBufferArr.length - 1;index++)
-        {
-            ByteBuffer individualCol = byteBufferArr[index];
-            // short lengthOfbytes = individualCol.getShort();
-            int noOfBytes = individualCol.capacity();
-
-            buffer.putShort((short)(offsetLen + noOfBytes));
-            offsetLen += noOfBytes;
-            individualCol.rewind();
-        }
-
-        // put actual data.
-        for(int index = 0;index < byteBufferArr.length;index++)
-        {
-            ByteBuffer individualCol = byteBufferArr[index];
-            buffer.put(individualCol.array());
-        }
-
-        buffer.rewind();
-        return buffer.array();
-
-    }
-
-    /**
-     * To calculate the total bytes in byte Buffer[].
-     * 
-     * @param byteBufferArr
-     * @return
-     */
-    private static int calculateTotalBytes(ByteBuffer[] byteBufferArr)
-    {
-        int total = 0;
-        for(int index = 0;index < byteBufferArr.length;index++)
-        {
-            total += byteBufferArr[index].capacity();
-        }
-        return total;
-    }
-
-    /**
-     * Method to check whether entire row is empty or not.
-     * 
-     * @param row
-     * @return
-     */
-    public static boolean checkAllValuesForNull(Object[] row)
-    {
-        if(checkNullForDims(row[0]) && checkNullForDouble(row[2])
-                && null == row[1])
-        {
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * To check whether the measures are empty/null
-     * 
-     * @param object
-     * @return
-     */
-    private static boolean checkNullForDouble(Object object)
-    {
-        Double[] measures = (Double[])object;
-        for(Double measure : measures)
-        {
-            if(null != measure)
-            {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * To check whether the dimensions are empty/null
-     * 
-     * @param object
-     * @return
-     */
-    private static boolean checkNullForDims(Object object)
-    {
-        Integer[] dimensions = (Integer[])object;
-        for(Integer dimension : dimensions)
-        {
-            if(null != dimension)
-            {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Method to get the required Dimension from obj []
-     * 
-     * @param index
-     * @param row
-     * @return
-     */
-    public static Integer getDimension(int index, Object[] row)
-    {
-
-        Integer[] dimensions = (Integer[])row[IgnoreDictionary.DIMENSION_INDEX_IN_ROW.getIndex()];
-
-        return dimensions[index];
-
-    }
-
-    /**
-     * Method to get the required measure from obj []
-     * 
-     * @param index
-     * @param row
-     * @return
-     */
-    public static Double getMeasure(int index, Object[] row)
-    {
-        Double[] measures = (Double[])row[IgnoreDictionary.MEASURES_INDEX_IN_ROW.getIndex()];
-        return measures[index];
-    }
-
-    /**
-     * 
-     * @param row
-     * @return
-     */
-    public static byte[] getByteArrayForNoDictionaryCols(Object[] row)
-    {
-
-        return (byte[])row[IgnoreDictionary.BYTE_ARRAY_INDEX_IN_ROW.getIndex()];
-    }
-
-    /**
-     * 
-     * @param out
-     * @param dimArray
-     * @param byteBufferArr
-     * @param measureArray
-     */
-    public static void prepareOutObj(Object[] out, Integer[] dimArray,
-            byte[] byteBufferArr, Double[] measureArray)
-    {
-
-        out[IgnoreDictionary.DIMENSION_INDEX_IN_ROW.getIndex()] = dimArray;
-        out[IgnoreDictionary.BYTE_ARRAY_INDEX_IN_ROW.getIndex()] = byteBufferArr;
-        out[IgnoreDictionary.MEASURES_INDEX_IN_ROW.getIndex()] = measureArray;
-
-    }
-
-    /**
-     * 
-     * @param row
-     * @return
-     */
-    public static Integer[] getCompleteDimensions(Object[] row)
-    {
-
-        return (Integer[])row[0];
-    }
-
-    /**
-     * This will extract the high cardinality count from the string.
-     * 
-     * @param highCardinalityDims2
-     */
-    public static int extractHighCardCount(String highCardinalityDim)
-    {
-        
-        if(null == highCardinalityDim)
-        {
-            return 0;
-        }
-        
-        String[] highCard = highCardinalityDim
-                .split(MolapCommonConstants.COMA_SPC_CHARACTER);
-        int[] highCardDimsLocal = new int[highCard.length];
-        List<String> list1 = new ArrayList<String>(
-                MolapCommonConstants.CONSTANT_SIZE_TEN);
-        // int[] lenshighCard = new int[highCard.length];
-
-        for(int i = 0;i < highCardDimsLocal.length;i++)
-        {
-            String[] dim = highCard[i]
-                    .split(MolapCommonConstants.COLON_SPC_CHARACTER);
-            list1.add(dim[0]);
-            highCardDimsLocal[i] = Integer.parseInt(dim[1]);
-            Integer.parseInt(dim[2]);
-
-        }
-
-        return list1.toArray(new String[list1.size()]).length;
-    }
-
-    /**
-     * This method will split one single byte array of high card dims into array
-     * of byte arrays.
-     * 
-     * @param highCardArr
-     * @param highCardCount
-     * @return
-     */
-    public static byte[][] splitHighCardKey(byte[] highCardArr,
-            int highCardCount)
-    {
-        byte[][] split = new byte[highCardCount][];
-
-        ByteBuffer buff = ByteBuffer.wrap(highCardArr, 2, highCardCount * 2);
-
-        int remainingCol = highCardCount;
-        short secIndex = 0;
-        short firstIndex = 0;
-        for(int i = 0;i < highCardCount;i++)
-        {
-            
-            if(remainingCol == 1)
-            {
-                firstIndex = buff.getShort();
-                int length = highCardArr.length - firstIndex;
-
-                // add 2 bytes (short) as length required to determine size of
-                // each column value.
-
-                split[i] = new byte[length + 2];
-                ByteBuffer splittedCol = ByteBuffer.wrap(split[i]);
-                splittedCol.putShort((short)length);
-
-                System.arraycopy(highCardArr, firstIndex, split[i], 2, length);
-
-            }
-            else
-            {
-
-                firstIndex = buff.getShort();
-                secIndex = buff.getShort();
-                int length = secIndex - firstIndex;
-
-                // add 2 bytes (short) as length required to determine size of
-                // each column value.
-
-                split[i] = new byte[length + 2];
-                ByteBuffer splittedCol = ByteBuffer.wrap(split[i]);
-                splittedCol.putShort((short)length);
-
-                System.arraycopy(highCardArr, firstIndex, split[i], 2, length);
-                buff.position(buff.position() - 2);
-
-            }
-            remainingCol--;
-        }
-
-        return split;
-    }
-
-    /**
-     * 
-     * @param index
-     * @param val
-     */
-    public static void setDimension(int index, int val, Object[] objArr)
-    {
-        Integer[] dimensions = (Integer[])objArr[IgnoreDictionary.DIMENSION_INDEX_IN_ROW.getIndex()];
-
-        dimensions[index] = val;
-
-    }
-    
-    /**
-     * This will extract the high cardinality count from the string.
-     * 
-     * @param highCardinalityDims2
-     */
-    public static String[] extractHighCardDimsArr(String highCardinalityDim)
-    {
-        
-        if(null == highCardinalityDim || highCardinalityDim.isEmpty())
-        {
-            return new String[0];
-        }
-        
-        String[] highCard = highCardinalityDim
-                .split(MolapCommonConstants.COMA_SPC_CHARACTER);
-        int[] highCardDimsLocal = new int[highCard.length];
-        List<String> list1 = new ArrayList<String>(
-                MolapCommonConstants.CONSTANT_SIZE_TEN);
-        // int[] lenshighCard = new int[highCard.length];
-
-        for(int i = 0;i < highCardDimsLocal.length;i++)
-        {
-            String[] dim = highCard[i]
-                    .split(MolapCommonConstants.COLON_SPC_CHARACTER);
-            list1.add(dim[0]);
-            highCardDimsLocal[i] = Integer.parseInt(dim[1]);
-            Integer.parseInt(dim[2]);
-
-        }
-
-        return list1.toArray(new String[list1.size()]);
-    }
-    /**
-     * 
-     * @param directSurrogateKeyList
-     * @return
-     */
-    public static byte[] convertListByteArrToSingleArr(
-            List<byte[]> directSurrogateKeyList)
-    {
-        ByteBuffer[] buffArr = new ByteBuffer[directSurrogateKeyList.size()];
-        int index = 0;
-        for(byte[] singleColVal : directSurrogateKeyList)
-        {
-            buffArr[index] = ByteBuffer.allocate(singleColVal.length);
-           buffArr[index].put(singleColVal);
-           buffArr[index++].rewind();
-        }
-        
-       return RemoveDictionaryUtil.packByteBufferIntoSingleByteArray(buffArr);
-        
-    }
-}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/MeasureAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/MeasureAggregator.java
index a0edaca..5a9c72d 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/MeasureAggregator.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/MeasureAggregator.java
@@ -1,159 +1,121 @@
-/*--------------------------------------------------------------------------------------------------------------------------*/
-/*!!Warning: This is a key information asset of Huawei Tech Co.,Ltd                                                         */
-/*CODEMARK:kOyQZYzjDpyGdBAEC2GaWmnksNUG9RKxzMKuuAYTdbJ5ajFrCnCGALet/FDi0nQqbEkSZoTs
-2wdXgejaKCr1dP3uE3wfvLHF9gW8+IdXbwdEVzw1icjfRowqz2DW4XzUpEhhSzBOwVynEHjc
-u0090fUfdjWEkccKe4Y/GlbooVMj1KehmvZGK5hDgAnVApUjAvQtlp8Lu0WseUP5anZyDBDh
-6kvDDAW/B/sKJeVCKc4vFsWCQAeKJIt78i2Q9FVTaS9c1SNsIZAmKxLVnR7+OQ==*/
-/*--------------------------------------------------------------------------------------------------------------------------*/
-/**
- *
- * Copyright Notice
- * =====================================
- * This file contains proprietary information of
- * Huawei Technologies India Pvt Ltd.
- * Copying or reproduction without prior written approval is prohibited.
- * Copyright (c) 2013
- * =====================================
- *
- */
 package com.huawei.unibi.molap.engine.aggregator;
 
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
 import java.io.Serializable;
+import java.math.BigDecimal;
 
-/**
- * Project Name NSE V3R7C00
- * 
- * Module Name : Molap Engine
- * 
- * Author K00900841
- * 
- * Created Date :13-May-2013 3:35:33 PM
- * 
- * FileName : MeasureAggregator.java
- * 
- * Class Description : MeasureAggregator interface. It will be implemented by
- * all the aggregator functions eg: sum, avg, max, min, etc, will be used for
- * aggregate the measure value based on kind of aggregator
- * 
- * Version 1.0
- */
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
 
 public interface MeasureAggregator extends Serializable,Comparable<MeasureAggregator>
 {
+
     /**
-     * Aggregate function which will aggregate the new value with older value
-     * 
+     * Below method will be used to aggregate the Double value 
+     *
      * @param newVal
-     *            new value
-     * @param key
-     *            mdkey
-     * @param offset
-     *            key offset
-     * @param length
-     *            length to be considered
-     * 
      */
-    void agg(double newVal, byte[] key, int offset, int length);
-    
-    
+    void agg(double newVal);
+
     /**
-     * Aggregate function which will aggregate the new value with older value
-     * 
+     * Below method will be used to aggregate the object value
+     *
      * @param newVal
-     *            new value
-     * @param key
-     *            mdkey
-     * @param offset
-     *            key offset
-     * @param length
-     *            length to be considered
-     * 
      */
-    void agg(Object newVal, byte[] key, int offset, int length);
-//    
-    byte[] getByteArray();
-    
+    void agg(Object newVal);
+
     /**
-     * Overloaded Aggregate function will be used for Aggregate tables because
-     * aggregate table will have fact_count as a measure.
-     * 
+     * Below method will be used to aggregate the value based on index 
      * @param newVal
-     *            new value
-     * @param factCount
-     *            total fact count
-     * 
+     * @param index
      */
-    void agg(double newVal, double factCount);
+    void agg(MolapReadDataHolder newVal,int index);
 
     /**
-     * This method will return the aggregated value of the measure
-     * 
-     * @return aggregated value
-     * 
-     * 
+     * Get the Serialize byte array 
+     * @return
+     */
+    byte[] getByteArray();
+
+
+    /**
+     * This method will be used to set the new value
+     *
+     * @param newValue
+     *
      */
-    double getValue();
+    void setNewValue(Object newValue);
 
     /**
      * This method return the object value of the MeasureAggregator
-     * 
+     *
      * @return aggregated value
-     * 
+     *
      */
     Object getValueObject();
 
     /**
+     * This method return the object value of the MeasureAggregator
+     *
+     * @return aggregated value
+     *
+     */
+    Double getDoubleValue();
+
+    /**
+     * This method return the object value of the MeasureAggregator
+     *
+     * @return aggregated value
+     *
+     */
+    Long getLongValue();
+
+    BigDecimal getBigDecimalValue();
+    /**
      * This method merge the aggregated value based on aggregator passed
-     * 
+     *
      * @param aggregator
      *            type of aggregator
-     * 
-     */
-    void merge(MeasureAggregator aggregator);
-    
-    /**
-     * This method will be used to set the new value
-     * 
-     * @param newValue
      *
      */
-    void setNewValue(double newValue);
-    
+    void merge(MeasureAggregator aggregator);
+
     /**
      * Is first time. It means it was never used for aggregating any value.
      * @return
      */
     boolean isFirstTime();
-    
+
     /**
      * it creates the new copy of MeasureAggregator
      * @return MeasureAggregator
      */
     MeasureAggregator getCopy();
-    
+
     /**
      * Write the state of the class to buffer
      * @param buffer
      */
     void writeData(DataOutput output) throws IOException;
-    
+
     /**
      * Read the state of the class and set to the object
      * @param buffer
      */
     void readData(DataInput inPut) throws IOException;
-    
+
+    /**
+     *
+     * @return
+     */
     MeasureAggregator get();
-    
+
     /**
      * Merge the byte arrays
-     * 
+     *
      * @param value
-     * 
+     *
      */
     void merge(byte[] value);
-    
 }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AbstractMeasureAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AbstractMeasureAggregator.java
index 61f43ac..9dbe7e6 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AbstractMeasureAggregator.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AbstractMeasureAggregator.java
@@ -103,13 +103,13 @@ public abstract class AbstractMeasureAggregator implements MeasureAggregator//,I
     }
      
     @Override
-    public void agg(double arg0, double arg1) 
+    public void agg(double arg0)
     {
 
     }
     
     @Override
-    public void setNewValue(double arg0) 
+    public void setNewValue(Object arg0)
     {
 
     }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgAggregator.java
deleted file mode 100644
index 9bdc201..0000000
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgAggregator.java
+++ /dev/null
@@ -1,297 +0,0 @@
-/*--------------------------------------------------------------------------------------------------------------------------*/
-/*!!Warning: This is a key information asset of Huawei Tech Co.,Ltd                                                         */
-/*CODEMARK:kOyQZYzjDpyGdBAEC2GaWmnksNUG9RKxzMKuuAYTdbJ5ajFrCnCGALet/FDi0nQqbEkSZoTs
-2wdXgejaKCr1dP3uE3wfvLHF9gW8+IdXbwdEVzw1icjfRowqz2DW4XzUpEhhSzBOwVynEHjc
-u0090YeyNJjyiBxlZZhvq198q+Px/O6umGvGwr5h9OKhpMctsfEvwH0Ku71ImcKU6VAJ7mHZ
-e2xQU1gqw8DAe8i5OCRnjPMmOC9dX8zPk/kKPGifGLgFauScMSF4Lt2p+I7MLQ==*/
-/*--------------------------------------------------------------------------------------------------------------------------*/
-/**
- *
- * Copyright Notice
- * =====================================
- * This file contains proprietary information of
- * Huawei Technologies India Pvt Ltd.
- * Copying or reproduction without prior written approval is prohibited.
- * Copyright (c) 2013
- * =====================================
- *
- */
-package com.huawei.unibi.molap.engine.aggregator.impl;
-
-import java.io.DataInput;
-import java.io.DataOutput;
-import java.io.IOException;
-
-import com.huawei.unibi.molap.constants.MolapCommonConstants;
-import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
-import java.nio.ByteBuffer;
-
-/**
- * Project Name NSE V3R7C00 
- * 
- * Module Name : Molap Engine
- * 
- * Author K00900841
- * 
- * Created Date :13-May-2013 3:35:33 PM
- * 
- * FileName : AvgAggregator.java
- * 
- * Class Description :
- * It will return average of aggregate values
- * 
- * Version 1.0
- */
-
-public class AvgAggregator implements MeasureAggregator
-{
-    
-    /**
-     * serialVersionUID
-     * 
-     */
-    private static final long serialVersionUID = 5463736686281089871L;
-
-    /**
-     * total number of aggregate values
-     */
-    protected double count;
-
-    /**
-     * aggregate value
-     */
-    protected double aggVal;
-    
-    /**
-     * 
-     */
-    protected boolean firstTime = true;
-
-    /**
-     * Average Aggregate function which will add all the aggregate values and it
-     * will increment the total count every time, for average value
-     * 
-     * @param newVal
-     *            new value
-     * @param key
-     *            mdkey
-     * @param offset
-     *            key offset
-     * @param length
-     *            length to be considered
-     * 
-     */
-    @Override
-    public void agg(double newVal, byte[] key, int offset, int length)
-    {
-        aggVal += newVal;
-        count++;
-        firstTime = false;
-    }
-    
-    /**
-     * Average Aggregate function which will add all the aggregate values and it
-     * will increment the total count every time, for average value
-     * 
-     * @param newVal
-     *            new value
-     * @param key
-     *            mdkey
-     * @param offset
-     *            key offset
-     * @param length
-     *            length to be considered
-     * 
-     */
-    @Override
-    public void agg(Object newVal, byte[] key, int offset, int length)
-    {
-        if(newVal instanceof byte[])
-        {
-            ByteBuffer buffer = ByteBuffer.wrap((byte[])newVal);
-            buffer.rewind();
-            //CHECKSTYLE:OFF    Approval No:Approval-V3R8C00_018
-            while(buffer.hasRemaining())
-            { //CHECKSTYLE:ON
-               aggVal+=buffer.getDouble();
-               count+=buffer.getDouble();
-               firstTime = false;
-            }            
-            return;
-        }
-        aggVal += (Double)newVal;
-        count++;
-        firstTime = false;
-    }
-
-    /**
-     * Below method will be used to get the value byte array
-     */
-    @Override
-    public byte[] getByteArray()
-    {
-        if(firstTime)
-        {
-            return new byte[0];
-        }
-        ByteBuffer buffer = ByteBuffer.allocate(2 * MolapCommonConstants.DOUBLE_SIZE_IN_BYTE);
-        buffer.putDouble(aggVal);
-        buffer.putDouble(count);
-        return buffer.array();
-//        return null;
-    }
-
-    /**
-     * Return the average of the aggregate values
-     * 
-     * @return average aggregate value
-     *
-     */
-    @Override
-    public double getValue()
-    {
-
-        return aggVal / count;
-    }
-
-    /**
-     * This method merge the aggregated value, in average aggregator it will add
-     * count and aggregate value
-     * 
-     * @param aggregator
-     *            Avg Aggregator
-     * 
-     */
-    @Override
-    public void merge(MeasureAggregator aggregator)
-    {
-        AvgAggregator avgAggregator = (AvgAggregator)aggregator;
-        if(!avgAggregator.isFirstTime())
-        {
-            aggVal += avgAggregator.aggVal;
-            count += avgAggregator.count;
-            firstTime = false;
-        }
-    }
-
-    /**
-     * Overloaded Aggregate function will be used for Aggregate tables because
-     * aggregate table will have fact_count as a measure.
-     * 
-     * @param newVal
-     *          new value
-     * @param factCount
-     *          total fact count
-     * 
-     */
-    @Override
-    public void agg(double newVal, double factCount)
-    {
-        aggVal += newVal;
-        count += factCount;
-        firstTime = false;
-    }
-
-    /**
-     * This method return the average value as an object
-     * 
-     * @return average value as an object
-     */
-    @Override
-    public Object getValueObject()
-    {
-        // TODO Auto-generated method stub
-        return aggVal / count;
-    }
-
-    /**
-     * 
-     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(double)
-     * 
-     */
-    @Override
-    public void setNewValue(double newValue)
-    {
-        aggVal=newValue;
-        count = 1;
-    }
-
-    @Override
-    public boolean isFirstTime()
-    {
-        return firstTime;
-    }
-
-    @Override
-    public void writeData(DataOutput output) throws IOException
-    {
-        output.writeBoolean(firstTime);
-        output.writeDouble(aggVal);
-        output.writeDouble(count);
-        
-    }
-
-    @Override
-    public void readData(DataInput inPut) throws IOException
-    {
-        firstTime = inPut.readBoolean();
-        aggVal = inPut.readDouble();
-        count = inPut.readDouble();
-    }
-
-    @Override
-    public MeasureAggregator getCopy()
-    {
-        AvgAggregator avg = new AvgAggregator();
-        avg.aggVal = aggVal;
-        avg.count = count;
-        avg.firstTime = firstTime;
-        return avg;
-    }
-
-    //we are not comparing any Aggregator values
-    /*public boolean equals(MeasureAggregator msrAggregator){
-        return compareTo(msrAggregator)==0;
-    }*/
-    
-    @Override
-    public int compareTo(MeasureAggregator o)
-    {
-        double val = getValue();
-        double otherVal = o.getValue();
-        if(val > otherVal)
-        {
-            return 1;
-        }
-        if(val < otherVal)
-        {
-            return -1;
-        }
-        return 0;
-    }
-    
-    @Override
-    public MeasureAggregator get()
-    {
-        return this;
-    }   
-    
-    public String toString()
-    {
-        return (aggVal / count)+"";
-    }
-
-    @Override
-    public void merge(byte[] value)
-    {
-        if(0 == value.length)
-        {
-            return;
-        }
-        ByteBuffer buffer = ByteBuffer.wrap(value);
-        aggVal += buffer.getDouble();
-        count += buffer.getDouble();
-        firstTime = false;
-    }
-
-}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgBigDecimalAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgBigDecimalAggregator.java
new file mode 100644
index 0000000..cc46af2
--- /dev/null
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgBigDecimalAggregator.java
@@ -0,0 +1,318 @@
+/*--------------------------------------------------------------------------------------------------------------------------*/
+/*!!Warning: This is a key information asset of Huawei Tech Co.,Ltd                                                         */
+/*CODEMARK:kOyQZYzjDpyGdBAEC2GaWmnksNUG9RKxzMKuuAYTdbJ5ajFrCnCGALet/FDi0nQqbEkSZoTs
+2wdXgejaKCr1dP3uE3wfvLHF9gW8+IdXbwdEVzw1icjfRowqz2DW4XzUpEhhSzBOwVynEHjc
+u0090YeyNJjyiBxlZZhvq198q+Px/O6umGvGwr5h9OKhpMctsfEvwH0Ku71ImcKU6VAJ7mHZ
+e2xQU1gqw8DAe8i5OCRnjPMmOC9dX8zPk/kKPGifGLgFauScMSF4Lt2p+I7MLQ==*/
+/*--------------------------------------------------------------------------------------------------------------------------*/
+/**
+ *
+ * Copyright Notice
+ * =====================================
+ * This file contains proprietary information of
+ * Huawei Technologies India Pvt Ltd.
+ * Copying or reproduction without prior written approval is prohibited.
+ * Copyright (c) 2013
+ * =====================================
+ *
+ */
+package com.huawei.unibi.molap.engine.aggregator.impl;
+
+import com.huawei.unibi.molap.constants.MolapCommonConstants;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.nio.ByteBuffer;
+
+/**
+ * Project Name NSE V3R7C00 
+ *
+ * Module Name : Molap Engine
+ *
+ * Author K00900841
+ *
+ * Created Date :13-May-2013 3:35:33 PM
+ *
+ * FileName : AvgAggregator.java
+ *
+ * Class Description :
+ * It will return average of aggregate values
+ *
+ * Version 1.0
+ */
+
+public class AvgBigDecimalAggregator implements MeasureAggregator
+{
+
+    /**
+     * serialVersionUID
+     *
+     */
+    private static final long serialVersionUID = 5463736686281089871L;
+
+    /**
+     * total number of aggregate values
+     */
+    protected double count;
+
+    /**
+     * aggregate value
+     */
+    protected BigDecimal aggVal;
+
+    /**
+     *
+     */
+    protected boolean firstTime = true;
+
+    /**
+     * Average Aggregate function which will add all the aggregate values and it
+     * will increment the total count every time, for average value
+     *
+     * @param newVal
+     *            new value
+     *
+     */
+    @Override
+    public void agg(double newVal)
+    {
+//        aggVal = aggVal.add(new BigDecimal(newVal));
+//        count++;
+//        firstTime = false;
+    }
+
+    /**
+     * Average Aggregate function which will add all the aggregate values and it
+     * will increment the total count every time, for average value
+     *
+     * @param newVal
+     *            new value
+     *
+     */
+    @Override
+    public void agg(Object newVal)
+    {
+        if(newVal instanceof byte[])
+        {
+            ByteBuffer buffer = ByteBuffer.wrap((byte[])newVal);
+            buffer.rewind();
+            //CHECKSTYLE:OFF    Approval No:Approval-V3R8C00_018
+            while(buffer.hasRemaining())
+            { //CHECKSTYLE:ON
+                byte[] valueByte = new byte[buffer.getInt()];
+                buffer.get(valueByte);
+                BigDecimal valueBigDecimal = new BigDecimal(new String(valueByte));
+                aggVal = aggVal.add(valueBigDecimal);
+
+                count += buffer.getDouble();
+                firstTime = false;
+            }
+            return;
+        }
+        aggVal = aggVal.add((BigDecimal)newVal);
+        count++;
+        firstTime = false;
+    }
+
+    @Override
+    public void agg(MolapReadDataHolder newVal,int index)
+    {
+        byte[] value = newVal.getReadableByteArrayValueByIndex(index);
+        ByteBuffer buffer = ByteBuffer.wrap(value);
+        byte[] valueByte = new byte[buffer.getInt()];
+        buffer.get(valueByte);
+        BigDecimal valueBigDecimal = new BigDecimal(new String(valueByte));
+        aggVal = aggVal.add(valueBigDecimal);
+        count += buffer.getDouble();
+        firstTime = false;
+    }
+
+    /**
+     * Below method will be used to get the value byte array
+     */
+    @Override
+    public byte[] getByteArray()
+    {
+        if(firstTime)
+        {
+            return new byte[0];
+        }
+        byte[] bytes = aggVal.toString().getBytes();
+
+        ByteBuffer allocate = ByteBuffer.allocate(4 + bytes.length + MolapCommonConstants.DOUBLE_SIZE_IN_BYTE);
+
+        allocate.putInt(bytes.length);
+        allocate.put(bytes);
+        allocate.putDouble(count);
+        allocate.rewind();
+
+        return allocate.array();
+    }
+
+    /**
+     * Return the average of the aggregate values
+     *
+     * @return average aggregate value
+     *
+     */
+    @Override
+    public Double getDoubleValue()
+    {
+
+        return null;
+    }
+
+    @Override
+    public Long getLongValue()
+    {
+        return null;
+    }
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        return aggVal.divide(new BigDecimal(count));
+    }
+
+    /**
+     * This method merge the aggregated value, in average aggregator it will add
+     * count and aggregate value
+     *
+     * @param aggregator
+     *            Avg Aggregator
+     *
+     */
+    @Override
+    public void merge(MeasureAggregator aggregator)
+    {
+        AvgBigDecimalAggregator avgAggregator = (AvgBigDecimalAggregator)aggregator;
+        if(!avgAggregator.isFirstTime())
+        {
+            aggVal = aggVal.add(avgAggregator.aggVal);
+            count += avgAggregator.count;
+            firstTime = false;
+        }
+    }
+
+    /**
+     * Overloaded Aggregate function will be used for Aggregate tables because
+     * aggregate table will have fact_count as a measure.
+     *
+     * @param newVal
+     *          new value
+     * @param factCount
+     *          total fact count
+     *
+     */
+//    @Override
+//    public void agg(double newVal, double factCount)
+//    {
+//        aggVal += newVal;
+//        count += factCount;
+//        firstTime = false;
+//    }
+
+    /**
+     * This method return the average value as an object
+     *
+     * @return average value as an object
+     */
+    @Override
+    public Object getValueObject()
+    {
+        // TODO Auto-generated method stub
+        return aggVal.divide(new BigDecimal(count));
+    }
+
+    /**
+     *
+     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(Object)
+     *
+     */
+    @Override
+    public void setNewValue(Object newValue)
+    {
+        aggVal = (BigDecimal)newValue;
+        count = 1;
+    }
+
+    @Override
+    public boolean isFirstTime()
+    {
+        return firstTime;
+    }
+
+    @Override
+    public void writeData(DataOutput output) throws IOException
+    {
+        output.writeBoolean(firstTime);
+        output.writeUTF(aggVal.toString());
+        output.writeDouble(count);
+
+    }
+
+    @Override
+    public void readData(DataInput inPut) throws IOException
+    {
+        firstTime = inPut.readBoolean();
+        aggVal = new BigDecimal(inPut.readUTF());
+        count = inPut.readDouble();
+    }
+
+    @Override
+    public MeasureAggregator getCopy()
+    {
+        AvgBigDecimalAggregator avg = new AvgBigDecimalAggregator();
+        avg.aggVal = aggVal;
+        avg.count = count;
+        avg.firstTime = firstTime;
+        return avg;
+    }
+
+    //we are not comparing any Aggregator values
+    /*public boolean equals(MeasureAggregator msrAggregator){
+        return compareTo(msrAggregator)==0;
+    }*/
+
+    @Override
+    public int compareTo(MeasureAggregator o)
+    {
+        BigDecimal val = getBigDecimalValue();
+        BigDecimal otherVal = o.getBigDecimalValue();
+
+        return val.compareTo(otherVal);
+    }
+
+    @Override
+    public MeasureAggregator get()
+    {
+        return this;
+    }
+
+    public String toString()
+    {
+        return (aggVal.divide(new BigDecimal(count)))+"";
+    }
+
+    @Override
+    public void merge(byte[] value)
+    {
+        if(0 == value.length)
+        {
+            return;
+        }
+        ByteBuffer buffer = ByteBuffer.wrap(value);
+
+        byte[] valueByte = new byte[buffer.getInt()];
+        buffer.get(valueByte);
+        BigDecimal valueBigDecimal = new BigDecimal(new String(valueByte));
+        aggVal = aggVal.add(valueBigDecimal);
+        count += buffer.getDouble();
+        firstTime = false;
+    }
+
+}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgDoubleAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgDoubleAggregator.java
new file mode 100644
index 0000000..c1b15a7
--- /dev/null
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgDoubleAggregator.java
@@ -0,0 +1,309 @@
+/*--------------------------------------------------------------------------------------------------------------------------*/
+/*!!Warning: This is a key information asset of Huawei Tech Co.,Ltd                                                         */
+/*CODEMARK:kOyQZYzjDpyGdBAEC2GaWmnksNUG9RKxzMKuuAYTdbJ5ajFrCnCGALet/FDi0nQqbEkSZoTs
+2wdXgejaKCr1dP3uE3wfvLHF9gW8+IdXbwdEVzw1icjfRowqz2DW4XzUpEhhSzBOwVynEHjc
+u0090YeyNJjyiBxlZZhvq198q+Px/O6umGvGwr5h9OKhpMctsfEvwH0Ku71ImcKU6VAJ7mHZ
+e2xQU1gqw8DAe8i5OCRnjPMmOC9dX8zPk/kKPGifGLgFauScMSF4Lt2p+I7MLQ==*/
+/*--------------------------------------------------------------------------------------------------------------------------*/
+/**
+ *
+ * Copyright Notice
+ * =====================================
+ * This file contains proprietary information of
+ * Huawei Technologies India Pvt Ltd.
+ * Copying or reproduction without prior written approval is prohibited.
+ * Copyright (c) 2013
+ * =====================================
+ *
+ */
+package com.huawei.unibi.molap.engine.aggregator.impl;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import com.huawei.unibi.molap.constants.MolapCommonConstants;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+
+import java.math.BigDecimal;
+import java.nio.ByteBuffer;
+
+/**
+ * Project Name NSE V3R7C00 
+ *
+ * Module Name : Molap Engine
+ *
+ * Author K00900841
+ *
+ * Created Date :13-May-2013 3:35:33 PM
+ *
+ * FileName : AvgAggregator.java
+ *
+ * Class Description :
+ * It will return average of aggregate values
+ *
+ * Version 1.0
+ */
+
+public class AvgDoubleAggregator implements MeasureAggregator
+{
+
+    /**
+     * serialVersionUID
+     *
+     */
+    private static final long serialVersionUID = 5463736686281089871L;
+
+    /**
+     * total number of aggregate values
+     */
+    protected double count;
+
+    /**
+     * aggregate value
+     */
+    protected double aggVal;
+
+    /**
+     *
+     */
+    protected boolean firstTime = true;
+
+    /**
+     * Average Aggregate function which will add all the aggregate values and it
+     * will increment the total count every time, for average value
+     *
+     * @param newVal
+     *            new value
+     *
+     */
+    @Override
+    public void agg(double newVal)
+    {
+        aggVal += newVal;
+        count++;
+        firstTime = false;
+    }
+
+    /**
+     * Average Aggregate function which will add all the aggregate values and it
+     * will increment the total count every time, for average value
+     *
+     * @param newVal
+     *            new value
+     *
+     */
+    @Override
+    public void agg(Object newVal)
+    {
+        if(newVal instanceof byte[])
+        {
+            ByteBuffer buffer = ByteBuffer.wrap((byte[])newVal);
+            buffer.rewind();
+            //CHECKSTYLE:OFF    Approval No:Approval-V3R8C00_018
+            while(buffer.hasRemaining())
+            { //CHECKSTYLE:ON
+                aggVal+=buffer.getDouble();
+                count+=buffer.getDouble();
+                firstTime = false;
+            }
+            return;
+        }
+        aggVal += (Double)newVal;
+        count++;
+        firstTime = false;
+    }
+
+    @Override
+    public void agg(MolapReadDataHolder newVal,int index)
+    {
+        byte[] value = newVal.getReadableByteArrayValueByIndex(index);
+        ByteBuffer buffer = ByteBuffer.wrap(value);
+        aggVal += buffer.getDouble();
+        count += buffer.getDouble();
+        firstTime = false;
+    }
+
+    /**
+     * Below method will be used to get the value byte array
+     */
+    @Override
+    public byte[] getByteArray()
+    {
+        if(firstTime)
+        {
+            return new byte[0];
+        }
+        ByteBuffer buffer = ByteBuffer.allocate(2 * MolapCommonConstants.DOUBLE_SIZE_IN_BYTE);
+        buffer.putDouble(aggVal);
+        buffer.putDouble(count);
+        return buffer.array();
+    }
+
+    /**
+     * Return the average of the aggregate values
+     *
+     * @return average aggregate value
+     *
+     */
+    @Override
+    public Double getDoubleValue()
+    {
+
+        return aggVal / count;
+    }
+
+    @Override
+    public Long getLongValue()
+    {
+        return null;
+    }
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        return null;
+    }
+
+    /**
+     * This method merge the aggregated value, in average aggregator it will add
+     * count and aggregate value
+     *
+     * @param aggregator
+     *            Avg Aggregator
+     *
+     */
+    @Override
+    public void merge(MeasureAggregator aggregator)
+    {
+        AvgDoubleAggregator avgAggregator = (AvgDoubleAggregator)aggregator;
+        if(!avgAggregator.isFirstTime())
+        {
+            aggVal += avgAggregator.aggVal;
+            count += avgAggregator.count;
+            firstTime = false;
+        }
+    }
+
+    /**
+     * Overloaded Aggregate function will be used for Aggregate tables because
+     * aggregate table will have fact_count as a measure.
+     *
+     * @param newVal
+     *          new value
+     * @param factCount
+     *          total fact count
+     *
+     */
+//    @Override
+//    public void agg(double newVal, double factCount)
+//    {
+//        aggVal += newVal;
+//        count += factCount;
+//        firstTime = false;
+//    }
+
+    /**
+     * This method return the average value as an object
+     *
+     * @return average value as an object
+     */
+    @Override
+    public Object getValueObject()
+    {
+        // TODO Auto-generated method stub
+        return aggVal / count;
+    }
+
+    /**
+     *
+     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(Object)
+     *
+     */
+    @Override
+    public void setNewValue(Object newValue)
+    {
+        aggVal = (Double)newValue;
+        count = 1;
+    }
+
+    @Override
+    public boolean isFirstTime()
+    {
+        return firstTime;
+    }
+
+    @Override
+    public void writeData(DataOutput output) throws IOException
+    {
+        output.writeBoolean(firstTime);
+        output.writeDouble(aggVal);
+        output.writeDouble(count);
+
+    }
+
+    @Override
+    public void readData(DataInput inPut) throws IOException
+    {
+        firstTime = inPut.readBoolean();
+        aggVal = inPut.readDouble();
+        count = inPut.readDouble();
+    }
+
+    @Override
+    public MeasureAggregator getCopy()
+    {
+        AvgDoubleAggregator avg = new AvgDoubleAggregator();
+        avg.aggVal = aggVal;
+        avg.count = count;
+        avg.firstTime = firstTime;
+        return avg;
+    }
+
+    //we are not comparing any Aggregator values
+    /*public boolean equals(MeasureAggregator msrAggregator){
+        return compareTo(msrAggregator)==0;
+    }*/
+
+    @Override
+    public int compareTo(MeasureAggregator o)
+    {
+        double val = getDoubleValue();
+        double otherVal = o.getDoubleValue();
+        if(val > otherVal)
+        {
+            return 1;
+        }
+        if(val < otherVal)
+        {
+            return -1;
+        }
+        return 0;
+    }
+
+    @Override
+    public MeasureAggregator get()
+    {
+        return this;
+    }
+
+    public String toString()
+    {
+        return (aggVal / count)+"";
+    }
+
+    @Override
+    public void merge(byte[] value)
+    {
+        if(0 == value.length)
+        {
+            return;
+        }
+        ByteBuffer buffer = ByteBuffer.wrap(value);
+        aggVal += buffer.getDouble();
+        count += buffer.getDouble();
+        firstTime = false;
+    }
+
+}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgLongAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgLongAggregator.java
new file mode 100644
index 0000000..bcd2781
--- /dev/null
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgLongAggregator.java
@@ -0,0 +1,309 @@
+/*--------------------------------------------------------------------------------------------------------------------------*/
+/*!!Warning: This is a key information asset of Huawei Tech Co.,Ltd                                                         */
+/*CODEMARK:kOyQZYzjDpyGdBAEC2GaWmnksNUG9RKxzMKuuAYTdbJ5ajFrCnCGALet/FDi0nQqbEkSZoTs
+2wdXgejaKCr1dP3uE3wfvLHF9gW8+IdXbwdEVzw1icjfRowqz2DW4XzUpEhhSzBOwVynEHjc
+u0090YeyNJjyiBxlZZhvq198q+Px/O6umGvGwr5h9OKhpMctsfEvwH0Ku71ImcKU6VAJ7mHZ
+e2xQU1gqw8DAe8i5OCRnjPMmOC9dX8zPk/kKPGifGLgFauScMSF4Lt2p+I7MLQ==*/
+/*--------------------------------------------------------------------------------------------------------------------------*/
+/**
+ *
+ * Copyright Notice
+ * =====================================
+ * This file contains proprietary information of
+ * Huawei Technologies India Pvt Ltd.
+ * Copying or reproduction without prior written approval is prohibited.
+ * Copyright (c) 2013
+ * =====================================
+ *
+ */
+package com.huawei.unibi.molap.engine.aggregator.impl;
+
+import com.huawei.unibi.molap.constants.MolapCommonConstants;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.nio.ByteBuffer;
+
+/**
+ * Project Name NSE V3R7C00 
+ *
+ * Module Name : Molap Engine
+ *
+ * Author K00900841
+ *
+ * Created Date :13-May-2013 3:35:33 PM
+ *
+ * FileName : AvgAggregator.java
+ *
+ * Class Description :
+ * It will return average of aggregate values
+ *
+ * Version 1.0
+ */
+
+public class AvgLongAggregator implements MeasureAggregator
+{
+
+    /**
+     * serialVersionUID
+     *
+     */
+    private static final long serialVersionUID = 5463736686281089871L;
+
+    /**
+     * total number of aggregate values
+     */
+    protected double count;
+
+    /**
+     * aggregate value
+     */
+    protected long aggVal;
+
+    /**
+     *
+     */
+    protected boolean firstTime = true;
+
+    /**
+     * Average Aggregate function which will add all the aggregate values and it
+     * will increment the total count every time, for average value
+     *
+     * @param newVal
+     *            new value
+     *
+     */
+    @Override
+    public void agg(double newVal)
+    {
+//        aggVal += newVal;
+//        count++;
+//        firstTime = false;
+    }
+
+    /**
+     * Average Aggregate function which will add all the aggregate values and it
+     * will increment the total count every time, for average value
+     *
+     * @param newVal
+     *            new value
+     *
+     */
+    @Override
+    public void agg(Object newVal)
+    {
+        if(newVal instanceof byte[])
+        {
+            ByteBuffer buffer = ByteBuffer.wrap((byte[])newVal);
+            buffer.rewind();
+            //CHECKSTYLE:OFF    Approval No:Approval-V3R8C00_018
+            while(buffer.hasRemaining())
+            { //CHECKSTYLE:ON
+                aggVal += buffer.getLong();
+                count += buffer.getDouble();
+                firstTime = false;
+            }
+            return;
+        }
+        aggVal += (Long)newVal;
+        count++;
+        firstTime = false;
+    }
+
+    @Override
+    public void agg(MolapReadDataHolder newVal,int index)
+    {
+        byte[] value = newVal.getReadableByteArrayValueByIndex(index);
+        ByteBuffer buffer = ByteBuffer.wrap(value);
+        aggVal += buffer.getLong();
+        count += buffer.getDouble();
+        firstTime = false;
+    }
+
+    /**
+     * Below method will be used to get the value byte array
+     */
+    @Override
+    public byte[] getByteArray()
+    {
+        if(firstTime)
+        {
+            return new byte[0];
+        }
+        ByteBuffer buffer = ByteBuffer.allocate(MolapCommonConstants.LONG_SIZE_IN_BYTE
+                + MolapCommonConstants.DOUBLE_SIZE_IN_BYTE);
+        buffer.putLong(aggVal);
+        buffer.putDouble(count);
+        return buffer.array();
+    }
+
+    /**
+     * Return the average of the aggregate values
+     *
+     * @return average aggregate value
+     *
+     */
+    @Override
+    public Double getDoubleValue()
+    {
+
+        return null;
+    }
+
+    @Override
+    public Long getLongValue()
+    {
+        return aggVal / (long)count;
+    }
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        return null;
+    }
+
+    /**
+     * This method merge the aggregated value, in average aggregator it will add
+     * count and aggregate value
+     *
+     * @param aggregator
+     *            Avg Aggregator
+     *
+     */
+    @Override
+    public void merge(MeasureAggregator aggregator)
+    {
+        AvgLongAggregator avgAggregator = (AvgLongAggregator)aggregator;
+        if(!avgAggregator.isFirstTime())
+        {
+            aggVal += avgAggregator.aggVal;
+            count += avgAggregator.count;
+            firstTime = false;
+        }
+    }
+
+    /**
+     * Overloaded Aggregate function will be used for Aggregate tables because
+     * aggregate table will have fact_count as a measure.
+     *
+     * @param newVal
+     *          new value
+     * @param factCount
+     *          total fact count
+     *
+     */
+//    @Override
+//    public void agg(double newVal, double factCount)
+//    {
+//        aggVal += newVal;
+//        count += factCount;
+//        firstTime = false;
+//    }
+
+    /**
+     * This method return the average value as an object
+     *
+     * @return average value as an object
+     */
+    @Override
+    public Object getValueObject()
+    {
+        // TODO Auto-generated method stub
+        return aggVal / count;
+    }
+
+    /**
+     *
+     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(Object)
+     *
+     */
+    @Override
+    public void setNewValue(Object newValue)
+    {
+        aggVal = (Long)newValue;
+        count = 1;
+    }
+
+    @Override
+    public boolean isFirstTime()
+    {
+        return firstTime;
+    }
+
+    @Override
+    public void writeData(DataOutput output) throws IOException
+    {
+        output.writeBoolean(firstTime);
+        output.writeLong(aggVal);
+        output.writeDouble(count);
+
+    }
+
+    @Override
+    public void readData(DataInput inPut) throws IOException
+    {
+        firstTime = inPut.readBoolean();
+        aggVal = inPut.readLong();
+        count = inPut.readDouble();
+    }
+
+    @Override
+    public MeasureAggregator getCopy()
+    {
+        AvgLongAggregator avg = new AvgLongAggregator();
+        avg.aggVal = aggVal;
+        avg.count = count;
+        avg.firstTime = firstTime;
+        return avg;
+    }
+
+    //we are not comparing any Aggregator values
+    /*public boolean equals(MeasureAggregator msrAggregator){
+        return compareTo(msrAggregator)==0;
+    }*/
+
+    @Override
+    public int compareTo(MeasureAggregator o)
+    {
+        long val = getLongValue();
+        long otherVal = o.getLongValue();
+        if(val > otherVal)
+        {
+            return 1;
+        }
+        if(val < otherVal)
+        {
+            return -1;
+        }
+        return 0;
+    }
+
+    @Override
+    public MeasureAggregator get()
+    {
+        return this;
+    }
+
+    public String toString()
+    {
+        return (aggVal / count)+"";
+    }
+
+    @Override
+    public void merge(byte[] value)
+    {
+        if(0 == value.length)
+        {
+            return;
+        }
+        ByteBuffer buffer = ByteBuffer.wrap(value);
+        aggVal += buffer.getLong();
+        count += buffer.getDouble();
+        firstTime = false;
+    }
+
+}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgOfAvgAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgOfAvgAggregator.java
deleted file mode 100644
index c8b69dd..0000000
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgOfAvgAggregator.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*--------------------------------------------------------------------------------------------------------------------------*/
-/*!!Warning: This is a key information asset of Huawei Tech Co.,Ltd                                                         */
-/*CODEMARK:kOyQZYzjDpyGdBAEC2GaWmnksNUG9RKxzMKuuAYTdbJ5ajFrCnCGALet/FDi0nQqbEkSZoTs
-2wdXgejaKCr1dP3uE3wfvLHF9gW8+IdXbwdEVzw1icjfRowqz2DW4XzUpEhhSzBOwVynEHjc
-u0090SI2vhQLZdN9xXYHEupl+nhkRgKlnd278HRtGfXkaEXPvEML++W+rNhsQQATOGLh7fNE
-dMQGS+xtKYZbQzG/f9W5WuvVcGSOyC1WRBfsYwKXUO3qTMgVm3zWpPaZP9EA5Q==*/
-/*--------------------------------------------------------------------------------------------------------------------------*/
-/**
- *
- * Copyright Notice
- * =====================================
- * This file contains proprietary information of
- * Huawei Technologies India Pvt Ltd.
- * Copying or reproduction without prior written approval is prohibited.
- * Copyright (c) 2013
- * =====================================
- *
- */
-package com.huawei.unibi.molap.engine.aggregator.impl;
-
-
-/**
- * Project Name NSE V3R7C00
- * 
- * Module Name : Molap Engine
- * 
- * Author K00900841
- * 
- * Created Date :13-May-2013 3:35:33 PM
- * 
- * FileName : AvgOfAvgAggregator.java
- * 
- * Class Description : This class will be used for aggregate tables. It is
- * overriding agg method. It will be used for getting the average of fact
- * count(average value)
- * 
- * Version 1.0
- */
-
-public class AvgOfAvgAggregator extends AvgAggregator
-{
-
-    /**
-     * 
-     *serialVersionUID
-     * 
-     */
-    private static final long serialVersionUID = 6482976744603672084L;
-
-    /**
-     * Overloaded Aggregate function will be used for Aggregate tables because
-     * aggregate table will have fact_count as a measure.
-     * 
-     * @param newVal
-     *          new value
-     * @param factCount
-     *          total fact count
-     * 
-     */
-    @Override
-    public void agg(double newVal, double factCount)
-    {
-        aggVal += (newVal * factCount);
-        count += factCount;
-        firstTime = false;
-    }
-
-}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgOfAvgBigDecimalAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgOfAvgBigDecimalAggregator.java
new file mode 100644
index 0000000..e122ba2
--- /dev/null
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgOfAvgBigDecimalAggregator.java
@@ -0,0 +1,79 @@
+/*--------------------------------------------------------------------------------------------------------------------------*/
+/*!!Warning: This is a key information asset of Huawei Tech Co.,Ltd                                                         */
+/*CODEMARK:kOyQZYzjDpyGdBAEC2GaWmnksNUG9RKxzMKuuAYTdbJ5ajFrCnCGALet/FDi0nQqbEkSZoTs
+2wdXgejaKCr1dP3uE3wfvLHF9gW8+IdXbwdEVzw1icjfRowqz2DW4XzUpEhhSzBOwVynEHjc
+u0090SI2vhQLZdN9xXYHEupl+nhkRgKlnd278HRtGfXkaEXPvEML++W+rNhsQQATOGLh7fNE
+dMQGS+xtKYZbQzG/f9W5WuvVcGSOyC1WRBfsYwKXUO3qTMgVm3zWpPaZP9EA5Q==*/
+/*--------------------------------------------------------------------------------------------------------------------------*/
+/**
+ *
+ * Copyright Notice
+ * =====================================
+ * This file contains proprietary information of
+ * Huawei Technologies India Pvt Ltd.
+ * Copying or reproduction without prior written approval is prohibited.
+ * Copyright (c) 2013
+ * =====================================
+ *
+ */
+package com.huawei.unibi.molap.engine.aggregator.impl;
+
+
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+
+import java.math.BigDecimal;
+import java.nio.ByteBuffer;
+
+/**
+ * Project Name NSE V3R7C00
+ * 
+ * Module Name : Molap Engine
+ * 
+ * Author K00900841
+ * 
+ * Created Date :13-May-2013 3:35:33 PM
+ * 
+ * FileName : AvgOfAvgAggregator.java
+ * 
+ * Class Description : This class will be used for aggregate tables. It is
+ * overriding agg method. It will be used for getting the average of fact
+ * count(average value)
+ * 
+ * Version 1.0
+ */
+
+public class AvgOfAvgBigDecimalAggregator extends AvgBigDecimalAggregator
+{
+
+    /**
+     * 
+     *serialVersionUID
+     * 
+     */
+    private static final long serialVersionUID = 6482976744603672084L;
+
+    /**
+     * Overloaded Aggregate function will be used for Aggregate tables because
+     * aggregate table will have fact_count as a measure.
+     * 
+     * @param newVal
+     *          new value
+     * @param index
+     *          index
+     * 
+     */
+    @Override
+    public void agg(MolapReadDataHolder newVal,int index)
+    {
+        byte[] value = newVal.getReadableByteArrayValueByIndex(index);
+        ByteBuffer buffer = ByteBuffer.wrap(value);
+        byte[] valueByte = new byte[buffer.getInt()];
+        buffer.get(valueByte);
+        BigDecimal newValue = new BigDecimal(new String(valueByte));
+        double factCount = buffer.getDouble();
+        aggVal = aggVal.add(newValue.multiply(new BigDecimal(factCount)));
+        count += factCount;
+        firstTime = false;
+    }
+
+}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgOfAvgDoubleAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgOfAvgDoubleAggregator.java
new file mode 100644
index 0000000..817747f
--- /dev/null
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgOfAvgDoubleAggregator.java
@@ -0,0 +1,76 @@
+/*--------------------------------------------------------------------------------------------------------------------------*/
+/*!!Warning: This is a key information asset of Huawei Tech Co.,Ltd                                                         */
+/*CODEMARK:kOyQZYzjDpyGdBAEC2GaWmnksNUG9RKxzMKuuAYTdbJ5ajFrCnCGALet/FDi0nQqbEkSZoTs
+2wdXgejaKCr1dP3uE3wfvLHF9gW8+IdXbwdEVzw1icjfRowqz2DW4XzUpEhhSzBOwVynEHjc
+u0090SI2vhQLZdN9xXYHEupl+nhkRgKlnd278HRtGfXkaEXPvEML++W+rNhsQQATOGLh7fNE
+dMQGS+xtKYZbQzG/f9W5WuvVcGSOyC1WRBfsYwKXUO3qTMgVm3zWpPaZP9EA5Q==*/
+/*--------------------------------------------------------------------------------------------------------------------------*/
+/**
+ *
+ * Copyright Notice
+ * =====================================
+ * This file contains proprietary information of
+ * Huawei Technologies India Pvt Ltd.
+ * Copying or reproduction without prior written approval is prohibited.
+ * Copyright (c) 2013
+ * =====================================
+ *
+ */
+package com.huawei.unibi.molap.engine.aggregator.impl;
+
+
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+
+import java.nio.ByteBuffer;
+
+/**
+ * Project Name NSE V3R7C00
+ * 
+ * Module Name : Molap Engine
+ * 
+ * Author K00900841
+ * 
+ * Created Date :13-May-2013 3:35:33 PM
+ * 
+ * FileName : AvgOfAvgAggregator.java
+ * 
+ * Class Description : This class will be used for aggregate tables. It is
+ * overriding agg method. It will be used for getting the average of fact
+ * count(average value)
+ * 
+ * Version 1.0
+ */
+
+public class AvgOfAvgDoubleAggregator extends AvgDoubleAggregator
+{
+
+    /**
+     * 
+     *serialVersionUID
+     * 
+     */
+    private static final long serialVersionUID = 6482976744603672084L;
+
+    /**
+     * Overloaded Aggregate function will be used for Aggregate tables because
+     * aggregate table will have fact_count as a measure.
+     * 
+     * @param newVal
+     *          new value
+     * @param index
+     *          index
+     * 
+     */
+    @Override
+    public void agg(MolapReadDataHolder newVal,int index)
+    {
+        byte[] value = newVal.getReadableByteArrayValueByIndex(index);
+        ByteBuffer buffer = ByteBuffer.wrap(value);
+        double newValue = buffer.getDouble();
+        double factCount = buffer.getDouble();
+        aggVal += (newValue * factCount);
+        count += factCount;
+        firstTime = false;
+    }
+
+}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgOfAvgLongAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgOfAvgLongAggregator.java
new file mode 100644
index 0000000..567f504
--- /dev/null
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/AvgOfAvgLongAggregator.java
@@ -0,0 +1,76 @@
+/*--------------------------------------------------------------------------------------------------------------------------*/
+/*!!Warning: This is a key information asset of Huawei Tech Co.,Ltd                                                         */
+/*CODEMARK:kOyQZYzjDpyGdBAEC2GaWmnksNUG9RKxzMKuuAYTdbJ5ajFrCnCGALet/FDi0nQqbEkSZoTs
+2wdXgejaKCr1dP3uE3wfvLHF9gW8+IdXbwdEVzw1icjfRowqz2DW4XzUpEhhSzBOwVynEHjc
+u0090SI2vhQLZdN9xXYHEupl+nhkRgKlnd278HRtGfXkaEXPvEML++W+rNhsQQATOGLh7fNE
+dMQGS+xtKYZbQzG/f9W5WuvVcGSOyC1WRBfsYwKXUO3qTMgVm3zWpPaZP9EA5Q==*/
+/*--------------------------------------------------------------------------------------------------------------------------*/
+/**
+ *
+ * Copyright Notice
+ * =====================================
+ * This file contains proprietary information of
+ * Huawei Technologies India Pvt Ltd.
+ * Copying or reproduction without prior written approval is prohibited.
+ * Copyright (c) 2013
+ * =====================================
+ *
+ */
+package com.huawei.unibi.molap.engine.aggregator.impl;
+
+
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+
+import java.nio.ByteBuffer;
+
+/**
+ * Project Name NSE V3R7C00
+ * 
+ * Module Name : Molap Engine
+ * 
+ * Author K00900841
+ * 
+ * Created Date :13-May-2013 3:35:33 PM
+ * 
+ * FileName : AvgOfAvgAggregator.java
+ * 
+ * Class Description : This class will be used for aggregate tables. It is
+ * overriding agg method. It will be used for getting the average of fact
+ * count(average value)
+ * 
+ * Version 1.0
+ */
+
+public class AvgOfAvgLongAggregator extends AvgLongAggregator
+{
+
+    /**
+     * 
+     *serialVersionUID
+     * 
+     */
+    private static final long serialVersionUID = 6482976744603672084L;
+
+    /**
+     * Overloaded Aggregate function will be used for Aggregate tables because
+     * aggregate table will have fact_count as a measure.
+     * 
+     * @param newVal
+     *          new value
+     * @param index
+     *          index
+     * 
+     */
+    @Override
+    public void agg(MolapReadDataHolder newVal,int index)
+    {
+        byte[] value = newVal.getReadableByteArrayValueByIndex(index);
+        ByteBuffer buffer = ByteBuffer.wrap(value);
+        double newValue = buffer.getLong();
+        double factCount = buffer.getDouble();
+        aggVal += (newValue * factCount);
+        count += factCount;
+        firstTime = false;
+    }
+
+}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/CalculatedMeasureAggregatorImpl.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/CalculatedMeasureAggregatorImpl.java
index e36e68f..2034ea0 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/CalculatedMeasureAggregatorImpl.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/CalculatedMeasureAggregatorImpl.java
@@ -13,7 +13,9 @@ package com.huawei.unibi.molap.engine.aggregator.impl;
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
+import java.math.BigDecimal;
 
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
 import com.huawei.unibi.molap.engine.aggregator.CalculatedMeasureAggregator;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 import com.huawei.unibi.molap.engine.executer.calcexp.MolapCalcFunction;
@@ -48,21 +50,21 @@ public class CalculatedMeasureAggregatorImpl implements CalculatedMeasureAggrega
     }
 
     @Override
-    public void agg(double newVal, byte[] key, int offset, int length)
+    public void agg(double newVal)
     {
         
     }
 
     @Override
-    public void agg(double newVal, double factCount)
+    public void agg(MolapReadDataHolder newVal, int index)
     {
-       
-        
+
     }
     
     @Override
-    public void agg(Object newVal, byte[] key, int offset, int length)
+    public void agg(Object newVal)
     {
+
     }
 
     @Override
@@ -71,13 +73,30 @@ public class CalculatedMeasureAggregatorImpl implements CalculatedMeasureAggrega
         return null;
     }
 
+//    @Override
+//    public double getValue()
+//    {
+//        return val;
+//    }
     @Override
-    public double getValue()
+    public Double getDoubleValue()
     {
         return val;
     }
 
     @Override
+    public Long getLongValue()
+    {
+        return (long)val;
+    }
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        return new BigDecimal(val);
+    }
+
+    @Override
     public Object getValueObject()
     {
         // TODO Auto-generated method stub
@@ -92,10 +111,10 @@ public class CalculatedMeasureAggregatorImpl implements CalculatedMeasureAggrega
     }
 
     @Override
-    public void setNewValue(double newValue)
+    public void setNewValue(Object newValue)
     {
         // TODO Auto-generated method stub
-        
+
     }
 
     @Override
@@ -138,8 +157,8 @@ public class CalculatedMeasureAggregatorImpl implements CalculatedMeasureAggrega
     @Override
     public int compareTo(MeasureAggregator msrObj) 
     {
-        double msrVal1 = getValue();    
-        double otherMsrVal1 = msrObj.getValue(); 
+        double msrVal1 = getDoubleValue();
+        double otherMsrVal1 = msrObj.getDoubleValue();
         if(msrVal1 > otherMsrVal1)
         {
             return 1;
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/CountAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/CountAggregator.java
index 6c693ba..3f1b8e0 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/CountAggregator.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/CountAggregator.java
@@ -21,9 +21,11 @@ package com.huawei.unibi.molap.engine.aggregator.impl;
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
+import java.math.BigDecimal;
 import java.nio.ByteBuffer;
 
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 
 /**
@@ -61,16 +63,10 @@ public class CountAggregator implements MeasureAggregator
      * 
      * @param newVal
      *            new value
-     * @param key
-     *            mdkey
-     * @param offset
-     *            key offset
-     * @param length
-     *            length to be considered
      * 
      */
     @Override
-    public void agg(double newVal, byte[] key, int offset, int length)
+    public void agg(double newVal)
     {
         aggVal++;
     }
@@ -80,16 +76,17 @@ public class CountAggregator implements MeasureAggregator
      * 
      * @param newVal
      *            new value
-     * @param key
-     *            mdkey
-     * @param offset
-     *            key offset
-     * @param length
-     *            length to be considered
      * 
      */
     @Override
-    public void agg(Object newVal, byte[] key, int offset, int length)
+    public void agg(Object newVal)
+    {
+        aggVal++;
+    }
+
+
+    @Override
+    public void agg(MolapReadDataHolder newVal,int index)
     {
         aggVal++;
     }
@@ -112,15 +109,27 @@ public class CountAggregator implements MeasureAggregator
      * 
      */
     @Override
-    public double getValue()
+    public Double getDoubleValue()
     {
         return aggVal;
     }
 
+    @Override
+    public Long getLongValue()
+    {
+        return (long)aggVal;
+    }
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        return new BigDecimal(aggVal);
+    }
+
     /**
      * Merge the total count with the aggregator
      * 
-     * @param Aggregator
+     * @param aggregator
      *            count aggregator
      * 
      */
@@ -142,11 +151,11 @@ public class CountAggregator implements MeasureAggregator
      *            total fact count
      * 
      */
-    @Override
-    public void agg(double newVal, double factCount)
-    {
-        agg(newVal, null, 0, 0);
-    }
+//    @Override
+//    public void agg(double newVal, double factCount)
+//    {
+//        agg(newVal, null, 0, 0);
+//    }
 
     /**
      * This method return the count value as an object
@@ -162,13 +171,13 @@ public class CountAggregator implements MeasureAggregator
 
     /**
      * 
-     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(double)
+     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(Object)
      * 
      */
     @Override
-    public void setNewValue(double newValue)
+    public void setNewValue(Object newValue)
     {
-        aggVal+=newValue;
+        aggVal += (long)newValue;
     }
 
     @Override
@@ -217,8 +226,8 @@ public class CountAggregator implements MeasureAggregator
     @Override
     public int compareTo(MeasureAggregator obj)
     {
-        double val = getValue();
-        double otherVal = obj.getValue();
+        double val = getDoubleValue();
+        double otherVal = obj.getDoubleValue();
         if(val > otherVal)
         {
             return 1;
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DistinctCountAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DistinctCountAggregator.java
index fdcd126..9262291 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DistinctCountAggregator.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DistinctCountAggregator.java
@@ -14,8 +14,10 @@ import java.io.DataInputStream;
 import java.io.DataOutput;
 import java.io.DataOutputStream;
 import java.io.IOException;
+import java.math.BigDecimal;
 import java.nio.ByteBuffer;
 
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
 import org.roaringbitmap.IntIterator;
 import org.roaringbitmap.RoaringBitmap;
 
@@ -63,10 +65,17 @@ public class DistinctCountAggregator implements MeasureAggregator
     
     private double minValue;
 
-    public DistinctCountAggregator(double minValue)
+    public DistinctCountAggregator(Object minValue)
     {
         valueSet = new RoaringBitmap();
-        this.minValue = minValue;
+        if (minValue instanceof BigDecimal)
+        {
+            this.minValue = ((BigDecimal)minValue).doubleValue();
+        }
+        else
+        {
+            this.minValue = (Double) minValue;
+        }
     }
     
     public DistinctCountAggregator()
@@ -78,9 +87,9 @@ public class DistinctCountAggregator implements MeasureAggregator
      * just need to add the unique values to agg set
      */
     @Override
-    public void agg(double newVal, byte[] key, int offset, int length)
+    public void agg(double newVal)
     {
-        valueSet.add((int)(newVal-minValue));
+        valueSet.add((int)(newVal- minValue));
     }
     
     /**
@@ -88,30 +97,17 @@ public class DistinctCountAggregator implements MeasureAggregator
      * 
      * @param newVal
      *            new value
-     * @param key
-     *            mdkey
-     * @param offset
-     *            key offset
-     * @param length
-     *            length to be considered
      * 
      */
     @Override
-    public void agg(Object newVal, byte[] key, int offset, int length)
+    public void agg(Object newVal)
     {
-//        byte[] values = (byte[])newVal;
-//        ByteArrayInputStream stream = new ByteArrayInputStream(values);
-//        DataInputStream outputStream = new DataInputStream(stream);
-//        RoaringBitmap bitmap = new RoaringBitmap();
-//        try
-//        {
-//            bitmap.deserialize(outputStream);
-//        }
-//        catch(IOException e)
-//        {
-//            e.printStackTrace();
-//        }
-//        valueSet.or(bitmap);
+        // Object include double
+        if(newVal instanceof Double)
+        {
+            agg((double)newVal);
+            return;
+        }
         byte[] values = (byte[])newVal;
         ByteBuffer buffer = ByteBuffer.wrap(values);
         buffer.rewind();
@@ -122,6 +118,12 @@ public class DistinctCountAggregator implements MeasureAggregator
         }
     }
 
+    @Override
+    public void agg(MolapReadDataHolder newVal, int index)
+    {
+
+    }
+
     /**
      * Below method will be used to get the value byte array
      */
@@ -158,11 +160,11 @@ public class DistinctCountAggregator implements MeasureAggregator
     }
 
     
-    @Override
-    public void agg(double newVal, double factCount)
-    {
-        
-    }
+//    @Override
+//    public void agg(double newVal, double factCount)
+//    {
+//
+//    }
 
 //    private void agg(Set<Double> set2)
 //    {
@@ -214,17 +216,40 @@ public class DistinctCountAggregator implements MeasureAggregator
     }
 
     @Override
-    public double getValue()
+    public Double getDoubleValue()
     {
         if(computedFixedValue == null)
         {
             readData();
-            return valueSet.getCardinality();
+            return (double)valueSet.getCardinality();
         }
         return computedFixedValue;
     }
 
     @Override
+    public Long getLongValue()
+    {
+        if(computedFixedValue == null)
+        {
+            readData();
+            return (long)valueSet.getCardinality();
+        }
+        return computedFixedValue.longValue();
+    }
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        if(computedFixedValue == null)
+        {
+            readData();
+            return new BigDecimal(valueSet.getCardinality());
+        }
+        return new BigDecimal(computedFixedValue);
+    }
+
+
+    @Override
     public Object getValueObject()
     {
         return valueSet.getCardinality();
@@ -232,13 +257,13 @@ public class DistinctCountAggregator implements MeasureAggregator
 
     /**
      * 
-     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(double)
+     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(Object)
      * 
      */
     @Override
-    public void setNewValue(double newValue)
+    public void setNewValue(Object newValue)
     {
-        computedFixedValue = newValue;
+        computedFixedValue = (double)newValue;
         valueSet = null;
     }
 
@@ -334,8 +359,8 @@ public class DistinctCountAggregator implements MeasureAggregator
     @Override
     public int compareTo(MeasureAggregator measureAggr)
     {
-        double compFixedVal = getValue();
-        double otherVal = measureAggr.getValue();
+        double compFixedVal = getDoubleValue();
+        double otherVal = measureAggr.getDoubleValue();
         if(compFixedVal > otherVal)
         {
             return 1;
@@ -398,7 +423,7 @@ public class DistinctCountAggregator implements MeasureAggregator
         double currentMinValue = buffer.getDouble();
         while(buffer.hasRemaining())
         {
-            agg(buffer.getInt()+currentMinValue, null, 0, 0);
+            agg(buffer.getInt()+currentMinValue);
         }
     }
 
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DistinctCountAggregatorObjectSet.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DistinctCountAggregatorObjectSet.java
index b809ec9..03be497 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DistinctCountAggregatorObjectSet.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DistinctCountAggregatorObjectSet.java
@@ -3,11 +3,13 @@ package com.huawei.unibi.molap.engine.aggregator.impl;
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
+import java.math.BigDecimal;
 import java.nio.ByteBuffer;
 import java.util.HashSet;
 import java.util.Set;
 
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 
 public class DistinctCountAggregatorObjectSet implements MeasureAggregator
@@ -32,7 +34,7 @@ public class DistinctCountAggregatorObjectSet implements MeasureAggregator
      * just need to add the unique values to agg set
      */
     @Override
-    public void agg(double newVal, byte[] key, int offset, int length)
+    public void agg(double newVal)
     {
         valueSet.add(newVal);
     }
@@ -42,17 +44,17 @@ public class DistinctCountAggregatorObjectSet implements MeasureAggregator
      * 
      * @param newVal
      *            new value
-     * @param key
-     *            mdkey
-     * @param offset
-     *            key offset
-     * @param length
-     *            length to be considered
      * 
      */
     @Override
-    public void agg(Object newVal, byte[] key, int offset, int length)
+    public void agg(Object newVal)
     {
+        // Object include double
+        if(newVal instanceof Double)
+        {
+            agg((double)newVal);
+            return;
+        }
         byte[] values = (byte[])newVal;
         ByteBuffer buffer = ByteBuffer.wrap(values);
         buffer.rewind();
@@ -63,6 +65,11 @@ public class DistinctCountAggregatorObjectSet implements MeasureAggregator
         }
     }
 
+    @Override
+    public void agg(MolapReadDataHolder newVal, int index)
+    {
+        valueSet.add(newVal.getReadableDoubleValueByIndex(index));
+    }
     /**
      * Below method will be used to get the value byte array
      */
@@ -73,11 +80,11 @@ public class DistinctCountAggregatorObjectSet implements MeasureAggregator
     }
 
     
-    @Override
-    public void agg(double newVal, double factCount)
-    {
-        
-    }
+//    @Override
+//    public void agg(double newVal, double factCount)
+//    {
+//
+//    }
 
     private void agg(Set<Object> set2)
     {
@@ -95,32 +102,35 @@ public class DistinctCountAggregatorObjectSet implements MeasureAggregator
     }
 
     @Override
-    public double getValue()
+    public Double getDoubleValue()
     {
-        return valueSet.size();
+        return (double)valueSet.size();
     }
 
     @Override
-    public Object getValueObject()
+    public Long getLongValue()
     {
-        return valueSet.size();
+        return (long)valueSet.size();
     }
 
-    /**
-     * 
-     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(double)
-     * 
-     */
     @Override
-    public void setNewValue(double newValue)
+    public BigDecimal getBigDecimalValue()
     {
+        return new BigDecimal(valueSet.size());
     }
-    
+
+    @Override
+    public Object getValueObject()
+    {
+        return valueSet.size();
+    }
+
     /**
      * 
-     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(double)
+     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(Object)
      * 
      */
+    @Override
     public void setNewValue(Object newValue)
     {
         valueSet.add(newValue);
@@ -161,8 +171,8 @@ public class DistinctCountAggregatorObjectSet implements MeasureAggregator
     @Override
     public int compareTo(MeasureAggregator measureAggr)
     {
-        double valueSetSize = getValue();
-        double otherVal = measureAggr.getValue();
+        double valueSetSize = getDoubleValue();
+        double otherVal = measureAggr.getDoubleValue();
         if(valueSetSize > otherVal)
         {
             return 1;
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DistinctCountAggregatorSet.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DistinctCountAggregatorSet.java
index a1cab8c..cd81808 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DistinctCountAggregatorSet.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DistinctCountAggregatorSet.java
@@ -10,6 +10,7 @@ package com.huawei.unibi.molap.engine.aggregator.impl;
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
+import java.math.BigDecimal;
 import java.nio.ByteBuffer;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -17,6 +18,7 @@ import java.util.Set;
 
 
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 
 /**
@@ -62,7 +64,7 @@ public class DistinctCountAggregatorSet implements MeasureAggregator
      * just need to add the unique values to agg set
      */
     @Override
-    public void agg(double newVal, byte[] key, int offset, int length)
+    public void agg(double newVal)
     {
         valueSet.add(newVal);
     }
@@ -90,17 +92,17 @@ public class DistinctCountAggregatorSet implements MeasureAggregator
      * 
      * @param newVal
      *            new value
-     * @param key
-     *            mdkey
-     * @param offset
-     *            key offset
-     * @param length
-     *            length to be considered
      * 
      */
     @Override
-    public void agg(Object newVal, byte[] key, int offset, int length)
+    public void agg(Object newVal)
     {
+        // Object include double
+        if(newVal instanceof Double)
+        {
+            agg((double)newVal);
+            return;
+        }
         byte[] values = (byte[])newVal;
         ByteBuffer buffer = ByteBuffer.wrap(values);
         buffer.rewind();
@@ -110,12 +112,18 @@ public class DistinctCountAggregatorSet implements MeasureAggregator
             valueSet.add(buffer.getDouble());
         }
     }
-    
+
     @Override
-    public void agg(double newVal, double factCount)
+    public void agg(MolapReadDataHolder newVal, int index)
     {
-        
+        valueSet.add(newVal.getReadableDoubleValueByIndex(index));
     }
+    
+//    @Override
+//    public void agg(double newVal, double factCount)
+//    {
+//
+//    }
 
     private void agg(Set<Double> set2)
     {
@@ -133,16 +141,36 @@ public class DistinctCountAggregatorSet implements MeasureAggregator
     }
 
     @Override
-    public double getValue()
+    public Double getDoubleValue()
     {
         if(computedFixedValue == null)
         {
-            return valueSet.size();
+            return (double)valueSet.size();
         }
         return computedFixedValue;
     }
 
     @Override
+    public Long getLongValue()
+    {
+        if(computedFixedValue == null)
+        {
+            return (long)valueSet.size();
+        }
+        return computedFixedValue.longValue();
+    }
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        if(computedFixedValue == null)
+        {
+            return new BigDecimal(valueSet.size());
+        }
+        return new BigDecimal(computedFixedValue);
+    }
+
+    @Override
     public Object getValueObject()
     {
         return valueSet.size();
@@ -156,13 +184,13 @@ public class DistinctCountAggregatorSet implements MeasureAggregator
     }
     /**
      * 
-     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(double)
+     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(Object)
      * 
      */
     @Override
-    public void setNewValue(double newValue)
+    public void setNewValue(Object newValue)
     {
-        computedFixedValue = newValue;
+        computedFixedValue = (Double)newValue;
         valueSet = null;
     }
  
@@ -240,8 +268,8 @@ public class DistinctCountAggregatorSet implements MeasureAggregator
     @Override
     public int compareTo(MeasureAggregator msr)
     {
-        double msrVal = getValue(); 
-        double otherMsrVal = msr.getValue();    
+        double msrVal = getDoubleValue();
+        double otherMsrVal = msr.getDoubleValue();
         if(msrVal > otherMsrVal)
         {
             return 1;
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DistinctStringCountAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DistinctStringCountAggregator.java
index 1c6e2c2..d317332 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DistinctStringCountAggregator.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DistinctStringCountAggregator.java
@@ -3,12 +3,14 @@ package com.huawei.unibi.molap.engine.aggregator.impl;
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
+import java.math.BigDecimal;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 import java.util.HashSet;
 import java.util.Set;
 
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 
 public class DistinctStringCountAggregator implements MeasureAggregator
@@ -22,7 +24,7 @@ public class DistinctStringCountAggregator implements MeasureAggregator
         this.valueSet = new HashSet<String>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
     }
 
-    public void agg(double newVal, byte[] key, int offset, int length)
+    public void agg(double newVal)
     {
     }
 
@@ -31,9 +33,9 @@ public class DistinctStringCountAggregator implements MeasureAggregator
         this.valueSet.add(newVal);
     }
 
-    public void agg(double newVal, double factCount)
-    {
-    }
+//    public void agg(double newVal, double factCount)
+//    {
+//    }
 
     private void agg(Set<String> set2)
     {
@@ -46,9 +48,19 @@ public class DistinctStringCountAggregator implements MeasureAggregator
         agg(distinctCountAggregator.valueSet);
     }
 
-    public double getValue()
+    public Double getDoubleValue()
+    {
+        return (double)this.valueSet.size();
+    }
+
+    public Long getLongValue()
+    {
+        return (long)this.valueSet.size();
+    }
+
+    public BigDecimal getBigDecimalValue()
     {
-        return this.valueSet.size();
+        return new BigDecimal(this.valueSet.size());
     }
 
     public Object getValueObject()
@@ -56,7 +68,7 @@ public class DistinctStringCountAggregator implements MeasureAggregator
         return Integer.valueOf(this.valueSet.size());
     }
 
-    public void setNewValue(double newValue)
+    public void setNewValue(Object newValue)
     {
     }
 
@@ -107,8 +119,8 @@ public class DistinctStringCountAggregator implements MeasureAggregator
      
     public int compareTo(MeasureAggregator o)
     {
-        double val = getValue();
-        double otherVal = o.getValue();
+        double val = getDoubleValue();
+        double otherVal = o.getDoubleValue();
         if(val > otherVal)
         {
             return 1;
@@ -121,12 +133,18 @@ public class DistinctStringCountAggregator implements MeasureAggregator
     }
 
     @Override
-    public void agg(Object newVal, byte[] key, int offset, int length)
+    public void agg(Object newVal)
     {
         this.valueSet.add((String)newVal);
     }
 
     @Override
+    public void agg(MolapReadDataHolder newVal, int index)
+    {
+//        valueSet.add(newVal.getReadableDoubleValueByIndex(index));
+    }
+
+    @Override
     public byte[] getByteArray()
     {
         return null;
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DummyAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DummyAggregator.java
deleted file mode 100644
index debc008..0000000
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DummyAggregator.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/**
- * 
- */
-package com.huawei.unibi.molap.engine.aggregator.impl;
-
-import java.io.DataInput;
-import java.io.DataOutput;
-import java.io.IOException;
-
-import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
-
-/**
- * @author R00903928
- *
- */
-public class DummyAggregator implements MeasureAggregator
-{
-    /**
-     * 
-     */
-    private static final long serialVersionUID = 1L;
-    
-    /**
-     * aggregate value
-     */
-    private double aggVal;
-
-    @Override
-    public int compareTo(MeasureAggregator o)
-    {
-        if(equals(o))
-        {
-            return 0;
-        }
-        return -1;
-    }
-    @Override
-    public boolean equals(Object arg0)
-    {
-        return super.equals(arg0);
-    }
-    @Override
-    public int hashCode()
-    {
-        return super.hashCode();
-    }
-    @Override
-    public void agg(double newVal, byte[] key, int offset, int length)
-    {
-        aggVal = newVal;
-    }
-
-    @Override
-    public void agg(Object newVal, byte[] key, int offset, int length)
-    {
-       
-    }
-
-    @Override
-    public byte[] getByteArray()
-    {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    public void agg(double newVal, double factCount)
-    {
-        aggVal =(Double) newVal;
-    }
-
-    @Override
-    public double getValue()
-    {
-        return aggVal;
-    }
-
-    @Override
-    public Object getValueObject()
-    {
-        // TODO Auto-generated method stub
-        return aggVal;
-    }
-
-    @Override
-    public void merge(MeasureAggregator aggregator)
-    {
-        // TODO Auto-generated method stub
-        
-    }
-
-    @Override
-    public void setNewValue(double newValue)
-    {
-        // TODO Auto-generated method stub
-        aggVal = newValue;
-    }
-
-    @Override
-    public boolean isFirstTime()
-    {
-        // TODO Auto-generated method stub
-        return false;
-    }
-
-    @Override
-    public MeasureAggregator getCopy()
-    {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    public void writeData(DataOutput output) throws IOException
-    {
-        // TODO Auto-generated method stub
-        
-    }
-
-    @Override
-    public void readData(DataInput inPut) throws IOException
-    {
-        // TODO Auto-generated method stub
-        
-    }
-
-    @Override
-    public MeasureAggregator get()
-    {
-        // TODO Auto-generated method stub
-        return this;
-    }
-
-    @Override
-    public void merge(byte[] value)
-    {
-        // TODO Auto-generated method stub
-        
-    }
-
-}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DummyBigDecimalAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DummyBigDecimalAggregator.java
new file mode 100644
index 0000000..3a7055b
--- /dev/null
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DummyBigDecimalAggregator.java
@@ -0,0 +1,161 @@
+/**
+ * 
+ */
+package com.huawei.unibi.molap.engine.aggregator.impl;
+
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.math.BigDecimal;
+
+/**
+ * @author R00903928
+ *
+ */
+public class DummyBigDecimalAggregator implements MeasureAggregator
+{
+    /**
+     * 
+     */
+    private static final long serialVersionUID = 1L;
+    
+    /**
+     * aggregate value
+     */
+    private BigDecimal aggVal;
+
+    @Override
+    public int compareTo(MeasureAggregator o)
+    {
+        if(equals(o))
+        {
+            return 0;
+        }
+        return -1;
+    }
+    @Override
+    public boolean equals(Object arg0)
+    {
+        return super.equals(arg0);
+    }
+    @Override
+    public int hashCode()
+    {
+        return super.hashCode();
+    }
+    @Override
+    public void agg(double newVal)
+    {
+//        aggVal = new BigDecimal(newVal);
+    }
+
+    @Override
+    public void agg(Object newVal)
+    {
+        aggVal = (BigDecimal)newVal;
+    }
+
+    @Override
+    public void agg(MolapReadDataHolder newVal, int index)
+    {
+        aggVal = newVal.getReadableBigDecimalValueByIndex(index);
+    }
+
+    @Override
+    public byte[] getByteArray()
+    {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+//    @Override
+//    public void agg(double newVal, double factCount)
+//    {
+//        aggVal =(Double) newVal;
+//    }
+
+    @Override
+    public Double getDoubleValue()
+    {
+        return null;
+    }
+
+    @Override
+    public Long getLongValue()
+    {
+        return null;
+    }
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        return aggVal;
+    }
+
+    @Override
+    public Object getValueObject()
+    {
+        // TODO Auto-generated method stub
+        return aggVal;
+    }
+
+    @Override
+    public void merge(MeasureAggregator aggregator)
+    {
+        // TODO Auto-generated method stub
+        
+    }
+
+    @Override
+    public void setNewValue(Object newValue)
+    {
+        // TODO Auto-generated method stub
+        aggVal = (BigDecimal)newValue;
+    }
+
+    @Override
+    public boolean isFirstTime()
+    {
+        // TODO Auto-generated method stub
+        return false;
+    }
+
+    @Override
+    public MeasureAggregator getCopy()
+    {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    @Override
+    public void writeData(DataOutput output) throws IOException
+    {
+        // TODO Auto-generated method stub
+        
+    }
+
+    @Override
+    public void readData(DataInput inPut) throws IOException
+    {
+        // TODO Auto-generated method stub
+        
+    }
+
+    @Override
+    public MeasureAggregator get()
+    {
+        // TODO Auto-generated method stub
+        return this;
+    }
+
+    @Override
+    public void merge(byte[] value)
+    {
+        // TODO Auto-generated method stub
+        
+    }
+
+}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DummyDoubleAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DummyDoubleAggregator.java
new file mode 100644
index 0000000..a5c645e
--- /dev/null
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DummyDoubleAggregator.java
@@ -0,0 +1,162 @@
+/**
+ * 
+ */
+package com.huawei.unibi.molap.engine.aggregator.impl;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.math.BigDecimal;
+
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+import com.huawei.unibi.molap.datastorage.store.impl.data.uncompressed.DoubleArrayDataFileStore;
+import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+
+/**
+ * @author R00903928
+ *
+ */
+public class DummyDoubleAggregator implements MeasureAggregator
+{
+    /**
+     * 
+     */
+    private static final long serialVersionUID = 1L;
+    
+    /**
+     * aggregate value
+     */
+    private double aggVal;
+
+    @Override
+    public int compareTo(MeasureAggregator o)
+    {
+        if(equals(o))
+        {
+            return 0;
+        }
+        return -1;
+    }
+    @Override
+    public boolean equals(Object arg0)
+    {
+        return super.equals(arg0);
+    }
+    @Override
+    public int hashCode()
+    {
+        return super.hashCode();
+    }
+    @Override
+    public void agg(double newVal)
+    {
+        aggVal = newVal;
+    }
+
+    @Override
+    public void agg(Object newVal)
+    {
+        aggVal = (Double)newVal;
+    }
+
+    @Override
+    public void agg(MolapReadDataHolder newVal, int index)
+    {
+        aggVal = newVal.getReadableDoubleValueByIndex(index);
+    }
+
+    @Override
+    public byte[] getByteArray()
+    {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+//    @Override
+//    public void agg(double newVal, double factCount)
+//    {
+//        aggVal =(Double) newVal;
+//    }
+
+    @Override
+    public Double getDoubleValue()
+    {
+        return aggVal;
+    }
+
+    @Override
+    public Long getLongValue()
+    {
+        return null;
+    }
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        return null;
+    }
+
+    @Override
+    public Object getValueObject()
+    {
+        // TODO Auto-generated method stub
+        return aggVal;
+    }
+
+    @Override
+    public void merge(MeasureAggregator aggregator)
+    {
+        // TODO Auto-generated method stub
+        
+    }
+
+    @Override
+    public void setNewValue(Object newValue)
+    {
+        // TODO Auto-generated method stub
+        aggVal = (Double)newValue;
+    }
+
+    @Override
+    public boolean isFirstTime()
+    {
+        // TODO Auto-generated method stub
+        return false;
+    }
+
+    @Override
+    public MeasureAggregator getCopy()
+    {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    @Override
+    public void writeData(DataOutput output) throws IOException
+    {
+        // TODO Auto-generated method stub
+        
+    }
+
+    @Override
+    public void readData(DataInput inPut) throws IOException
+    {
+        // TODO Auto-generated method stub
+        
+    }
+
+    @Override
+    public MeasureAggregator get()
+    {
+        // TODO Auto-generated method stub
+        return this;
+    }
+
+    @Override
+    public void merge(byte[] value)
+    {
+        // TODO Auto-generated method stub
+        
+    }
+
+}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DummyLongAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DummyLongAggregator.java
new file mode 100644
index 0000000..675b8fe
--- /dev/null
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/DummyLongAggregator.java
@@ -0,0 +1,161 @@
+/**
+ * 
+ */
+package com.huawei.unibi.molap.engine.aggregator.impl;
+
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.math.BigDecimal;
+
+/**
+ * @author R00903928
+ *
+ */
+public class DummyLongAggregator implements MeasureAggregator
+{
+    /**
+     * 
+     */
+    private static final long serialVersionUID = 1L;
+    
+    /**
+     * aggregate value
+     */
+    private long aggVal;
+
+    @Override
+    public int compareTo(MeasureAggregator o)
+    {
+        if(equals(o))
+        {
+            return 0;
+        }
+        return -1;
+    }
+    @Override
+    public boolean equals(Object arg0)
+    {
+        return super.equals(arg0);
+    }
+    @Override
+    public int hashCode()
+    {
+        return super.hashCode();
+    }
+    @Override
+    public void agg(double newVal)
+    {
+//        aggVal = (long)newVal;
+    }
+
+    @Override
+    public void agg(Object newVal)
+    {
+        aggVal = (Long)newVal;
+    }
+
+    @Override
+    public void agg(MolapReadDataHolder newVal, int index)
+    {
+        aggVal = newVal.getReadableLongValueByIndex(index);
+    }
+
+    @Override
+    public byte[] getByteArray()
+    {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+//    @Override
+//    public void agg(double newVal, double factCount)
+//    {
+//        aggVal =(Double) newVal;
+//    }
+
+    @Override
+    public Double getDoubleValue()
+    {
+        return null;
+    }
+
+    @Override
+    public Long getLongValue()
+    {
+        return aggVal;
+    }
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        return null;
+    }
+
+    @Override
+    public Object getValueObject()
+    {
+        // TODO Auto-generated method stub
+        return aggVal;
+    }
+
+    @Override
+    public void merge(MeasureAggregator aggregator)
+    {
+        // TODO Auto-generated method stub
+        
+    }
+
+    @Override
+    public void setNewValue(Object newValue)
+    {
+        // TODO Auto-generated method stub
+        aggVal = (Long)newValue;
+    }
+
+    @Override
+    public boolean isFirstTime()
+    {
+        // TODO Auto-generated method stub
+        return false;
+    }
+
+    @Override
+    public MeasureAggregator getCopy()
+    {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    @Override
+    public void writeData(DataOutput output) throws IOException
+    {
+        // TODO Auto-generated method stub
+        
+    }
+
+    @Override
+    public void readData(DataInput inPut) throws IOException
+    {
+        // TODO Auto-generated method stub
+        
+    }
+
+    @Override
+    public MeasureAggregator get()
+    {
+        // TODO Auto-generated method stub
+        return this;
+    }
+
+    @Override
+    public void merge(byte[] value)
+    {
+        // TODO Auto-generated method stub
+        
+    }
+
+}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/MaxAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/MaxAggregator.java
index f23b364..d52287e 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/MaxAggregator.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/MaxAggregator.java
@@ -27,9 +27,11 @@ import java.io.ObjectInput;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutput;
 import java.io.ObjectOutputStream;
+import java.math.BigDecimal;
 
 import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 import com.huawei.unibi.molap.engine.util.MolapEngineLogEvent;
 import com.huawei.unibi.molap.util.MolapUtil;
@@ -77,17 +79,11 @@ public class MaxAggregator implements MeasureAggregator
      * 
      * @param newVal
      *          new value
-     * @param key
-     *          mdkey 
-     * @param offset
-     *          key offset 
-     * @param length
-     *          length to be considered 
      *
      */
     
     @Override
-    public void agg(double newVal, byte[] key, int offset, int length)
+    public void agg(double newVal)
     {
         internalAgg((Double)newVal);
         firstTime = false;
@@ -108,21 +104,21 @@ public class MaxAggregator implements MeasureAggregator
      * 
      * @param newVal
      *          new value
-     * @param key
-     *          mdkey 
-     * @param offset
-     *          key offset 
-     * @param length
-     *          length to be considered 
      *
      */
     @Override
-    public void agg(Object newVal, byte[] key, int offset, int length)
+    public void agg(Object newVal)
     {
         internalAgg(newVal);
         firstTime = false;
     }
 
+    @Override
+    public void agg(MolapReadDataHolder newVal, int index)
+    {
+        internalAgg(newVal.getReadableDoubleValueByIndex(index));
+        firstTime = false;
+    }
     /**
      * Below method will be used to get the value byte array
      */
@@ -165,12 +161,12 @@ public class MaxAggregator implements MeasureAggregator
      *            total fact count
      * 
      */
-    @Override
-    public void agg(double newVal, double factCount)
-    {
-        agg(newVal, null, 0, 0);
-        firstTime = false;
-    }
+//    @Override
+//    public void agg(double newVal, double factCount)
+//    {
+//        agg(newVal);
+//        firstTime = false;
+//    }
 
     /**
      * This method will return max value
@@ -179,11 +175,23 @@ public class MaxAggregator implements MeasureAggregator
      *
      */
     @Override
-    public double getValue()
+    public Double getDoubleValue()
     {
         return (Double)((Object)aggVal);
     }
 
+    @Override
+    public Long getLongValue()
+    {
+        return (Long)((Object)aggVal);
+    }
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        return (BigDecimal)((Object)aggVal);
+    }
+
     /**
      * Merge the value, it will update the max aggregate value if aggregator
      * passed as an argument will have value greater than aggVal
@@ -198,7 +206,7 @@ public class MaxAggregator implements MeasureAggregator
         MaxAggregator maxAggregator = (MaxAggregator)aggregator;
 //        if(!maxAggregator.isFirstTime())
 //        {
-            agg(maxAggregator.aggVal, null, 0, 0);
+            agg(maxAggregator.aggVal);
 //        }
     }
 
@@ -275,11 +283,11 @@ public class MaxAggregator implements MeasureAggregator
     
     /**
      * 
-     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(double)
+     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(Object)
      * 
      */
     @Override
-    public void setNewValue(double newValue)
+    public void setNewValue(Object newValue)
     {
 //        aggVal= newValue;
     }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/MinAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/MinAggregator.java
index 29ef1fe..c1fad81 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/MinAggregator.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/MinAggregator.java
@@ -27,9 +27,11 @@ import java.io.ObjectInput;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutput;
 import java.io.ObjectOutputStream;
+import java.math.BigDecimal;
 
 import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 import com.huawei.unibi.molap.engine.util.MolapEngineLogEvent;
 import com.huawei.unibi.molap.util.MolapUtil;
@@ -77,16 +79,10 @@ public class MinAggregator implements MeasureAggregator
      * 
      * @param newVal
      *            new value
-     * @param key
-     *            mdkey
-     * @param offset
-     *            key offset
-     * @param length
-     *            length to be considered
      * 
      */
     @Override
-    public void agg(double newVal, byte[] key, int offset, int length)
+    public void agg(double newVal)
     {
         internalAgg((Double)newVal);
         firstTime = false;
@@ -108,21 +104,22 @@ public class MinAggregator implements MeasureAggregator
      * 
      * @param newVal
      *            new value
-     * @param key
-     *            mdkey
-     * @param offset
-     *            key offset
-     * @param length
-     *            length to be considered
      * 
      */
     @Override
-    public void agg(Object newVal, byte[] key, int offset, int length)
+    public void agg(Object newVal)
     {
         internalAgg(newVal);
         firstTime = false;
     }
 
+    @Override
+    public void agg(MolapReadDataHolder newVal, int index)
+    {
+        internalAgg(newVal.getReadableDoubleValueByIndex(index));
+        firstTime = false;
+    }
+
     /**
      * Below method will be used to get the value byte array
      */
@@ -161,11 +158,23 @@ public class MinAggregator implements MeasureAggregator
      */
 
     @Override
-    public double getValue()
+    public Double getDoubleValue()
     {
         return (Double)((Object)aggVal);
     }
 
+    @Override
+    public Long getLongValue()
+    {
+        return (Long)((Object)aggVal);
+    }
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        return (BigDecimal)((Object)aggVal);
+    }
+
     /**
      * Merge the value, it will update the min aggregate value if aggregator
      * passed as an argument will have value less than aggVal
@@ -180,7 +189,7 @@ public class MinAggregator implements MeasureAggregator
         MinAggregator minAggregator = (MinAggregator)aggregator;
 //        if(!minAggregator.isFirstTime())
 //        {
-            agg(minAggregator.aggVal, null, 0, 0);
+            agg(minAggregator.aggVal);
 //        }
     }
 
@@ -196,21 +205,21 @@ public class MinAggregator implements MeasureAggregator
      * 
      */
 
-    @Override
-    public void agg(double newVal, double factCount)
-    {
-        agg(newVal, null, 0, 0);
-        firstTime = false;
-    }
+//    @Override
+//    public void agg(double newVal, double factCount)
+//    {
+//        agg(newVal);
+//        firstTime = false;
+//    }
     
 
     /**
      * 
-     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(double)
+     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(Object)
      * 
      */
     @Override
-    public void setNewValue(double newValue)
+    public void setNewValue(Object newValue)
     {
 //        aggVal= newValue;
     }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumAggregator.java
deleted file mode 100644
index 2cf7d27..0000000
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumAggregator.java
+++ /dev/null
@@ -1,265 +0,0 @@
-/*--------------------------------------------------------------------------------------------------------------------------*/
-/*!!Warning: This is a key information asset of Huawei Tech Co.,Ltd                                                         */
-/*CODEMARK:kOyQZYzjDpyGdBAEC2GaWmnksNUG9RKxzMKuuAYTdbJ5ajFrCnCGALet/FDi0nQqbEkSZoTs
-2wdXgejaKCr1dP3uE3wfvLHF9gW8+IdXbwdEVzw1icjfRowqz2DW4XzUpEhhSzBOwVynEHjc
-u0090fbnj+0VbOfZnjQdUjNGeZBp/OEV/ihcZz/8Bj30H6cdHtnLWokryD8YEIDSBoqj0HMv
-x2bWOm2rwPhsF8R5ByGyW4CmQm6QiI4mdcr/+CnCQ2iadvOiXEuMjfxMA+hszQ==*/
-/*--------------------------------------------------------------------------------------------------------------------------*/
-/**
- *
- * Copyright Notice
- * =====================================
- * This file contains proprietary information of
- * Huawei Technologies India Pvt Ltd.
- * Copying or reproduction without prior written approval is prohibited.
- * Copyright (c) 2013
- * =====================================
- *
- */
-package com.huawei.unibi.molap.engine.aggregator.impl;
-
-import java.io.DataInput;
-import java.io.DataOutput;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-
-import com.huawei.unibi.molap.constants.MolapCommonConstants;
-import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
-
-/**
- * Project Name NSE V3R7C00
- * 
- * Module Name : Molap Engine
- * 
- * Author K00900841
- * 
- * Created Date :13-May-2013 3:35:33 PM
- * 
- * FileName : SumAggregator.java
- * 
- * Class Description : It will return sum of all the values
- * 
- * Version 1.0
- */
-public class SumAggregator implements MeasureAggregator
-{
-
-    /**
-     * serialVersionUID
-     * 
-     */
-    private static final long serialVersionUID = 623750056131364540L;
-
-    /**
-     * aggregate value
-     */
-    private double aggVal;
-    
-    /**
-     * 
-     */
-    private boolean firstTime = true;
-
-    /**
-     * This method will update the aggVal it will add new value to aggVal
-     * 
-     * @param newVal
-     *            new value
-     * @param key
-     *            mdkey
-     * @param offset
-     *            key offset
-     * @param length
-     *            length to be considered
-     * 
-     */
-    @Override
-    public void agg(double newVal, byte[] key, int offset, int length)
-    {
-        aggVal += newVal;
-        firstTime = false;
-    }
-
-    /**
-     * This method will update the aggVal it will add new value to aggVal
-     * 
-     * @param newVal
-     *            new value
-     * @param key
-     *            mdkey
-     * @param offset
-     *            key offset
-     * @param length
-     *            length to be considered
-     * 
-     */
-    @Override
-    public void agg(Object newVal, byte[] key, int offset, int length)
-    {
-        aggVal += (Double)newVal;
-        firstTime = false;
-    }
-
-    /**
-     * Below method will be used to get the value byte array
-     */
-    @Override
-    public byte[] getByteArray()
-    {
-        if(firstTime)
-        {
-            return new byte[0];
-        }
-        ByteBuffer buffer = ByteBuffer.allocate(MolapCommonConstants.DOUBLE_SIZE_IN_BYTE);
-        buffer.putDouble(aggVal);
-        return buffer.array();
-    }
-    
-    /**
-     * This method will return aggVal
-     * 
-     * @return sum value
-     * 
-     */
-
-    @Override
-    public double getValue()
-    {
-        return aggVal;
-    }
-
-    /**
-     * Merge the value, it will update the sum aggregate value it will add new
-     * value to aggVal
-     * 
-     * @param aggregator
-     *            SumAggregator
-     * 
-     */
-    @Override
-    public void merge(MeasureAggregator aggregator)
-    {
-        if(!aggregator.isFirstTime())
-        {
-            agg(aggregator.getValue(), null, 0, 0);
-        }
-    }
-
-    /**
-     * Overloaded Aggregate function will be used for Aggregate tables because
-     * aggregate table will have fact_count as a measure. it will add new value
-     * to aggVal
-     * 
-     * @param newVal
-     *            new value
-     * @param factCount
-     *            total fact count
-     * 
-     */
-
-    @Override
-    public void agg(double newVal, double factCount)
-    {
-        agg(newVal, null, 0, 0);
-    }
-
-    /**
-     * This method return the sum value as an object
-     * 
-     * @return sum value as an object
-     */
-    @Override
-    public Object getValueObject()
-    {
-        return aggVal;
-    }
-
-    /**
-     * 
-     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(double)
-     * 
-     */
-    @Override
-    public void setNewValue(double newValue)
-    {
-        aggVal = newValue;
-    }
-
-    @Override
-    public boolean isFirstTime()
-    {
-        return firstTime;
-    }
-    
-    //TODO SIMIAN
-    @Override
-    public void readData(DataInput inPut) throws IOException
-    {
-        firstTime = inPut.readBoolean();
-        aggVal = inPut.readDouble();
-    }
-
-    @Override
-    public void writeData(DataOutput output) throws IOException
-    {
-        output.writeBoolean(firstTime);
-        output.writeDouble(aggVal);
-        
-    }
-
-  
-    @Override
-    public MeasureAggregator getCopy() 
-    {
-        SumAggregator aggr = new SumAggregator();
-        aggr.aggVal = aggVal;
-        aggr.firstTime = firstTime;
-        return aggr; 
-    }
-    
-    //we are not comparing the Aggregator values 
-    /* public boolean equals(MeasureAggregator msrAggregator){
-         return compareTo(msrAggregator)==0;
-     }*/
-     
-
-    @Override
-    public int compareTo(MeasureAggregator o)
-    {
-        double value = getValue();
-        double otherVal = o.getValue();
-        if(value > otherVal)
-        {
-            return 1;
-        }
-        if(value < otherVal)
-        {
-            return -1;
-        }
-        return 0;
-    }
-
-    
-
-    @Override
-    public void merge(byte[] value)
-    {
-        if(0 == value.length)
-        {
-            return;
-        }
-        aggVal+= ByteBuffer.wrap(value).getDouble();
-        firstTime = false;
-    }
-    
-    @Override
-    public MeasureAggregator get()
-    {
-        return this;
-    }
-    
-    public String toString()
-    {
-        return aggVal+"";
-    }
-}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumBigDecimalAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumBigDecimalAggregator.java
new file mode 100644
index 0000000..7f29d2d
--- /dev/null
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumBigDecimalAggregator.java
@@ -0,0 +1,274 @@
+/*--------------------------------------------------------------------------------------------------------------------------*/
+/*!!Warning: This is a key information asset of Huawei Tech Co.,Ltd                                                         */
+/*CODEMARK:kOyQZYzjDpyGdBAEC2GaWmnksNUG9RKxzMKuuAYTdbJ5ajFrCnCGALet/FDi0nQqbEkSZoTs
+2wdXgejaKCr1dP3uE3wfvLHF9gW8+IdXbwdEVzw1icjfRowqz2DW4XzUpEhhSzBOwVynEHjc
+u0090fbnj+0VbOfZnjQdUjNGeZBp/OEV/ihcZz/8Bj30H6cdHtnLWokryD8YEIDSBoqj0HMv
+x2bWOm2rwPhsF8R5ByGyW4CmQm6QiI4mdcr/+CnCQ2iadvOiXEuMjfxMA+hszQ==*/
+/*--------------------------------------------------------------------------------------------------------------------------*/
+/**
+ *
+ * Copyright Notice
+ * =====================================
+ * This file contains proprietary information of
+ * Huawei Technologies India Pvt Ltd.
+ * Copying or reproduction without prior written approval is prohibited.
+ * Copyright (c) 2013
+ * =====================================
+ *
+ */
+package com.huawei.unibi.molap.engine.aggregator.impl;
+
+import com.huawei.unibi.molap.constants.MolapCommonConstants;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.nio.ByteBuffer;
+
+/**
+ * Project Name NSE V3R7C00
+ * 
+ * Module Name : Molap Engine
+ * 
+ * Author K00900841
+ * 
+ * Created Date :13-May-2013 3:35:33 PM
+ * 
+ * FileName : SumAggregator.java
+ * 
+ * Class Description : It will return sum of all the values
+ * 
+ * Version 1.0
+ */
+public class SumBigDecimalAggregator implements MeasureAggregator
+{
+
+    /**
+     * serialVersionUID
+     * 
+     */
+    private static final long serialVersionUID = 623750056131364540L;
+
+    /**
+     * aggregate value
+     */
+    private BigDecimal aggVal;
+    
+    /**
+     * 
+     */
+    private boolean firstTime = true;
+
+    /**
+     * This method will update the aggVal it will add new value to aggVal
+     * 
+     * @param newVal
+     *            new value
+     * 
+     */
+    @Override
+    public void agg(double newVal)
+    {
+
+    }
+
+    /**
+     * This method will update the aggVal it will add new value to aggVal
+     * 
+     * @param newVal
+     *            new value
+     * 
+     */
+    @Override
+    public void agg(Object newVal)
+    {
+        if(firstTime)
+        {
+            aggVal = (BigDecimal)newVal;
+            firstTime = false;
+        }
+        else
+        {
+            aggVal = aggVal.add((BigDecimal)newVal);
+        }
+    }
+
+
+    public void agg(MolapReadDataHolder newVal,int index)
+    {
+        BigDecimal valueBigDecimal = newVal.getReadableBigDecimalValueByIndex(index);
+        aggVal = aggVal.add(valueBigDecimal);
+        firstTime = false;
+    }
+    /**
+     * Below method will be used to get the value byte array
+     */
+    @Override
+    public byte[] getByteArray()
+    {
+        if(firstTime)
+        {
+            return new byte[0];
+        }
+//        ByteBuffer buffer = ByteBuffer.allocate(MolapCommonConstants.DOUBLE_SIZE_IN_BYTE);
+//        byte[] byteValSrc =  aggVal.toString().getBytes();
+//        byte[] byteValDest = new byte[byteValSrc.length + 1];
+//        byteValDest[0] = (byte)byteValSrc.length;
+//        System.arraycopy(byteValSrc, 0, byteValDest, 1, byteValSrc.length);
+//        buffer.put(byteValDest);
+//        return buffer.array();
+
+        byte[] bytes = aggVal.toString().getBytes();
+
+        ByteBuffer allocate = ByteBuffer.allocate(4+bytes.length);
+
+        allocate.putInt(bytes.length);
+        allocate.put(bytes);
+        allocate.rewind();
+        return allocate.array();
+    }
+    
+    /**
+     * This method will return aggVal
+     * 
+     * @return sum value
+     * 
+     */
+
+    @Override
+    public Double getDoubleValue()
+    {
+        return null;
+    }
+
+
+    @Override
+    public Long getLongValue()
+    {
+        return null;
+    }
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        return aggVal;
+    }
+
+    /* Merge the value, it will update the sum aggregate value it will add new
+     * value to aggVal
+     * 
+     * @param aggregator
+     *            SumAggregator
+     * 
+     */
+    @Override
+    public void merge(MeasureAggregator aggregator)
+    {
+        if(!aggregator.isFirstTime())
+        {
+            agg(aggregator.getDoubleValue());
+        }
+    }
+
+
+    /**
+     * This method return the sum value as an object
+     * 
+     * @return sum value as an object
+     */
+    @Override
+    public Object getValueObject()
+    {
+        return aggVal;
+    }
+
+    /**
+     * 
+     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(Object)
+     * 
+     */
+    @Override
+    public void setNewValue(Object newValue)
+    {
+        aggVal = (BigDecimal)newValue;
+    }
+
+    @Override
+    public boolean isFirstTime()
+    {
+        return firstTime;
+    }
+    
+    //TODO SIMIAN
+    @Override
+    public void readData(DataInput inPut) throws IOException
+    {
+        firstTime = inPut.readBoolean();
+        aggVal = new BigDecimal(inPut.readUTF());
+    }
+
+    @Override
+    public void writeData(DataOutput output) throws IOException
+    {
+        output.writeBoolean(firstTime);
+        output.writeUTF(aggVal.toString());
+        
+    }
+
+  
+    @Override
+    public MeasureAggregator getCopy()
+    {
+        SumBigDecimalAggregator aggr = new SumBigDecimalAggregator();
+        aggr.aggVal = aggVal;
+        aggr.firstTime = firstTime;
+        return aggr; 
+    }
+    
+    //we are not comparing the Aggregator values 
+    /* public boolean equals(MeasureAggregator msrAggregator){
+         return compareTo(msrAggregator)==0;
+     }*/
+     
+
+    @Override
+    public int compareTo(MeasureAggregator o)
+    {
+        BigDecimal value = getBigDecimalValue();
+        BigDecimal otherVal = o.getBigDecimalValue();
+
+        return value.compareTo(otherVal);
+    }
+
+    
+
+    @Override
+    public void merge(byte[] value)
+    {
+        if(0 == value.length)
+        {
+            return;
+        }
+
+        ByteBuffer buffer = ByteBuffer.wrap(value);
+        byte[] valueByte = new byte[buffer.getInt()];
+        buffer.get(valueByte);
+        BigDecimal valueBigDecimal = new BigDecimal(new String(valueByte));
+        aggVal = aggVal.add(valueBigDecimal);
+        firstTime = false;
+    }
+    
+    @Override
+    public MeasureAggregator get()
+    {
+        return this;
+    }
+    
+    public String toString()
+    {
+        return aggVal+"";
+    }
+}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumDistinctAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumDistinctAggregator.java
deleted file mode 100644
index eba05b2..0000000
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumDistinctAggregator.java
+++ /dev/null
@@ -1,273 +0,0 @@
-package com.huawei.unibi.molap.engine.aggregator.impl;
-
-import java.io.DataInput;
-import java.io.DataOutput;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Set;
-
-import com.huawei.unibi.molap.constants.MolapCommonConstants;
-import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
-
-/**
- * @author K00900207
- * 
- *         <p>
- *         The sum distinct aggregator
- *         <p>
- *         Ex:
- *         <p>
- *         ID NAME Sales
- *         <p>
- *         1 a 200
- *         <p>
- *         2 a 100
- *         <p>
- *         3 a 200
- *         <p>
- *         select sum(distinct sales) # would result 300
- */
-/**
- * @author K00900207
- *
- */
-/**
- * @author K00900207
- *
- */
-public class SumDistinctAggregator implements MeasureAggregator
-{
-    
-    /**
-     * 
-     */
-    private static final long serialVersionUID = 6313463368629960155L;
-    
-    /**
-     * For Spark MOLAP to avoid heavy object transfer it better to flatten the
-     * Aggregators. There is no aggregation expected after setting this value.
-     */
-    private Double computedFixedValue;
-
-   
-
-    /**
-     * 
-     */
-    private Set<Double> valueSet;
-
-    public SumDistinctAggregator()
-    {
-        valueSet = new HashSet<Double>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
-    }
-
-    /**
-     * just need to add the unique values to agg set
-     */
-    @Override
-    public void agg(double newVal, byte[] key, int offset, int length)
-    {
-        valueSet.add(newVal);
-    }
-
-    /**
-     * Distinct Aggregate function which update the Distinct set
-     * 
-     * @param newVal
-     *            new value
-     * @param key
-     *            mdkey
-     * @param offset
-     *            key offset
-     * @param length
-     *            length to be considered
-     * 
-     */
-    @Override
-    public void agg(Object newVal, byte[] key, int offset, int length)
-    {
-        valueSet.add(newVal instanceof Double ? (Double)newVal : new Double(newVal.toString()));
-    }
-
-    /**
-     * Below method will be used to get the value byte array
-     */
-    @Override
-    public byte[] getByteArray()
-    {
-        Iterator<Double> iterator = valueSet.iterator();
-        ByteBuffer buffer = ByteBuffer.allocate(valueSet.size() * MolapCommonConstants.DOUBLE_SIZE_IN_BYTE);
-        // CHECKSTYLE:OFF Approval No:Approval-V3R8C00_018
-        while(iterator.hasNext())
-        { // CHECKSTYLE:ON
-            buffer.putDouble(iterator.next());
-        }
-        buffer.rewind();
-        return buffer.array();
-    }
-
-    @Override
-    public void agg(double newVal, double factCount)
-    {
-        valueSet.add(newVal);
-    }
-
-    private void agg(Set<Double> set2)
-    {
-        valueSet.addAll(set2);
-    }
-
-    /**
-     * merge the valueset so that we get the count of unique values
-     */
-    @Override
-    public void merge(MeasureAggregator aggregator)
-    {
-        SumDistinctAggregator distinctAggregator = (SumDistinctAggregator)aggregator;
-        agg(distinctAggregator.valueSet);
-    }
-
-    @Override
-    public double getValue()
-    {
-        if(computedFixedValue == null)
-        {
-            double result = 0;
-            for(Double aValue : valueSet)
-            {
-                result += aValue;
-            }
-            return result;
-        }
-        return computedFixedValue;
-    }
-
-    @Override
-    public Object getValueObject()
-    {
-        return getValue();
-    }
-
-    /**
-     * 
-     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(double)
-     * 
-     */
-    @Override
-    public void setNewValue(double newValue)
-    {
-        computedFixedValue = newValue;
-        valueSet = null;
-    }
-
-    @Override
-    public boolean isFirstTime()
-    {
-        return false;
-    }
-
-    @Override
-    public void writeData(DataOutput dataOutput) throws IOException
-    {
-        if(computedFixedValue != null)
-        {
-            ByteBuffer byteBuffer = ByteBuffer.allocate(4 + 8);
-            byteBuffer.putInt(-1);
-            byteBuffer.putDouble(computedFixedValue);
-            byteBuffer.flip();
-            dataOutput.write(byteBuffer.array());
-        }
-        else
-        {
-            int length = valueSet.size() * 8;
-            ByteBuffer byteBuffer = ByteBuffer.allocate(length + 4 + 1);
-            byteBuffer.putInt(length);
-            for(double val : valueSet)
-            {
-                byteBuffer.putDouble(val);
-            }
-            byteBuffer.flip();
-            dataOutput.write(byteBuffer.array());
-        }
-    }
-
-  
-    @Override
-    public MeasureAggregator get()
-    {
-        return this;
-    }
-
-    public String toString()
-    {
-        if(computedFixedValue == null)
-        {
-            return valueSet.size() + "";
-        }
-        return computedFixedValue + "";
-    }
-
-    @Override
-    public void merge(byte[] value)
-    {
-        if(0 == value.length)
-        {
-            return;
-        }
-        ByteBuffer buffer = ByteBuffer.wrap(value);
-        buffer.rewind();
-        while(buffer.hasRemaining())
-        {
-            agg(buffer.getDouble(), null, 0, 0);
-        }
-    }
-    
-    @Override
-    public MeasureAggregator getCopy()
-    {
-        SumDistinctAggregator aggregator = new SumDistinctAggregator();
-        aggregator.valueSet = new HashSet<Double>(valueSet);
-        return aggregator;
-    }
-
-    @Override
-    public int compareTo(MeasureAggregator msr)
-    {
-        double msrValObj = getValue(); 
-        double otherVal = msr.getValue();
-        if(msrValObj > otherVal)
-        {
-            return 1;
-        }
-        if(msrValObj < otherVal)
-        {
-            return -1;
-        }
-        return 0;
-    }
-    
-    @Override
-    public void readData(DataInput inPut) throws IOException
-    {
-        int length = inPut.readInt();
-
-        if(length == -1)
-        {
-            computedFixedValue = inPut.readDouble();
-            valueSet = null;
-        }
-        else
-        {
-            length = length / 8;
-            valueSet = new HashSet<Double>(length + 1, 1.0f);
-            for(int i = 0;i < length;i++)
-            {
-                valueSet.add(inPut.readDouble());
-            }
-        }
-
-    }
-
-}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumDistinctBigDecimalAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumDistinctBigDecimalAggregator.java
new file mode 100644
index 0000000..16d926f
--- /dev/null
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumDistinctBigDecimalAggregator.java
@@ -0,0 +1,291 @@
+package com.huawei.unibi.molap.engine.aggregator.impl;
+
+import com.huawei.unibi.molap.constants.MolapCommonConstants;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.nio.ByteBuffer;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+
+/**
+ * @author K00900207
+ * 
+ *         <p>
+ *         The sum distinct aggregator
+ *         <p>
+ *         Ex:
+ *         <p>
+ *         ID NAME Sales
+ *         <p>
+ *         1 a 200
+ *         <p>
+ *         2 a 100
+ *         <p>
+ *         3 a 200
+ *         <p>
+ *         select sum(distinct sales) # would result 300
+ */
+/**
+ * @author K00900207
+ *
+ */
+
+/**
+ * @author K00900207
+ *
+ */
+public class SumDistinctBigDecimalAggregator implements MeasureAggregator
+{
+
+    /**
+     *
+     */
+    private static final long serialVersionUID = 6313463368629960155L;
+
+    /**
+     * For Spark MOLAP to avoid heavy object transfer it better to flatten the
+     * Aggregators. There is no aggregation expected after setting this value.
+     */
+    private BigDecimal computedFixedValue;
+
+
+
+    /**
+     *
+     */
+    private Set<BigDecimal> valueSet;
+
+    public SumDistinctBigDecimalAggregator()
+    {
+        valueSet = new HashSet<BigDecimal>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
+    }
+
+    /**
+     * just need to add the unique values to agg set
+     */
+    @Override
+    public void agg(double newVal)
+    {
+//        valueSet.add(newVal);
+    }
+
+    /**
+     * Distinct Aggregate function which update the Distinct set
+     *
+     * @param newVal
+     *            new value
+     *
+     */
+    @Override
+    public void agg(Object newVal)
+    {
+        valueSet.add(newVal instanceof BigDecimal ? (BigDecimal)newVal : new BigDecimal(newVal.toString()));
+    }
+
+    @Override
+    public void agg(MolapReadDataHolder newVal, int index)
+    {
+        BigDecimal valueBigDecimal = newVal.getReadableBigDecimalValueByIndex(index);
+        valueSet.add(valueBigDecimal);
+    }
+    /**
+     * Below method will be used to get the value byte array
+     */
+    @Override
+    public byte[] getByteArray()
+    {
+        Iterator<BigDecimal> iterator = valueSet.iterator();
+        ByteBuffer buffer = ByteBuffer.allocate(valueSet.size() * MolapCommonConstants.DOUBLE_SIZE_IN_BYTE);
+        // CHECKSTYLE:OFF Approval No:Approval-V3R8C00_018
+        while(iterator.hasNext())
+        { // CHECKSTYLE:ON
+            byte[] bytes = iterator.next().toString().getBytes();
+            buffer.putInt(bytes.length);
+            buffer.put(bytes);
+        }
+        buffer.rewind();
+        return buffer.array();
+    }
+
+//    @Override
+//    public void agg(double newVal, double factCount)
+//    {
+//        valueSet.add(newVal);
+//    }
+
+    private void agg(Set<BigDecimal> set2)
+    {
+        valueSet.addAll(set2);
+    }
+
+    /**
+     * merge the valueset so that we get the count of unique values
+     */
+    @Override
+    public void merge(MeasureAggregator aggregator)
+    {
+        SumDistinctBigDecimalAggregator distinctAggregator = (SumDistinctBigDecimalAggregator)aggregator;
+        agg(distinctAggregator.valueSet);
+    }
+
+    @Override
+    public Double getDoubleValue()
+    {
+        return null;
+    }
+
+    @Override
+    public Long getLongValue()
+    {
+        return null;
+    }
+
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        if(computedFixedValue == null)
+        {
+            BigDecimal result = new BigDecimal(0);
+            for(BigDecimal aValue : valueSet)
+            {
+                result = result.add(aValue);
+            }
+            return result;
+        }
+        return computedFixedValue;
+    }
+    @Override
+    public Object getValueObject()
+    {
+        return getBigDecimalValue();
+    }
+
+    /**
+     *
+     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(Object)
+     *
+     */
+    @Override
+    public void setNewValue(Object newValue)
+    {
+        computedFixedValue = (BigDecimal)newValue;
+        valueSet = null;
+    }
+
+    @Override
+    public boolean isFirstTime()
+    {
+        return false;
+    }
+
+    @Override
+    public void writeData(DataOutput dataOutput) throws IOException
+    {
+        if(computedFixedValue != null)
+        {
+            byte[] bytes = computedFixedValue.toString().getBytes();
+            ByteBuffer byteBuffer = ByteBuffer.allocate(4 + 4 + bytes.length);
+            byteBuffer.putInt(-1);
+            byteBuffer.putInt(bytes.length);
+            byteBuffer.put(bytes);
+            byteBuffer.flip();
+            dataOutput.write(byteBuffer.array());
+        }
+        else
+        {
+            int length = valueSet.size() * 8 + valueSet.size() * 4;
+            ByteBuffer byteBuffer = ByteBuffer.allocate(length + 4 + 1);
+            byteBuffer.putInt(length);
+            for(BigDecimal val : valueSet)
+            {
+                byte[] bytes = val.toString().getBytes();
+                byteBuffer.putInt(-1);
+                byteBuffer.putInt(bytes.length);
+                byteBuffer.put(bytes);
+            }
+            byteBuffer.flip();
+            dataOutput.write(byteBuffer.array());
+        }
+    }
+
+
+    @Override
+    public MeasureAggregator get()
+    {
+        return this;
+    }
+
+    public String toString()
+    {
+        if(computedFixedValue == null)
+        {
+            return valueSet.size() + "";
+        }
+        return computedFixedValue + "";
+    }
+
+    @Override
+    public void merge(byte[] value)
+    {
+        if(0 == value.length)
+        {
+            return;
+        }
+        ByteBuffer buffer = ByteBuffer.wrap(value);
+        buffer.rewind();
+        while(buffer.hasRemaining())
+        {
+            byte[] valueByte = new byte[buffer.getInt()];
+            buffer.get(valueByte);
+            BigDecimal valueBigDecimal = new BigDecimal(new String(valueByte));
+            agg(valueBigDecimal);
+        }
+    }
+
+    @Override
+    public MeasureAggregator getCopy()
+    {
+        SumDistinctBigDecimalAggregator aggregator = new SumDistinctBigDecimalAggregator();
+        aggregator.valueSet = new HashSet<BigDecimal>(valueSet);
+        return aggregator;
+    }
+
+    @Override
+    public int compareTo(MeasureAggregator msr)
+    {
+        BigDecimal msrValObj = getBigDecimalValue();
+        BigDecimal otherVal = msr.getBigDecimalValue();
+
+        return msrValObj.compareTo(otherVal);
+    }
+    
+    @Override
+    public void readData(DataInput inPut) throws IOException
+    {
+        int length = inPut.readInt();
+
+        if(length == -1)
+        {
+            computedFixedValue = new BigDecimal(inPut.readUTF());
+            valueSet = null;
+        }
+        else
+        {
+            length = length / 8;
+            valueSet = new HashSet<BigDecimal>(length + 1, 1.0f);
+            for(int i = 0;i < length;i++)
+            {
+                valueSet.add(new BigDecimal(inPut.readUTF()));
+            }
+        }
+
+    }
+
+}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumDistinctDoubleAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumDistinctDoubleAggregator.java
new file mode 100644
index 0000000..76377d2
--- /dev/null
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumDistinctDoubleAggregator.java
@@ -0,0 +1,286 @@
+package com.huawei.unibi.molap.engine.aggregator.impl;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.nio.ByteBuffer;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+
+import com.huawei.unibi.molap.constants.MolapCommonConstants;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+
+/**
+ * @author K00900207
+ * 
+ *         <p>
+ *         The sum distinct aggregator
+ *         <p>
+ *         Ex:
+ *         <p>
+ *         ID NAME Sales
+ *         <p>
+ *         1 a 200
+ *         <p>
+ *         2 a 100
+ *         <p>
+ *         3 a 200
+ *         <p>
+ *         select sum(distinct sales) # would result 300
+ */
+/**
+ * @author K00900207
+ *
+ */
+/**
+ * @author K00900207
+ *
+ */
+public class SumDistinctDoubleAggregator implements MeasureAggregator
+{
+    
+    /**
+     * 
+     */
+    private static final long serialVersionUID = 6313463368629960155L;
+    
+    /**
+     * For Spark MOLAP to avoid heavy object transfer it better to flatten the
+     * Aggregators. There is no aggregation expected after setting this value.
+     */
+    private Double computedFixedValue;
+
+   
+
+    /**
+     * 
+     */
+    private Set<Double> valueSet;
+
+    public SumDistinctDoubleAggregator()
+    {
+        valueSet = new HashSet<Double>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
+    }
+
+    /**
+     * just need to add the unique values to agg set
+     */
+    @Override
+    public void agg(double newVal)
+    {
+        valueSet.add(newVal);
+    }
+
+    /**
+     * Distinct Aggregate function which update the Distinct set
+     * 
+     * @param newVal
+     *            new value
+     * 
+     */
+    @Override
+    public void agg(Object newVal)
+    {
+        valueSet.add(newVal instanceof Double ? (Double)newVal : new Double(newVal.toString()));
+    }
+
+    @Override
+    public void agg(MolapReadDataHolder newVal, int index)
+    {
+        valueSet.add(newVal.getReadableDoubleValueByIndex(index));
+    }
+    /**
+     * Below method will be used to get the value byte array
+     */
+    @Override
+    public byte[] getByteArray()
+    {
+        Iterator<Double> iterator = valueSet.iterator();
+        ByteBuffer buffer = ByteBuffer.allocate(valueSet.size() * MolapCommonConstants.DOUBLE_SIZE_IN_BYTE);
+        // CHECKSTYLE:OFF Approval No:Approval-V3R8C00_018
+        while(iterator.hasNext())
+        { // CHECKSTYLE:ON
+            buffer.putDouble(iterator.next());
+        }
+        buffer.rewind();
+        return buffer.array();
+    }
+
+//    @Override
+//    public void agg(double newVal, double factCount)
+//    {
+//        valueSet.add(newVal);
+//    }
+
+    private void agg(Set<Double> set2)
+    {
+        valueSet.addAll(set2);
+    }
+
+    /**
+     * merge the valueset so that we get the count of unique values
+     */
+    @Override
+    public void merge(MeasureAggregator aggregator)
+    {
+        SumDistinctDoubleAggregator distinctAggregator = (SumDistinctDoubleAggregator)aggregator;
+        agg(distinctAggregator.valueSet);
+    }
+
+    @Override
+    public Double getDoubleValue()
+    {
+        if(computedFixedValue == null)
+        {
+            double result = 0;
+            for(Double aValue : valueSet)
+            {
+                result += aValue;
+            }
+            return result;
+        }
+        return computedFixedValue;
+    }
+
+    @Override
+    public Long getLongValue()
+    {
+        return null;
+    }
+
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        return null;
+    }
+    @Override
+    public Object getValueObject()
+    {
+        return getDoubleValue();
+    }
+
+    /**
+     * 
+     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(Object)
+     * 
+     */
+    @Override
+    public void setNewValue(Object newValue)
+    {
+        computedFixedValue = (Double)newValue;
+        valueSet = null;
+    }
+
+    @Override
+    public boolean isFirstTime()
+    {
+        return false;
+    }
+
+    @Override
+    public void writeData(DataOutput dataOutput) throws IOException
+    {
+        if(computedFixedValue != null)
+        {
+            ByteBuffer byteBuffer = ByteBuffer.allocate(4 + 8);
+            byteBuffer.putInt(-1);
+            byteBuffer.putDouble(computedFixedValue);
+            byteBuffer.flip();
+            dataOutput.write(byteBuffer.array());
+        }
+        else
+        {
+            int length = valueSet.size() * 8;
+            ByteBuffer byteBuffer = ByteBuffer.allocate(length + 4 + 1);
+            byteBuffer.putInt(length);
+            for(double val : valueSet)
+            {
+                byteBuffer.putDouble(val);
+            }
+            byteBuffer.flip();
+            dataOutput.write(byteBuffer.array());
+        }
+    }
+
+  
+    @Override
+    public MeasureAggregator get()
+    {
+        return this;
+    }
+
+    public String toString()
+    {
+        if(computedFixedValue == null)
+        {
+            return valueSet.size() + "";
+        }
+        return computedFixedValue + "";
+    }
+
+    @Override
+    public void merge(byte[] value)
+    {
+        if(0 == value.length)
+        {
+            return;
+        }
+        ByteBuffer buffer = ByteBuffer.wrap(value);
+        buffer.rewind();
+        while(buffer.hasRemaining())
+        {
+            agg(buffer.getDouble());
+        }
+    }
+    
+    @Override
+    public MeasureAggregator getCopy()
+    {
+        SumDistinctDoubleAggregator aggregator = new SumDistinctDoubleAggregator();
+        aggregator.valueSet = new HashSet<Double>(valueSet);
+        return aggregator;
+    }
+
+    @Override
+    public int compareTo(MeasureAggregator msr)
+    {
+        double msrValObj = getDoubleValue();
+        double otherVal = msr.getDoubleValue();
+        if(msrValObj > otherVal)
+        {
+            return 1;
+        }
+        if(msrValObj < otherVal)
+        {
+            return -1;
+        }
+        return 0;
+    }
+    
+    @Override
+    public void readData(DataInput inPut) throws IOException
+    {
+        int length = inPut.readInt();
+
+        if(length == -1)
+        {
+            computedFixedValue = inPut.readDouble();
+            valueSet = null;
+        }
+        else
+        {
+            length = length / 8;
+            valueSet = new HashSet<Double>(length + 1, 1.0f);
+            for(int i = 0;i < length;i++)
+            {
+                valueSet.add(inPut.readDouble());
+            }
+        }
+
+    }
+
+}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumDistinctLongAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumDistinctLongAggregator.java
new file mode 100644
index 0000000..de93b8f
--- /dev/null
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumDistinctLongAggregator.java
@@ -0,0 +1,287 @@
+package com.huawei.unibi.molap.engine.aggregator.impl;
+
+import com.huawei.unibi.molap.constants.MolapCommonConstants;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.nio.ByteBuffer;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+
+/**
+ * @author K00900207
+ * 
+ *         <p>
+ *         The sum distinct aggregator
+ *         <p>
+ *         Ex:
+ *         <p>
+ *         ID NAME Sales
+ *         <p>
+ *         1 a 200
+ *         <p>
+ *         2 a 100
+ *         <p>
+ *         3 a 200
+ *         <p>
+ *         select sum(distinct sales) # would result 300
+ */
+/**
+ * @author K00900207
+ *
+ */
+
+/**
+ * @author K00900207
+ *
+ */
+public class SumDistinctLongAggregator implements MeasureAggregator
+{
+
+    /**
+     *
+     */
+    private static final long serialVersionUID = 6313463368629960155L;
+
+    /**
+     * For Spark MOLAP to avoid heavy object transfer it better to flatten the
+     * Aggregators. There is no aggregation expected after setting this value.
+     */
+    private Long computedFixedValue;
+
+
+
+    /**
+     *
+     */
+    private Set<Long> valueSet;
+
+    public SumDistinctLongAggregator()
+    {
+        valueSet = new HashSet<Long>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
+    }
+
+    /**
+     * just need to add the unique values to agg set
+     */
+    @Override
+    public void agg(double newVal)
+    {
+//        valueSet.add(newVal);
+    }
+
+    /**
+     * Distinct Aggregate function which update the Distinct set
+     *
+     * @param newVal
+     *            new value
+     *
+     */
+    @Override
+    public void agg(Object newVal)
+    {
+        valueSet.add(newVal instanceof Long ? (Long)newVal : new Long(newVal.toString()));
+    }
+
+    @Override
+    public void agg(MolapReadDataHolder newVal, int index)
+    {
+        valueSet.add(newVal.getReadableLongValueByIndex(index));
+    }
+    /**
+     * Below method will be used to get the value byte array
+     */
+    @Override
+    public byte[] getByteArray()
+    {
+        Iterator<Long> iterator = valueSet.iterator();
+        ByteBuffer buffer = ByteBuffer.allocate(valueSet.size() * MolapCommonConstants.DOUBLE_SIZE_IN_BYTE);
+        // CHECKSTYLE:OFF Approval No:Approval-V3R8C00_018
+        while(iterator.hasNext())
+        { // CHECKSTYLE:ON
+            buffer.putLong(iterator.next());
+        }
+        buffer.rewind();
+        return buffer.array();
+    }
+
+//    @Override
+//    public void agg(double newVal, double factCount)
+//    {
+//        valueSet.add(newVal);
+//    }
+
+    private void agg(Set<Long> set2)
+    {
+        valueSet.addAll(set2);
+    }
+
+    /**
+     * merge the valueset so that we get the count of unique values
+     */
+    @Override
+    public void merge(MeasureAggregator aggregator)
+    {
+        SumDistinctLongAggregator distinctAggregator = (SumDistinctLongAggregator)aggregator;
+        agg(distinctAggregator.valueSet);
+    }
+
+    @Override
+    public Double getDoubleValue()
+    {
+        return null;
+    }
+
+    @Override
+    public Long getLongValue()
+    {
+        if(computedFixedValue == null)
+        {
+            long result = 0;
+            for(Long aValue : valueSet)
+            {
+                result += aValue;
+            }
+            return result;
+        }
+        return computedFixedValue;
+    }
+
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        return null;
+    }
+    @Override
+    public Object getValueObject()
+    {
+        return getLongValue();
+    }
+
+    /**
+     *
+     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(Object)
+     *
+     */
+    @Override
+    public void setNewValue(Object newValue)
+    {
+        computedFixedValue = (Long)newValue;
+        valueSet = null;
+    }
+
+    @Override
+    public boolean isFirstTime()
+    {
+        return false;
+    }
+
+    @Override
+    public void writeData(DataOutput dataOutput) throws IOException
+    {
+        if(computedFixedValue != null)
+        {
+            ByteBuffer byteBuffer = ByteBuffer.allocate(4 + 8);
+            byteBuffer.putInt(-1);
+            byteBuffer.putLong(computedFixedValue);
+            byteBuffer.flip();
+            dataOutput.write(byteBuffer.array());
+        }
+        else
+        {
+            int length = valueSet.size() * 8;
+            ByteBuffer byteBuffer = ByteBuffer.allocate(length + 4 + 1);
+            byteBuffer.putInt(length);
+            for(long val : valueSet)
+            {
+                byteBuffer.putLong(val);
+            }
+            byteBuffer.flip();
+            dataOutput.write(byteBuffer.array());
+        }
+    }
+
+
+    @Override
+    public MeasureAggregator get()
+    {
+        return this;
+    }
+
+    public String toString()
+    {
+        if(computedFixedValue == null)
+        {
+            return valueSet.size() + "";
+        }
+        return computedFixedValue + "";
+    }
+
+    @Override
+    public void merge(byte[] value)
+    {
+        if(0 == value.length)
+        {
+            return;
+        }
+        ByteBuffer buffer = ByteBuffer.wrap(value);
+        buffer.rewind();
+        while(buffer.hasRemaining())
+        {
+            agg(buffer.getLong());
+        }
+    }
+
+    @Override
+    public MeasureAggregator getCopy()
+    {
+        SumDistinctLongAggregator aggregator = new SumDistinctLongAggregator();
+        aggregator.valueSet = new HashSet<Long>(valueSet);
+        return aggregator;
+    }
+
+    @Override
+    public int compareTo(MeasureAggregator msr)
+    {
+        long msrValObj = getLongValue();
+        long otherVal = msr.getLongValue();
+        if(msrValObj > otherVal)
+        {
+            return 1;
+        }
+        if(msrValObj < otherVal)
+        {
+            return -1;
+        }
+        return 0;
+    }
+    
+    @Override
+    public void readData(DataInput inPut) throws IOException
+    {
+        int length = inPut.readInt();
+
+        if(length == -1)
+        {
+            computedFixedValue = inPut.readLong();
+            valueSet = null;
+        }
+        else
+        {
+            length = length / 8;
+            valueSet = new HashSet<Long>(length + 1, 1.0f);
+            for(int i = 0;i < length;i++)
+            {
+                valueSet.add(inPut.readLong());
+            }
+        }
+
+    }
+
+}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumDoubleAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumDoubleAggregator.java
new file mode 100644
index 0000000..2ac80a6
--- /dev/null
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumDoubleAggregator.java
@@ -0,0 +1,256 @@
+/*--------------------------------------------------------------------------------------------------------------------------*/
+/*!!Warning: This is a key information asset of Huawei Tech Co.,Ltd                                                         */
+/*CODEMARK:kOyQZYzjDpyGdBAEC2GaWmnksNUG9RKxzMKuuAYTdbJ5ajFrCnCGALet/FDi0nQqbEkSZoTs
+2wdXgejaKCr1dP3uE3wfvLHF9gW8+IdXbwdEVzw1icjfRowqz2DW4XzUpEhhSzBOwVynEHjc
+u0090fbnj+0VbOfZnjQdUjNGeZBp/OEV/ihcZz/8Bj30H6cdHtnLWokryD8YEIDSBoqj0HMv
+x2bWOm2rwPhsF8R5ByGyW4CmQm6QiI4mdcr/+CnCQ2iadvOiXEuMjfxMA+hszQ==*/
+/*--------------------------------------------------------------------------------------------------------------------------*/
+/**
+ *
+ * Copyright Notice
+ * =====================================
+ * This file contains proprietary information of
+ * Huawei Technologies India Pvt Ltd.
+ * Copying or reproduction without prior written approval is prohibited.
+ * Copyright (c) 2013
+ * =====================================
+ *
+ */
+package com.huawei.unibi.molap.engine.aggregator.impl;
+
+import com.huawei.unibi.molap.constants.MolapCommonConstants;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.nio.ByteBuffer;
+
+/**
+ * Project Name NSE V3R7C00
+ * 
+ * Module Name : Molap Engine
+ * 
+ * Author K00900841
+ * 
+ * Created Date :13-May-2013 3:35:33 PM
+ * 
+ * FileName : SumAggregator.java
+ * 
+ * Class Description : It will return sum of all the values
+ * 
+ * Version 1.0
+ */
+public class SumDoubleAggregator implements MeasureAggregator
+{
+
+    /**
+     * serialVersionUID
+     * 
+     */
+    private static final long serialVersionUID = 623750056131364540L;
+
+    /**
+     * aggregate value
+     */
+    private double aggVal;
+    
+    /**
+     * 
+     */
+    private boolean firstTime = true;
+
+    /**
+     * This method will update the aggVal it will add new value to aggVal
+     * 
+     * @param newVal
+     *            new value
+     * 
+     */
+    @Override
+    public void agg(double newVal)
+    {
+        aggVal += newVal;
+        firstTime = false;
+    }
+
+    /**
+     * This method will update the aggVal it will add new value to aggVal
+     * 
+     * @param newVal
+     *            new value
+     * 
+     */
+    @Override
+    public void agg(Object newVal)
+    {
+        aggVal += (Double)newVal;
+        firstTime = false;
+    }
+
+
+    public void agg(MolapReadDataHolder newVal,int index)
+    {
+        aggVal += newVal.getReadableDoubleValueByIndex(index);
+        firstTime = false;
+    }
+    /**
+     * Below method will be used to get the value byte array
+     */
+    @Override
+    public byte[] getByteArray()
+    {
+        if(firstTime)
+        {
+            return new byte[0];
+        }
+        ByteBuffer buffer = ByteBuffer.allocate(MolapCommonConstants.DOUBLE_SIZE_IN_BYTE);
+        buffer.putDouble(aggVal);
+        return buffer.array();
+    }
+    
+    /**
+     * This method will return aggVal
+     * 
+     * @return sum value
+     * 
+     */
+
+    @Override
+    public Double getDoubleValue()
+    {
+        return aggVal;
+    }
+
+
+    @Override
+    public Long getLongValue()
+    {
+        return null;
+    }
+
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        return null;
+    }
+    /* Merge the value, it will update the sum aggregate value it will add new
+     * value to aggVal
+     * 
+     * @param aggregator
+     *            SumAggregator
+     * 
+     */
+    @Override
+    public void merge(MeasureAggregator aggregator)
+    {
+        if(!aggregator.isFirstTime())
+        {
+            agg(aggregator.getDoubleValue());
+        }
+    }
+
+
+    /**
+     * This method return the sum value as an object
+     * 
+     * @return sum value as an object
+     */
+    @Override
+    public Object getValueObject()
+    {
+        return aggVal;
+    }
+
+    /**
+     * 
+     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(Object)
+     * 
+     */
+    @Override
+    public void setNewValue(Object newValue)
+    {
+        aggVal = (Double)newValue;
+    }
+
+    @Override
+    public boolean isFirstTime()
+    {
+        return firstTime;
+    }
+    
+    //TODO SIMIAN
+    @Override
+    public void readData(DataInput inPut) throws IOException
+    {
+        firstTime = inPut.readBoolean();
+        aggVal = inPut.readDouble();
+    }
+
+    @Override
+    public void writeData(DataOutput output) throws IOException
+    {
+        output.writeBoolean(firstTime);
+        output.writeDouble(aggVal);
+        
+    }
+
+  
+    @Override
+    public MeasureAggregator getCopy()
+    {
+        SumDoubleAggregator aggr = new SumDoubleAggregator();
+        aggr.aggVal = aggVal;
+        aggr.firstTime = firstTime;
+        return aggr; 
+    }
+    
+    //we are not comparing the Aggregator values 
+    /* public boolean equals(MeasureAggregator msrAggregator){
+         return compareTo(msrAggregator)==0;
+     }*/
+     
+
+    @Override
+    public int compareTo(MeasureAggregator o)
+    {
+        double value = getDoubleValue();
+        double otherVal = o.getDoubleValue();
+        if(value > otherVal)
+        {
+            return 1;
+        }
+        if(value < otherVal)
+        {
+            return -1;
+        }
+        return 0;
+    }
+
+    
+
+    @Override
+    public void merge(byte[] value)
+    {
+        if(0 == value.length)
+        {
+            return;
+        }
+        aggVal+= ByteBuffer.wrap(value).getDouble();
+        firstTime = false;
+    }
+    
+    @Override
+    public MeasureAggregator get()
+    {
+        return this;
+    }
+    
+    public String toString()
+    {
+        return aggVal+"";
+    }
+}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumLongAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumLongAggregator.java
new file mode 100644
index 0000000..a7114ea
--- /dev/null
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SumLongAggregator.java
@@ -0,0 +1,255 @@
+/*--------------------------------------------------------------------------------------------------------------------------*/
+/*!!Warning: This is a key information asset of Huawei Tech Co.,Ltd                                                         */
+/*CODEMARK:kOyQZYzjDpyGdBAEC2GaWmnksNUG9RKxzMKuuAYTdbJ5ajFrCnCGALet/FDi0nQqbEkSZoTs
+2wdXgejaKCr1dP3uE3wfvLHF9gW8+IdXbwdEVzw1icjfRowqz2DW4XzUpEhhSzBOwVynEHjc
+u0090fbnj+0VbOfZnjQdUjNGeZBp/OEV/ihcZz/8Bj30H6cdHtnLWokryD8YEIDSBoqj0HMv
+x2bWOm2rwPhsF8R5ByGyW4CmQm6QiI4mdcr/+CnCQ2iadvOiXEuMjfxMA+hszQ==*/
+/*--------------------------------------------------------------------------------------------------------------------------*/
+/**
+ *
+ * Copyright Notice
+ * =====================================
+ * This file contains proprietary information of
+ * Huawei Technologies India Pvt Ltd.
+ * Copying or reproduction without prior written approval is prohibited.
+ * Copyright (c) 2013
+ * =====================================
+ *
+ */
+package com.huawei.unibi.molap.engine.aggregator.impl;
+
+import com.huawei.unibi.molap.constants.MolapCommonConstants;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.nio.ByteBuffer;
+
+/**
+ * Project Name NSE V3R7C00
+ * 
+ * Module Name : Molap Engine
+ * 
+ * Author K00900841
+ * 
+ * Created Date :13-May-2013 3:35:33 PM
+ * 
+ * FileName : SumAggregator.java
+ * 
+ * Class Description : It will return sum of all the values
+ * 
+ * Version 1.0
+ */
+public class SumLongAggregator implements MeasureAggregator
+{
+
+    /**
+     * serialVersionUID
+     * 
+     */
+    private static final long serialVersionUID = 623750056131364540L;
+
+    /**
+     * aggregate value
+     */
+    private long aggVal;
+    
+    /**
+     * 
+     */
+    private boolean firstTime = true;
+
+    /**
+     * This method will update the aggVal it will add new value to aggVal
+     * 
+     * @param newVal
+     *            new value
+     * 
+     */
+    @Override
+    public void agg(double newVal)
+    {
+//        aggVal += newVal;
+//        firstTime = false;
+    }
+
+    /**
+     * This method will update the aggVal it will add new value to aggVal
+     * 
+     * @param newVal
+     *            new value
+     * 
+     */
+    @Override
+    public void agg(Object newVal)
+    {
+        aggVal += (long)newVal;
+        firstTime = false;
+    }
+
+
+    public void agg(MolapReadDataHolder newVal,int index)
+    {
+        aggVal += newVal.getReadableLongValueByIndex(index);
+        firstTime = false;
+    }
+    /**
+     * Below method will be used to get the value byte array
+     */
+    @Override
+    public byte[] getByteArray()
+    {
+        if(firstTime)
+        {
+            return new byte[0];
+        }
+        ByteBuffer buffer = ByteBuffer.allocate(MolapCommonConstants.LONG_SIZE_IN_BYTE);
+        buffer.putLong(aggVal);
+        return buffer.array();
+    }
+    
+    /**
+     * This method will return aggVal
+     * 
+     * @return sum value
+     * 
+     */
+
+    @Override
+    public Double getDoubleValue()
+    {
+        return null;
+    }
+
+
+    @Override
+    public Long getLongValue()
+    {
+        return aggVal;
+    }
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        return null;
+    }
+    /* Merge the value, it will update the sum aggregate value it will add new
+     * value to aggVal
+     * 
+     * @param aggregator
+     *            SumAggregator
+     * 
+     */
+    @Override
+    public void merge(MeasureAggregator aggregator)
+    {
+        if(!aggregator.isFirstTime())
+        {
+            agg(aggregator.getLongValue());
+        }
+    }
+
+
+    /**
+     * This method return the sum value as an object
+     * 
+     * @return sum value as an object
+     */
+    @Override
+    public Object getValueObject()
+    {
+        return aggVal;
+    }
+
+    /**
+     * 
+     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(Object)
+     * 
+     */
+    @Override
+    public void setNewValue(Object newValue)
+    {
+        aggVal = (long)newValue;
+    }
+
+    @Override
+    public boolean isFirstTime()
+    {
+        return firstTime;
+    }
+    
+    //TODO SIMIAN
+    @Override
+    public void readData(DataInput inPut) throws IOException
+    {
+        firstTime = inPut.readBoolean();
+        aggVal = inPut.readLong();
+    }
+
+    @Override
+    public void writeData(DataOutput output) throws IOException
+    {
+        output.writeBoolean(firstTime);
+        output.writeLong(aggVal);
+        
+    }
+
+  
+    @Override
+    public MeasureAggregator getCopy()
+    {
+        SumLongAggregator aggr = new SumLongAggregator();
+        aggr.aggVal = aggVal;
+        aggr.firstTime = firstTime;
+        return aggr; 
+    }
+    
+    //we are not comparing the Aggregator values 
+    /* public boolean equals(MeasureAggregator msrAggregator){
+         return compareTo(msrAggregator)==0;
+     }*/
+     
+
+    @Override
+    public int compareTo(MeasureAggregator o)
+    {
+        Long value = getLongValue();
+        Long otherVal = o.getLongValue();
+        if(value > otherVal)
+        {
+            return 1;
+        }
+        if(value < otherVal)
+        {
+            return -1;
+        }
+        return 0;
+    }
+
+    
+
+    @Override
+    public void merge(byte[] value)
+    {
+        if(0 == value.length)
+        {
+            return;
+        }
+        aggVal+= ByteBuffer.wrap(value).getLong();
+        firstTime = false;
+    }
+    
+    @Override
+    public MeasureAggregator get()
+    {
+        return this;
+    }
+    
+    public String toString()
+    {
+        return aggVal+"";
+    }
+}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SurrogateBasedDistinctCountAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SurrogateBasedDistinctCountAggregator.java
index c7562fc..e5e6db4 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SurrogateBasedDistinctCountAggregator.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/SurrogateBasedDistinctCountAggregator.java
@@ -7,8 +7,10 @@ import java.io.DataInputStream;
 import java.io.DataOutput;
 import java.io.DataOutputStream;
 import java.io.IOException;
+import java.math.BigDecimal;
 import java.nio.ByteBuffer;
 
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
 import org.roaringbitmap.RoaringBitmap;
 
 import com.huawei.iweb.platform.logging.LogService;
@@ -64,7 +66,7 @@ public class SurrogateBasedDistinctCountAggregator implements MeasureAggregator
      * just need to add the unique values to agg set
      */
     @Override
-    public void agg(double newVal, byte[] key, int offset, int length)
+    public void agg(double newVal)
     {//CHECKSTYLE:OFF    Approval No:Approval-V3R8C00_013
         int a = (int)newVal;//CHECKSTYLE:ON
         bitSet.add(a);
@@ -75,17 +77,18 @@ public class SurrogateBasedDistinctCountAggregator implements MeasureAggregator
      * 
      * @param newVal
      *            new value
-     * @param key
-     *            mdkey
-     * @param offset
-     *            key offset
-     * @param length
-     *            length to be considered
      * 
      */
     @Override
-    public void agg(Object newVal, byte[] key, int offset, int length)
+    public void agg(Object newVal)
     {
+        // Object include double
+        if(newVal instanceof Double)
+        {
+            agg((double)newVal);
+            return;
+        }
+
         byte[] values = (byte[])newVal;
         ByteBuffer buffer = ByteBuffer.wrap(values);
         buffer.rewind();
@@ -96,6 +99,11 @@ public class SurrogateBasedDistinctCountAggregator implements MeasureAggregator
         }
     }
 
+    public void agg(MolapReadDataHolder newVal,int index)
+    {
+        int a = (int)newVal.getReadableDoubleValueByIndex(index);//CHECKSTYLE:ON
+        bitSet.add(a);
+    }
     /**
      * Below method will be used to get the value byte array
      */
@@ -106,11 +114,11 @@ public class SurrogateBasedDistinctCountAggregator implements MeasureAggregator
     }
 
     
-    @Override
-    public void agg(double newVal, double factCount)
-    {
-        
-    }
+//    @Override
+//    public void agg(double newVal, double factCount)
+//    {
+//
+//    }
 
     private void agg(RoaringBitmap bitSet2)
     {
@@ -130,17 +138,39 @@ public class SurrogateBasedDistinctCountAggregator implements MeasureAggregator
     }
 
     @Override
-    public double getValue()
+    public Double getDoubleValue()
     {
         if(computedFixedValue == null)
         {
             readData();
-            return bitSet.getCardinality();
+            return (double)bitSet.getCardinality();
         }
         return computedFixedValue;
     }
 
     @Override
+    public Long getLongValue()
+    {
+        if(computedFixedValue == null)
+        {
+            readData();
+            return (long)bitSet.getCardinality();
+        }
+        return computedFixedValue.longValue();
+    }
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        if(computedFixedValue == null)
+        {
+            readData();
+            return new BigDecimal(bitSet.getCardinality());
+        }
+        return new BigDecimal(computedFixedValue);
+    }
+
+    @Override
     public Object getValueObject()
     {
         return bitSet.getCardinality();
@@ -148,13 +178,13 @@ public class SurrogateBasedDistinctCountAggregator implements MeasureAggregator
 
     /**
      * 
-     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(double)
+     * @see com.huawei.unibi.molap.engine.aggregator.MeasureAggregator#setNewValue(Object)
      * 
      */
     @Override
-    public void setNewValue(double newValue)
+    public void setNewValue(Object newValue)
     {
-        computedFixedValue = newValue;
+        computedFixedValue = (Double)newValue;
         bitSet = null;
     }
 
@@ -194,8 +224,8 @@ public class SurrogateBasedDistinctCountAggregator implements MeasureAggregator
     @Override
     public int compareTo(MeasureAggregator object)
     {
-        double val = getValue();
-        double otherVal = object.getValue();
+        double val = getDoubleValue();
+        double otherVal = object.getDoubleValue();
         if(val > otherVal) 
         {
             return 1;
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/dim/DistinctCountAggregatorForDim.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/dim/DistinctCountAggregatorForDim.java
index f77fe0a..0a4e468 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/dim/DistinctCountAggregatorForDim.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/impl/dim/DistinctCountAggregatorForDim.java
@@ -6,9 +6,11 @@ package com.huawei.unibi.molap.engine.aggregator.impl.dim;
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
+import java.math.BigDecimal;
 import java.util.HashSet;
 
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 import com.huawei.unibi.molap.engine.wrappers.ByteArrayWrapper;
 
@@ -63,8 +65,8 @@ public class DistinctCountAggregatorForDim implements MeasureAggregator
     @Override
     public int compareTo(MeasureAggregator msrAggrInfo) 
     {
-        double val = getValue();
-        double otherVal = msrAggrInfo.getValue();
+        double val = getDoubleValue();
+        double otherVal = msrAggrInfo.getDoubleValue();
         if(val > otherVal)
         {
             return 1;
@@ -77,23 +79,30 @@ public class DistinctCountAggregatorForDim implements MeasureAggregator
     }
 
     @Override
-    public void agg(double newVal, byte[] key, int offset, int length)
+    public void agg(double newVal)
     {
-    	wrapper.setData(key, offset, maxKey, maskByteRanges, maskByteLen);
-    	if(valueSet.add(wrapper))
-    	{
-    		wrapper = new ByteArrayWrapper();
-    	}
+        //TODO : new method's didn't have key and offset arguments
+//    	wrapper.setData(key, offset, maxKey, maskByteRanges, maskByteLen);
+//    	if(valueSet.add(wrapper))
+//    	{
+//    		wrapper = new ByteArrayWrapper();
+//    	}
     }
 
     @Override
-    public void agg(Object newVal, byte[] key, int offset, int length)
+    public void agg(Object newVal)
     {
-        wrapper.setData(key, offset, maxKey, maskByteRanges, maskByteLen);
-        if(valueSet.add(wrapper))
-        {
-            wrapper = new ByteArrayWrapper();
-        }
+//        wrapper.setData(key, offset, maxKey, maskByteRanges, maskByteLen);
+//        if(valueSet.add(wrapper))
+//        {
+//            wrapper = new ByteArrayWrapper();
+//        }
+    }
+
+    @Override
+    public void agg(MolapReadDataHolder newVal, int index)
+    {
+
     }
 
     @Override
@@ -103,21 +112,41 @@ public class DistinctCountAggregatorForDim implements MeasureAggregator
         return null;
     }
 
+//    @Override
+//    public void agg(double newVal, double factCount)
+//    {
+//        // TODO Auto-generated method stub
+//
+//    }
+
     @Override
-    public void agg(double newVal, double factCount)
+    public Double getDoubleValue()
     {
-        // TODO Auto-generated method stub
-        
+        if(computedFixedValue == null)
+        {
+            return (double)valueSet.size();
+        }
+        return computedFixedValue;
     }
 
     @Override
-    public double getValue()
+    public Long getLongValue()
     {
         if(computedFixedValue == null)
         {
-            return valueSet.size();
+            return (long)valueSet.size();
         }
-        return computedFixedValue;
+        return computedFixedValue.longValue();
+    }
+
+    @Override
+    public BigDecimal getBigDecimalValue()
+    {
+        if(computedFixedValue == null)
+        {
+            return new BigDecimal(valueSet.size());
+        }
+        return new BigDecimal(computedFixedValue);
     }
 
     @Override
@@ -135,9 +164,9 @@ public class DistinctCountAggregatorForDim implements MeasureAggregator
     }
 
     @Override
-    public void setNewValue(double newValue)
+    public void setNewValue(Object newValue)
     {
-        computedFixedValue = newValue;
+        computedFixedValue = (Double)newValue;
         valueSet = null;
     }
 
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/util/AggUtil.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/util/AggUtil.java
index 02774f3..120ca47 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/util/AggUtil.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/aggregator/util/AggUtil.java
@@ -6,12 +6,14 @@ u0090Yk4s7KSKIUvZ2lgA/xp4ghb3aurzQANDt/emqkEblEQAOjeMe559FD3SF5oC/1/UgVk
 e/uIo4p0QwQECisBIIwb092Y0KGWLGhqeMYznisGeN+b36Lz9EW6cIC2XtwC5w==*/
 /*--------------------------------------------------------------------------------------------------------------------------*/
 /**
- * 
+ *
  */
 package com.huawei.unibi.molap.engine.aggregator.util;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
+import java.math.BigDecimal;
+import java.util.HashMap;
 import java.util.List;
 
 import com.huawei.iweb.platform.logging.LogService;
@@ -20,47 +22,38 @@ import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.engine.aggregator.CustomMeasureAggregator;
 import com.huawei.unibi.molap.engine.aggregator.CustomMolapAggregateExpression;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
-import com.huawei.unibi.molap.engine.aggregator.impl.AvgAggregator;
-import com.huawei.unibi.molap.engine.aggregator.impl.AvgOfAvgAggregator;
-import com.huawei.unibi.molap.engine.aggregator.impl.CalculatedMeasureAggregatorImpl;
-import com.huawei.unibi.molap.engine.aggregator.impl.CountAggregator;
-import com.huawei.unibi.molap.engine.aggregator.impl.DistinctCountAggregator;
-import com.huawei.unibi.molap.engine.aggregator.impl.DistinctCountAggregatorObjectSet;
-import com.huawei.unibi.molap.engine.aggregator.impl.DistinctStringCountAggregator;
-import com.huawei.unibi.molap.engine.aggregator.impl.DummyAggregator;
-import com.huawei.unibi.molap.engine.aggregator.impl.MaxAggregator;
-import com.huawei.unibi.molap.engine.aggregator.impl.MinAggregator;
-import com.huawei.unibi.molap.engine.aggregator.impl.SumAggregator;
-import com.huawei.unibi.molap.engine.aggregator.impl.SumDistinctAggregator;
-import com.huawei.unibi.molap.engine.aggregator.impl.SurrogateBasedDistinctCountAggregator;
+import com.huawei.unibi.molap.engine.executer.MolapQueryExecutorModel;
+import com.huawei.unibi.molap.engine.aggregator.impl.*;
 import com.huawei.unibi.molap.engine.executer.calcexp.MolapCalcFunction;
 import com.huawei.unibi.molap.engine.util.MolapEngineLogEvent;
 import com.huawei.unibi.molap.keygenerator.KeyGenerator;
 import com.huawei.unibi.molap.metadata.CalculatedMeasure;
+import com.huawei.unibi.molap.metadata.MolapMetadata;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Measure;
+import com.huawei.unibi.molap.olap.SqlStatement;
 
 /**
  * Project Name NSE V3R7C00
- * 
+ *
  * Module Name : Molap Engine
- * 
+ *
  * Author K00900841
- * 
+ *
  * Created Date :13-May-2013 3:35:33 PM
- * 
+ *
  * FileName : AggUtil.java
- * 
+ *
  * Class Description : AggUtil class for aggregate classes It will return
  * aggregator instance for measures
- * 
+ *
  * Version 1.0
  */
 public final class AggUtil
 {
-    
+
     private AggUtil()
     {
-        
+
     }
     /**
      * Attribute for Molap LOGGER
@@ -68,11 +61,87 @@ public final class AggUtil
     private static final LogService LOGGER = LogServiceFactory
             .getLogService(AggUtil.class.getName());
 
+    /**
+     * type of Measure
+     */
+    private  static HashMap<Integer,SqlStatement.Type> queryMeasureType= new HashMap<>();
+
+    /**
+     * measure ordinal number
+     */
+    public static int[] measureOrdinal;
+
+    /**
+     * all measures
+     */
+    public static SqlStatement.Type[] allMeasures;
+    
+    /**
+     * initialize measureType
+     */
+    public static void initMeasureType(MolapQueryExecutorModel queryModel)
+    {
+        int ordinal;
+        //This part is used to initialize measure types for normal query
+        measureOrdinal = new int[queryModel.getMsrs().size()];
+        for(int i = 0; i < queryModel.getMsrs().size();i++)
+        {
+            ordinal = queryModel.getMsrs().get(i).getOrdinal();
+            queryMeasureType.put(ordinal,queryModel.getMsrs().get(i).getDataType());
+            measureOrdinal[i] = ordinal;
+        }
+        //This psrt is used to initialize all mesure types.
+        List<Measure> measures = queryModel.getCube().getMeasures(queryModel.getCube().getFactTableName());
+        allMeasures = new SqlStatement.Type[measures.size()];
+        for(int j = 0;j < measures.size();j++)
+        {
+            allMeasures[j] = measures.get(j).getDataType();
+        }
+    }
+
+    /**
+     * initialize measureType
+     */
+    public static void initMeasureType(Measure[] measures)
+    {
+        int ordinal;
+        measureOrdinal = new int[measures.length];
+        for(int i = 0; i < measures.length;i++)
+        {
+            ordinal = measures[i].getOrdinal();
+            queryMeasureType.put(ordinal, measures[i].getDataType());
+            measureOrdinal[i] = ordinal;
+        }
+    }
+
+    /**
+     * get selected measureType
+     */
+    public static SqlStatement.Type getMeasureType(int measureOdinal)
+    {
+//        return measureType.get(measureOdinal);
+        if(allMeasures.length != 0)
+        {
+            return allMeasures[measureOdinal];
+        }
+        else
+        {
+            return queryMeasureType.get(measureOdinal);
+        }
+    }
+
+    /**
+     * get all measureType
+     */
+//    public static SqlStatement.Type getAllMeasureType(int index)
+//    {
+//        return allMeasures[index];
+//    }
+
 
     /**
-     * 
      * This method will return aggregate instance based on aggregate name
-     * 
+     *
      * @param aggregatorType
      *            aggregator Type
      * @param hasFactCount
@@ -82,29 +151,40 @@ public final class AggUtil
      * @param slice
      *            slice
      * @return MeasureAggregator
-     * 
-     * 
+     *
+     *
      */
-    public static MeasureAggregator getAggregator(String aggregatorType,boolean isHighCardinality, boolean hasFactCount, KeyGenerator generator,
-           boolean isSurrogateBasedDistinctCountRequired, double minValue) 
+    public static MeasureAggregator getAggregator(String aggregatorType, boolean hasFactCount, KeyGenerator generator,
+                                                  boolean isSurrogateBasedDistinctCountRequired, Object minValue, SqlStatement.Type dataType)
     {
         // this will be used for aggregate table because aggregate tables will
         // have one of the measure as fact count
         if(hasFactCount && MolapCommonConstants.AVERAGE.equalsIgnoreCase(aggregatorType))
         {
-            return new AvgOfAvgAggregator();
+            switch(dataType)
+            {
+                case BIGINT:
+
+                    return new AvgOfAvgLongAggregator();
+                case DECIMAL:
+
+                    return new AvgOfAvgBigDecimalAggregator();
+                default:
+
+                    return new AvgOfAvgDoubleAggregator();
+            }
         }
         else
         {
-            return getAggregator(aggregatorType,isHighCardinality, generator,isSurrogateBasedDistinctCountRequired, minValue);
+            return getAggregator(aggregatorType, generator,isSurrogateBasedDistinctCountRequired, minValue, dataType);
         }
     }
 
     /**
-     * 
+     *
      * Factory method, this method determines what agg needs to be given based
      * on MeasureAggregator type
-     * 
+     *
      * @param aggregatorType
      *            aggregate name
      * @param generator
@@ -112,12 +192,18 @@ public final class AggUtil
      * @param slice
      *            slice
      * @return MeasureAggregator
-     * 
-     * 
+     *
+     *
+     */
+
+    /*
+        get  Aggregator by dataType and aggregatorType
      */
-    private static MeasureAggregator getAggregator(String aggregatorType,boolean isHighCardinality, KeyGenerator generator,boolean isSurrogateGeneratedDistinctCount, double minValue)
+    private static MeasureAggregator getAggregator(String aggregatorType, KeyGenerator generator,
+                                                   boolean isSurrogateGeneratedDistinctCount, Object minValue, SqlStatement.Type dataType)
     {
         // get the MeasureAggregator based on aggregate type
+        isSurrogateGeneratedDistinctCount=false;
         if(MolapCommonConstants.MIN.equalsIgnoreCase(aggregatorType))
         {
             return new MinAggregator();
@@ -134,35 +220,81 @@ public final class AggUtil
         //
         else if(MolapCommonConstants.AVERAGE.equalsIgnoreCase(aggregatorType))
         {
-            return new AvgAggregator();
+            switch(dataType)
+            {
+                case BIGINT:
+
+                    return new AvgLongAggregator();
+                case DECIMAL:
+
+                    return new AvgBigDecimalAggregator();
+                default:
+
+                    return new AvgDoubleAggregator();
+            }
         }
         //
         else if(MolapCommonConstants.DISTINCT_COUNT.equalsIgnoreCase(aggregatorType))
         {
-            if(isHighCardinality)
+            if(isSurrogateGeneratedDistinctCount)
             {
-                return new DistinctStringCountAggregator();
+                return new SurrogateBasedDistinctCountAggregator();
             }
             return new DistinctCountAggregator(minValue);
         }
         else if(MolapCommonConstants.SUM.equalsIgnoreCase(aggregatorType))
         {
-            return new SumAggregator();
+//            return new SumAggregator();
+            switch(dataType)
+            {
+                case BIGINT:
+
+                    return new SumLongAggregator();
+                case DECIMAL:
+
+                    return new SumBigDecimalAggregator();
+                default:
+
+                    return new SumDoubleAggregator();
+            }
         }
         else if(MolapCommonConstants.SUM_DISTINCT.equalsIgnoreCase(aggregatorType))
         {
-            return new SumDistinctAggregator();
+            switch(dataType)
+            {
+                case BIGINT:
+
+                    return new SumDistinctLongAggregator();
+                case DECIMAL:
+
+                    return new SumDistinctBigDecimalAggregator();
+                default:
+
+                    return new SumDistinctDoubleAggregator();
+            }
         }
         else if(MolapCommonConstants.DUMMY.equalsIgnoreCase(aggregatorType))
         {
-            return new DummyAggregator();
+            switch(dataType)
+            {
+                case BIGINT:
+
+                    return new DummyLongAggregator();
+                case DECIMAL:
+
+                    return new DummyBigDecimalAggregator();
+                default:
+
+                    return new DummyDoubleAggregator();
+            }
         }
         else
         {
             return null;
         }
     }
-    
+
+
     private static MeasureAggregator getCustomAggregator(String aggregatorType, String aggregatorClassName, KeyGenerator generator, String cubeUniqueName)
     {
         //
@@ -174,71 +306,71 @@ public final class AggUtil
         }
         catch(ClassNotFoundException e)
         {
-            LOGGER.error(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, e, 
-                    "No custom class named " 
-                    + aggregatorClassName + " was found");
+            LOGGER.error(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, e,
+                    "No custom class named "
+                            + aggregatorClassName + " was found");
         }
         //
         catch(SecurityException e)
         {
-            LOGGER.error(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, e, 
-                    "Security Exception while loading custom class " 
-                    + aggregatorClassName);
+            LOGGER.error(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, e,
+                    "Security Exception while loading custom class "
+                            + aggregatorClassName);
         }
         //
         catch(NoSuchMethodException e)
         {
-            LOGGER.error(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, e, 
-                    "Required constructor for custom class " 
-                    + aggregatorClassName + " not found");
+            LOGGER.error(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, e,
+                    "Required constructor for custom class "
+                            + aggregatorClassName + " not found");
         }
         catch(IllegalArgumentException e)
         {
-            LOGGER.error(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, e, 
-                    "IllegalArgumentException while loading custom class " 
-                    + aggregatorClassName);
+            LOGGER.error(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, e,
+                    "IllegalArgumentException while loading custom class "
+                            + aggregatorClassName);
         }
         //
         catch(InstantiationException e)
         {
-            LOGGER.error(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, e, 
-                    "InstantiationException while loading custom class " 
-                    + aggregatorClassName);
+            LOGGER.error(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, e,
+                    "InstantiationException while loading custom class "
+                            + aggregatorClassName);
         }
         //
         catch(IllegalAccessException e)
         {
-            LOGGER.error(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, e, 
-                    "IllegalAccessException while loading custom class " 
-                    + aggregatorClassName);
+            LOGGER.error(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, e,
+                    "IllegalAccessException while loading custom class "
+                            + aggregatorClassName);
         }
         catch(InvocationTargetException e)
         {
-            LOGGER.error(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, e, 
-                    "InvocationTargetException while loading custom class " 
-                    + aggregatorClassName);
+            LOGGER.error(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, e,
+                    "InvocationTargetException while loading custom class "
+                            + aggregatorClassName);
         }
         // return default sum aggregator in case something wrong happen and log it
-        LOGGER.info(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG,  
+        LOGGER.info(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG,
                 "Custom aggregator could not be loaded, " +
-                "returning the default Sum Aggregator");
+                        "returning the default Sum Aggregator");
         return null;
     }
 
     /**
      * This method determines what agg needs to be given for each individual
      * measures and based on hasFactCount, suitable avg ... aggs will be choosen
-     * 
+     *
      * @param measures
      * @param hasFactCount
      * @return
-     * 
+     *
      */
     public static MeasureAggregator[] getAggregatorsWithCubeName(Measure[] measures, boolean hasFactCount, KeyGenerator generator,
-            String cubeUniqueName)
+                                                                 String cubeUniqueName)
     {
         MeasureAggregator[] aggregators = new MeasureAggregator[measures.length];
-        
+
         int count=0;
         for(int i = 0;i < measures.length;i++)
         {
@@ -253,7 +385,7 @@ public final class AggUtil
         {
             isSurrogateBasedDistinctCountRequired = false;
         }
-        
+
         MeasureAggregator aggregator = null;
         for(int i = 0;i < measures.length;i++)
         {
@@ -266,8 +398,9 @@ public final class AggUtil
             }
             else
             {
-                
-                aggregator = getAggregator(aggName, hasFactCount, generator, measures[i].isSurrogateGenerated() && isSurrogateBasedDistinctCountRequired, measures[i].getMinValue());
+
+                aggregator = getAggregator(aggName, hasFactCount, generator, measures[i].isSurrogateGenerated() && isSurrogateBasedDistinctCountRequired,
+                        measures[i].getMinValue(), measures[i].getDataType());
             }
 //            if (aggregator == null) {
 //                 throw MondrianResource.instance().UnknownAggregator.ex(
@@ -277,18 +410,18 @@ public final class AggUtil
         }
         return aggregators;
     }
-    
+
     /**
      * This method determines what agg needs to be given for each individual
      * measures and based on hasFactCount, suitable avg ... aggs will be choosen
-     * 
+     *
      * @param measures
      * @param hasFactCount
      * @return
-     * 
+     *
      */
     public static MeasureAggregator[] getAggregators(Measure[] measures,MolapCalcFunction[] calculatedMeasures, boolean hasFactCount, KeyGenerator generator,
-            String slice)
+                                                     String slice)
     {
         int length = measures.length+calculatedMeasures.length;
         MeasureAggregator[] aggregators = new MeasureAggregator[length];
@@ -318,8 +451,9 @@ public final class AggUtil
             }
             else
             {
-                
-                aggregator = getAggregator(aggName, hasFactCount, generator,measures[i].isSurrogateGenerated() && isSurrogateBasedDistinctCountRequired, measures[i].getMinValue());
+
+                aggregator = getAggregator(aggName, hasFactCount, generator,measures[i].isSurrogateGenerated() && isSurrogateBasedDistinctCountRequired,
+                        measures[i].getMinValue(), measures[i].getDataType());
             }
 //            if (aggregator == null) {
 //                 throw MondrianResource.instance().UnknownAggregator.ex(
@@ -327,7 +461,7 @@ public final class AggUtil
 //            }
             aggregators[i] = aggregator;
         }
-        
+
         for(int i = 0;i < calculatedMeasures.length;i++)
         {
             CalculatedMeasureAggregatorImpl aggregatorImpl = new CalculatedMeasureAggregatorImpl(calculatedMeasures[i]);
@@ -335,18 +469,18 @@ public final class AggUtil
         }
         return aggregators;
     }
-    
+
     /**
      * This method determines what agg needs to be given for each individual
      * measures and based on hasFactCount, suitable avg ... aggs will be choosen
-     * 
+     *
      * @param measures
      * @param hasFactCount
      * @return
-     * 
+     *
      */
     public static MeasureAggregator[] getAggregators(Measure[] measures,CalculatedMeasure[] calculatedMeasures, boolean hasFactCount, KeyGenerator generator,
-            String slice)
+                                                     String slice)
     {
         int length = measures.length+calculatedMeasures.length;
         MeasureAggregator[] aggregators = new MeasureAggregator[length];
@@ -363,9 +497,9 @@ public final class AggUtil
         boolean isSurrogateBasedDistinctCountRequired = true;
         if(cnt > 1)
         {
-            isSurrogateBasedDistinctCountRequired = false; 
+            isSurrogateBasedDistinctCountRequired = false;
         }
-        for(int i = 0;i < measures.length;i++) 
+        for(int i = 0;i < measures.length;i++)
         {
             // based on MeasureAggregator name create the MeasureAggregator
             // object
@@ -376,8 +510,9 @@ public final class AggUtil
             }
             else
             {
-                
-                aggregatorInfo = getAggregator(aggName, hasFactCount, generator,measures[i].isSurrogateGenerated() && isSurrogateBasedDistinctCountRequired, measures[i].getMinValue());
+
+                aggregatorInfo = getAggregator(aggName, hasFactCount, generator,measures[i].isSurrogateGenerated() && isSurrogateBasedDistinctCountRequired,
+                        measures[i].getMinValue(), measures[i].getDataType());
             }
 //            if (aggregator == null) {
 //                 throw MondrianResource.instance().UnknownAggregator.ex(
@@ -385,7 +520,7 @@ public final class AggUtil
 //            }
             aggregators[i] = aggregatorInfo;
         }
-        
+
         for(int i = 0;i < calculatedMeasures.length;i++)
         {
             CalculatedMeasureAggregatorImpl aggregatorImpl = new CalculatedMeasureAggregatorImpl();
@@ -396,7 +531,7 @@ public final class AggUtil
 
     /**
      * This method determines what agg needs to be given for each aggregateNames
-     * 
+     *
      * @param aggregateNames
      *            list of MeasureAggregator name
      * @param hasFactCount
@@ -407,23 +542,24 @@ public final class AggUtil
      *            slice
      * @return MeasureAggregator array which will hold agrregator for each
      *         aggregateNames
-     * 
+     *
      */
     public static MeasureAggregator[] getAggregators(List<String> aggregateNames, boolean hasFactCount,
-            KeyGenerator generator)
+                                                     KeyGenerator generator)
     {
         int valueSize = aggregateNames.size();
         MeasureAggregator[] aggregators = new MeasureAggregator[valueSize];
         for(int i = 0;i < valueSize;i++)
         {
-            aggregators[i] = getAggregator(aggregateNames.get(i), hasFactCount, generator,false, 0);
+            SqlStatement.Type dataType = getMeasureType(measureOrdinal[i]);
+            aggregators[i] = getAggregator(aggregateNames.get(i), hasFactCount, generator,false, 0, dataType);
         }
         return aggregators;
     }
-    
+
     /**
      * This method determines what agg needs to be given for each aggregateNames
-     * 
+     *
      * @param aggregateNames
      *            list of MeasureAggregator name
      * @param hasFactCount
@@ -434,10 +570,10 @@ public final class AggUtil
      *            slice
      * @return MeasureAggregator array which will hold agrregator for each
      *         aggregateNames
-     * 
+     *
      */
     public static MeasureAggregator[] getAggregators(List<String> aggregateNames, List<String> aggregatorClassName,boolean hasFactCount,
-            KeyGenerator generator,String cubeUniqueName, double[] minValue)
+                                                     KeyGenerator generator,String cubeUniqueName, Object[] minValue)
     {
         int valueSize = aggregateNames.size();
         MeasureAggregator[] aggregators = new MeasureAggregator[valueSize];
@@ -449,61 +585,71 @@ public final class AggUtil
             }
             else
             {
-                aggregators[i] = getAggregator(aggregateNames.get(i), hasFactCount, generator,false,minValue[i]);
+                SqlStatement.Type dataType = getMeasureType(measureOrdinal[i]);
+                aggregators[i] = getAggregator(aggregateNames.get(i), hasFactCount, generator,false,minValue[i], dataType);
             }
         }
         return aggregators;
     }
-    
+
     /**
-     * 
+     *
      * This method will aggregate values to aggreator passed as a parameter and
      * return the aggregated value
-     * 
+     *
      * @param measureAggregator
      * @param value1
      * @param value2
      * @param factCount
      * @param factCount2
      * @return return aggreagted value
-     * 
+     *
      */
-    public static double aggregate(MeasureAggregator measureAggregator, double value1, double value2,
-            double factCount, double factCount2)  
+    public static Object aggregate(MeasureAggregator measureAggregator, double value1, double value2,
+                                   double factCount, double factCount2, SqlStatement.Type dataType)
     {
         // aggregate first value
-        measureAggregator.agg(value1, factCount); 
+        // just for test MaxAggregator
+        measureAggregator.agg(value1);
         // aggregate second value
-        measureAggregator.agg(value2, factCount2);
+        measureAggregator.agg(value2);
         // return the aggregated values
-        return measureAggregator.getValue();
+//        return measureAggregator.getValue();
+        switch (dataType)
+        {
+            case BIGINT:
+
+                return measureAggregator.getLongValue();
+            case DECIMAL:
+
+                BigDecimal valueBigDecimal = new BigDecimal(new String(measureAggregator.getByteArray()));
+                return valueBigDecimal;
+            default:
+
+                return measureAggregator.getLongValue();
+        }
     }
 
     public static MeasureAggregator[] getAggregators(String[] aggType, boolean hasFactCount,
-            KeyGenerator generator, String cubeUniqueName, double[] minValue,boolean[] highCardinalityTypes)
+                                                     KeyGenerator generator, String cubeUniqueName, Object[] minValue, SqlStatement.Type[] dataTypes)
     {
         MeasureAggregator[] aggregators = new MeasureAggregator[aggType.length];
         for(int i = 0;i < aggType.length;i++)
         {
-            if(null!=highCardinalityTypes)
-            {
-            aggregators[i]  = getAggregator(aggType[i],highCardinalityTypes[i], hasFactCount, generator, false, minValue[i]);
-            }
-            else
-            {
-                aggregators[i]  = getAggregator(aggType[i],false, hasFactCount, generator, false, minValue[i]);
-            }
+            SqlStatement.Type dataType = dataTypes[i];
+            aggregators[i]  = getAggregator(aggType[i], hasFactCount, generator, false, minValue[i], dataType);
         }
         return aggregators;
-        
+
     }
-    
+
     public static MeasureAggregator[] getAggregators(String[] aggType,
-            List<CustomMolapAggregateExpression> aggregateExpressions, boolean hasFactCount, KeyGenerator generator,
-            String cubeUniqueName, double[] minValue,boolean[] highCardinalityTypes)
+                                                     List<CustomMolapAggregateExpression> aggregateExpressions, boolean hasFactCount, KeyGenerator generator,
+                                                     String cubeUniqueName, Object[] minValue, SqlStatement.Type[] dataTypes)
     {
         MeasureAggregator[] aggregators = new MeasureAggregator[aggType.length];
         int customIndex=0;
+        int j = 0;
         for(int i = 0;i < aggType.length;i++)
         {
 
@@ -521,17 +667,11 @@ public final class AggUtil
             }
             else
             {
-                if(null != highCardinalityTypes)
-                {
-                    aggregators[i] = getAggregator(aggType[i],highCardinalityTypes[i], hasFactCount, generator, false, minValue[i]);
-                }
-                else
-                {
-                    aggregators[i] = getAggregator(aggType[i],false, hasFactCount, generator, false, minValue[i]);
-                }
+                SqlStatement.Type dataType = dataTypes[i];
+                aggregators[i] = getAggregator(aggType[i], hasFactCount, generator, false, minValue[i], dataType);
             }
         }
         return aggregators;
-    
+
     }
 }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/cache/QueryExecutorUtil.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/cache/QueryExecutorUtil.java
index 64faaa5..53d27b3 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/cache/QueryExecutorUtil.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/cache/QueryExecutorUtil.java
@@ -257,15 +257,23 @@ public final class QueryExecutorUtil
         Arrays.fill(max, 0L);
         for(int i = 0;i < queryDimensions.length;i++)
         {
-            if(queryDimensions[i].isHighCardinalityDim())
-            {
-                continue;
-            }
             max[queryDimensions[i].getOrdinal()] = Long.MAX_VALUE;
         }
         return generator.generateKey(max);
     }
     
+
+
+
+
+
+
+
+
+   
+
+    
+    
     
     public static void getFiltersFromIterator(int[] ordinals, MolapResultHolder iter,MolapFilterInfo filterInfo,boolean include)
     {
@@ -2513,26 +2521,10 @@ public final class QueryExecutorUtil
         for(int i = 0;i < queryDimensions.length;i++)
         {
 
-            
-			if(queryDimensions[i].isHighCardinalityDim())
-            {
-                continue;
-            }
-			else if(queryDimensions[i].getDataType() == SqlStatement.Type.ARRAY)
-            {
-                continue;
-            }
-            else if(queryDimensions[i].getDataType() == SqlStatement.Type.STRUCT)
-                continue;
-            else if(queryDimensions[i].getParentName() != null)
-                continue;
-            else
+            int[] range = generator.getKeyByteOffsets(queryDimensions[i].getOrdinal());
+            for(int j = range[0];j <= range[1];j++)
             {
-                int[] range = generator.getKeyByteOffsets(queryDimensions[i].getOrdinal());
-                for(int j = range[0];j <= range[1];j++)
-                {
-                    integers.add(j);
-                }
+                integers.add(j);
             }
 
         }
@@ -2643,28 +2635,4 @@ public final class QueryExecutorUtil
         return Arrays.equals(queryOrdinals, segmentOrdinals);
     }
     
-   /* public static int [] removeHighCardinalityDimOrdinal(int[] queryDimOrdinal, Dimension[] queryDimensions)
-    {
-        List<Integer> listOfOrdinal=new ArrayList<Integer>(queryDimensions.length);
-        int[] result = null;
-        for(int ordinal:queryDimOrdinal)
-        {
-            for(Dimension queryDimension:queryDimensions)
-            {
-                if(queryDimension.getOrdinal()==ordinal && !queryDimension.isHighCardinalityDim())
-                {
-                    listOfOrdinal.add(ordinal);
-                    //break;
-                }
-            }
-            
-        }
-        Integer[] arraysOfOrdinal=listOfOrdinal.toArray(new Integer [listOfOrdinal.size()]);
-        result = new int[arraysOfOrdinal.length];
-        for (int i = 0; i < arraysOfOrdinal.length; i++) {
-            result[i] = arraysOfOrdinal[i].intValue();
-        }
-        return result;
-    }*/
-    
 }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/ColumnarAggregatorInfo.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/ColumnarAggregatorInfo.java
index 823fe2a..e80279f 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/ColumnarAggregatorInfo.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/ColumnarAggregatorInfo.java
@@ -1,23 +1,15 @@
 package com.huawei.unibi.molap.engine.columnar.aggregator;
 
 import java.util.List;
-import java.util.Map;
 
 import com.huawei.unibi.molap.engine.aggregator.CustomMolapAggregateExpression;
 import com.huawei.unibi.molap.engine.aggregator.dimension.DimensionAggregatorInfo;
-import com.huawei.unibi.molap.engine.complex.querytypes.GenericQueryType;
 import com.huawei.unibi.molap.engine.datastorage.InMemoryCube;
 import com.huawei.unibi.molap.keygenerator.KeyGenerator;
-import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
+import com.huawei.unibi.molap.olap.SqlStatement;
 
 public class ColumnarAggregatorInfo
 {
-    private int queryDimensionsLength;
-    
-    private Map<Integer,GenericQueryType> complexQueryDims;
-    
-    private Dimension[] dimensions;
-    
     /**
      * slice
      */
@@ -41,7 +33,7 @@ public class ColumnarAggregatorInfo
     /**
      * uniqueValue
      */
-    private double[] uniqueValue;
+    private Object[] uniqueValue;
     
     /**
      * limit
@@ -76,7 +68,7 @@ public class ColumnarAggregatorInfo
     /**
      * minValue
      */
-    private double[] msrMinValue;
+    private Object[] msrMinValue;
     
     /**
      * measurIndex
@@ -121,12 +113,12 @@ public class ColumnarAggregatorInfo
     /**
      * msrDefaultValue
      */
-    private double[] msrDefaultValue;
-
+    private Object[] msrDefaultValue;
+    
     /**
-     * 
+     * array of sql datatypes of mesaures and dimensions
      */
-    private boolean[] highCardinalityTypes;
+    protected SqlStatement.Type[] dataTypes;
     
   
     /**
@@ -160,37 +152,7 @@ public class ColumnarAggregatorInfo
     {
         this.countMsrIndex = countMsrIndex;
     }
-    
-    public void setQueryDimensionsLength(int queryDimensionsLength)
-    {
-        this.queryDimensionsLength = queryDimensionsLength;
-    }
-    
-    public int getQueryDimensionsLength()
-    {
-        return queryDimensionsLength;
-    }
-    
-    public Dimension[] getDimensions()
-    {
-        return dimensions;
-    }
 
-    public void setDimensions(Dimension[] dimensions)
-    {
-        this.dimensions = dimensions;
-    }
-
-    public Map<Integer, GenericQueryType> getComplexQueryDims()
-    {
-        return complexQueryDims;
-    }
-
-    public void setComplexQueryDims(Map<Integer, GenericQueryType> complexQueryDims)
-    {
-        this.complexQueryDims = complexQueryDims;
-    }
-    
     /**
      * @return the avgMsrIndexes
      */
@@ -226,7 +188,7 @@ public class ColumnarAggregatorInfo
     /**
      * @return the uniqueValue
      */
-    public double[] getUniqueValue()
+    public Object[] getUniqueValue()
     {
         return uniqueValue;
     }
@@ -234,7 +196,7 @@ public class ColumnarAggregatorInfo
     /**
      * @param uniqueValue the uniqueValue to set
      */
-    public void setUniqueValue(double[] uniqueValue)
+    public void setUniqueValue(Object[] uniqueValue)
     {
         this.uniqueValue = uniqueValue;
     }
@@ -299,12 +261,12 @@ public class ColumnarAggregatorInfo
         this.aggType = aggType;
     }
 
-    public double[] getMsrMinValue()
+    public Object[] getMsrMinValue()
     {
         return msrMinValue;
     }
 
-    public void setMsrMinValue(double[] msrMinValue)
+    public void setMsrMinValue(Object[] msrMinValue)
     {
         this.msrMinValue = msrMinValue;
     }
@@ -389,32 +351,23 @@ public class ColumnarAggregatorInfo
         this.isMeasureExistis = isMeasureExistis;
     }
 
-    public double[] getMsrDefaultValue()
+    public Object[] getMsrDefaultValue()
     {
         return msrDefaultValue;
     }
 
-    public void setMsrDefaultValue(double[] msrDefaultValue)
+    public void setMsrDefaultValue(Object[] msrDefaultValue)
     {
         this.msrDefaultValue = msrDefaultValue;
     }
 
-    /**
-     * setHighCardinalityType.
-     * @param highCardinalityTypes
-     */
-    public void setHighCardinalityType(boolean[] highCardinalityTypes)
+    public SqlStatement.Type[] getDataTypes()
     {
-       this.highCardinalityTypes=highCardinalityTypes;
-        
+        return dataTypes;
     }
-    /**
-     * getHighCardinalityTypes.
-     * @return
-     */
-    public boolean[] getHighCardinalityTypes()
+
+    public void setDataTypes(SqlStatement.Type[] dataTypes)
     {
-        return highCardinalityTypes;
+        this.dataTypes = dataTypes;
     }
-
 }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/DataAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/DataAggregator.java
index 37b8c62..81120c6 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/DataAggregator.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/DataAggregator.java
@@ -7,7 +7,6 @@ import com.huawei.unibi.molap.engine.columnar.aggregator.impl.measure.AggregateT
 import com.huawei.unibi.molap.engine.columnar.aggregator.impl.measure.FactTableAggregator;
 import com.huawei.unibi.molap.engine.columnar.aggregator.impl.measure.MeasureDataAggregator;
 import com.huawei.unibi.molap.engine.columnar.keyvalue.AbstractColumnarScanResult;
-import com.huawei.unibi.molap.engine.wrappers.ByteArrayWrapper;
 
 public class DataAggregator
 {
@@ -32,9 +31,9 @@ public class DataAggregator
         expressionAggregator = new ExpressionAggregator(columnarAggregatorInfo);
     }
 
-    public void aggregateData(AbstractColumnarScanResult keyValue, MeasureAggregator[] currentMsrRowData, ByteArrayWrapper dimensionsRowWrapper)
+    public void aggregateData(AbstractColumnarScanResult keyValue, MeasureAggregator[] currentMsrRowData)
     {
-        dimensionDataAggreagtor.aggregateDimension(keyValue, currentMsrRowData,dimensionsRowWrapper);
+        dimensionDataAggreagtor.aggregateDimension(keyValue, currentMsrRowData);
         expressionAggregator.aggregateExpression(keyValue, currentMsrRowData);
         msrAggregator.aggregateMeasure(keyValue, currentMsrRowData);
     }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/ExpressionAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/ExpressionAggregator.java
index c29a7db..b737004 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/ExpressionAggregator.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/ExpressionAggregator.java
@@ -11,6 +11,7 @@ import com.huawei.unibi.molap.engine.util.DataTypeConverter;
 import com.huawei.unibi.molap.engine.util.QueryExecutorUtility;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Measure;
+import com.huawei.unibi.molap.olap.SqlStatement;
 
 /**
  * To handle aggregation for expressions in the query   
@@ -41,13 +42,9 @@ public class ExpressionAggregator
                 Dimension dimension = referredColumns.get(j);
                 if(dimension instanceof Measure)
                 {
-                    row[j]=keyValue.getNormalMeasureValue(dimension.getOrdinal());
-                }
-                else if(dimension.isHighCardinalityDim())
-                {
-                   byte[] directSurrogate= keyValue.getHighCardinalityDimDataForAgg(dimension);
-                   row[j]=DataTypeConverter.getDataBasedOnDataType(new String(directSurrogate),
-                           dimension.getDataType());
+                    SqlStatement.Type dataType = this.columnaraggreagtorInfo.getDataTypes()[this.columnaraggreagtorInfo
+                            .getMeasureStartIndex() + dimension.getOrdinal()];
+                    row[j] = keyValue.getNormalMeasureValue(dimension.getOrdinal(), dataType);
                 }
                 else
                 {
@@ -56,14 +53,11 @@ public class ExpressionAggregator
                     {
                         row[j]=null;
                     }
-                    else
-                    {
                     String member = QueryExecutorUtility
                     .getMemberBySurrogateKey(dimension, dimSurrogate,
                             columnaraggreagtorInfo.getSlices(), columnaraggreagtorInfo.getCurrentSliceIndex()).toString();
                     row[j]=DataTypeConverter.getDataBasedOnDataType(member,
                             dimension.getDataType());
-                    }
                 }
             }
             CustomMeasureAggregator agg = (CustomMeasureAggregator)currentMsrRowData[startIndex+i];
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/ListBasedResultAggregatorImpl.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/ListBasedResultAggregatorImpl.java
index ced2f0e..1992b30 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/ListBasedResultAggregatorImpl.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/ListBasedResultAggregatorImpl.java
@@ -59,24 +59,11 @@ public class ListBasedResultAggregatorImpl implements ColumnarScannedResultAggre
         while(keyValue.hasNext() && (limit == -1 || rowCounter < limit))
         {
             key = new ByteArrayWrapper();
-            //Primitives types selected
-            if(columnaraggreagtorInfo.getQueryDimensionsLength() == keyValue.getKeyBlockLength())
-            {
-                key.setMaskedKey(keyValue.getKeyArray());
-            }
-            else
-            {
-                //Complex columns selected.
-                List<byte[]> complexKeyArray = keyValue.getKeyArrayWithComplexTypes(this.columnaraggreagtorInfo.getComplexQueryDims());
-                key.setMaskedKey(complexKeyArray.remove(complexKeyArray.size() - 1));
-                for(byte[] complexKey : complexKeyArray)
-                {
-                    key.addComplexTypeData(complexKey);
-                }
-            }
+            key.setMaskedKey(keyValue.getKeyArray());
             value = AggUtil.getAggregators(columnaraggreagtorInfo.getAggType(), isAggTable, null,
-                        columnaraggreagtorInfo.getCubeUniqueName(),columnaraggreagtorInfo.getMsrMinValue(),columnaraggreagtorInfo.getHighCardinalityTypes());
-            dataAggregator.aggregateData(keyValue, value,key);
+                    columnaraggreagtorInfo.getCubeUniqueName(), columnaraggreagtorInfo.getMsrMinValue(),
+                    columnaraggreagtorInfo.getDataTypes());
+            dataAggregator.aggregateData(keyValue, value);
             keys.add(key);
             values.add(value);
             rowCounter++;
@@ -137,13 +124,10 @@ public class ListBasedResultAggregatorImpl implements ColumnarScannedResultAggre
                         updatedData[data.length+k]=restructureHolder.metaData.getNewDimsSurrogateKeys()[k];
                     }
                 }
-                if(restructureHolder.getQueryDimsCount() == columnaraggreagtorInfo.getLatestKeyGenerator().getDimCount())
-                {
-                    key.setMaskedKey(QueryExecutorUtility.getMaskedKey(columnaraggreagtorInfo.getLatestKeyGenerator()
+                key.setMaskedKey(QueryExecutorUtility.getMaskedKey(columnaraggreagtorInfo.getLatestKeyGenerator()
                         .generateKey(updatedData), columnaraggreagtorInfo.getActualMaxKeyBasedOnDimensions(),
                         columnaraggreagtorInfo.getActalMaskedByteRanges(), columnaraggreagtorInfo
                                 .getActualMaskedKeyByteSize()));
-                }
                 finalKeys.add(key);
                 finalValues.add(values.get(i));
             }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/MapBasedResultAggregatorImpl.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/MapBasedResultAggregatorImpl.java
index 28e7b85..6633cb0 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/MapBasedResultAggregatorImpl.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/MapBasedResultAggregatorImpl.java
@@ -2,7 +2,6 @@ package com.huawei.unibi.molap.engine.columnar.aggregator.impl;
 
 import java.util.Arrays;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 
@@ -62,39 +61,24 @@ public class MapBasedResultAggregatorImpl implements ColumnarScannedResultAggreg
     @Override
     public int aggregateData(AbstractColumnarScanResult keyValue)
     {
-        ByteArrayWrapper dimensionsRowWrapper = null;
+        ByteArrayWrapper dimensionsRowWrapper = new ByteArrayWrapper(xxHash32);
         while(keyValue.hasNext())
         {
-            dimensionsRowWrapper = new ByteArrayWrapper();
-            //Primitives types selected
-            if(columnaraggreagtorInfo.getDimensionAggInfos().size() == keyValue.getKeyBlockLength())
-            {
-                dimensionsRowWrapper.setMaskedKey(keyValue.getKeyArray());
-            }
-            else
-            {
-                //Complex columns selected.
-                List<byte[]> complexKeyArray = keyValue.getKeyArrayWithComplexTypes(this.columnaraggreagtorInfo.getComplexQueryDims());
-                dimensionsRowWrapper.setMaskedKey(complexKeyArray.remove(complexKeyArray.size() - 1));
-                for(byte[] complexKey : complexKeyArray)
-                {
-                    dimensionsRowWrapper.addComplexTypeData(complexKey);
-                }
-            }
+            dimensionsRowWrapper.setMaskedKey(keyValue.getKeyArray());
             MeasureAggregator[] currentMsrRowData = aggData.get(dimensionsRowWrapper);
-            
             if(null == currentMsrRowData)
             {
                 currentMsrRowData = AggUtil.getAggregators(columnaraggreagtorInfo.getAggType(),
                         columnaraggreagtorInfo.getCustomExpressions(), isAggTable, null,
-                        columnaraggreagtorInfo.getCubeUniqueName(), columnaraggreagtorInfo.getMsrMinValue(),columnaraggreagtorInfo.getHighCardinalityTypes());
+                        columnaraggreagtorInfo.getCubeUniqueName(), columnaraggreagtorInfo.getMsrMinValue(),
+                        columnaraggreagtorInfo.getDataTypes());
                 aggData.put(dimensionsRowWrapper, currentMsrRowData);
+                dimensionsRowWrapper = new ByteArrayWrapper(xxHash32);
             }
-            dataAggregator.aggregateData(keyValue, currentMsrRowData,dimensionsRowWrapper);
+            dataAggregator.aggregateData(keyValue, currentMsrRowData);
         }
         return 0;
     }
-    
 
     @Override
     public Result getResult(RestructureHolder restructureHolder)
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/dimension/DimensionDataAggreagtor.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/dimension/DimensionDataAggreagtor.java
index b7583aa..5d6171b 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/dimension/DimensionDataAggreagtor.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/dimension/DimensionDataAggreagtor.java
@@ -1,33 +1,20 @@
 package com.huawei.unibi.molap.engine.columnar.aggregator.impl.dimension;
 
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
-import com.huawei.iweb.platform.logging.LogService;
-import com.huawei.iweb.platform.logging.LogServiceFactory;
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 import com.huawei.unibi.molap.engine.aggregator.dimension.DimensionAggregatorInfo;
 import com.huawei.unibi.molap.engine.columnar.aggregator.ColumnarAggregatorInfo;
 import com.huawei.unibi.molap.engine.columnar.keyvalue.AbstractColumnarScanResult;
-import com.huawei.unibi.molap.engine.datastorage.Member;
-import com.huawei.unibi.molap.engine.complex.querytypes.GenericQueryType;
 import com.huawei.unibi.molap.engine.util.DataTypeConverter;
-import com.huawei.unibi.molap.engine.util.MolapEngineLogEvent;
 import com.huawei.unibi.molap.engine.util.QueryExecutorUtility;
-import com.huawei.unibi.molap.engine.wrappers.ByteArrayWrapper;
-import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
 import com.huawei.unibi.molap.olap.SqlStatement;
-import com.huawei.unibi.molap.olap.SqlStatement.Type;
 
 public class DimensionDataAggreagtor
 {
-    private static final LogService LOGGER = LogServiceFactory.getLogService(DimensionDataAggreagtor.class.getName());
 
     private int[][] dimCountAndDistinctCountAGGIndex;
 
@@ -112,79 +99,45 @@ public class DimensionDataAggreagtor
         }
     }
 
-    public void aggregateDimension(AbstractColumnarScanResult keyValue, MeasureAggregator[] currentMsrRowData, ByteArrayWrapper dimensionsRowWrapper)
+    public void aggregateDimension(AbstractColumnarScanResult keyValue, MeasureAggregator[] currentMsrRowData)
     {
         DimensionAggregatorInfo dimensionAggregatorInfo= null;
         int dimSurrogate = 0;
         for(int i = 0;i < dimensionAggInfos.size();i++)
         {
             dimensionAggregatorInfo = dimensionAggInfos.get(i);
-            
             if(!dimensionAggregatorInfo.isDimensionPresentInCurrentSlice())
             {
                 continue;
             }
-            else if(!dimensionAggregatorInfo.getDim().isHighCardinalityDim())
-            {
-             dimSurrogate = keyValue.getDimDataForAgg(dimensionAggregatorInfo.getDim().getOrdinal());
+            dimSurrogate = keyValue.getDimDataForAgg(dimensionAggregatorInfo.getDim().getOrdinal());
             Object dataBasedOnDataType = null;
-            byte[] complexSurrogates = null;
-            GenericQueryType complexType = null;
-            if(dimensionAggregatorInfo.getDim().getDataType() != Type.ARRAY &&  dimensionAggregatorInfo.getDim().getDataType() != Type.STRUCT)
-            {
-                dimSurrogate = keyValue.getDimDataForAgg(dimensionAggregatorInfo.getDim().getOrdinal());
-                if(dimSurrogate==1)
-                {
-                    break;
-                }
-            }
-            else
+            if(dimSurrogate==1)
             {
-                try
-                {
-                    complexType = this.columnaraggreagtorInfo.getComplexQueryDims().get(dimensionAggregatorInfo.getDim().getOrdinal());
-                    ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
-                    DataOutputStream dataOutputStream = new DataOutputStream(byteStream);
-                    keyValue.getComplexDimDataForAgg(complexType, dataOutputStream);
-                    complexSurrogates = byteStream.toByteArray();
-                    byteStream.close();
-                }
-                catch(IOException e)
-                {
-                    LOGGER.error(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, e);
-                }
+                break;
             }
             for(int j = 0;j < dimCountAndDistinctCountAGGIndex[i].length;j++)
             {
-                if(dimensionAggregatorInfo.getDim().getDataType() != Type.ARRAY &&  dimensionAggregatorInfo.getDim().getDataType() != Type.STRUCT)
+                if(dimensionAggregatorInfo.getDim().getDataType()!=SqlStatement.Type.STRING)
                 {
-                    if(dimensionAggregatorInfo.getDim().getDataType()!=SqlStatement.Type.STRING)
+                    if(null==dataBasedOnDataType)
                     {
-                        if(null==dataBasedOnDataType)
-                        {
-                            dataBasedOnDataType = QueryExecutorUtility
-                                    .getMemberBySurrogateKey(dimensionAggregatorInfo.getDim(), dimSurrogate,
-                                            columnaraggreagtorInfo.getSlices(), columnaraggreagtorInfo.getCurrentSliceIndex()).toString();
-                            dataBasedOnDataType = DataTypeConverter.getDataBasedOnDataType((String)dataBasedOnDataType,
-                                    dimensionAggregatorInfo.getDim().getDataType());
-                        }
-                        if(null!=dataBasedOnDataType)
-                        {
-                            currentMsrRowData[dimCountAndDistinctCountAGGIndex[i][j]].agg(dimSurrogate, null, 0, 0);
-                        }
+                        dataBasedOnDataType = QueryExecutorUtility
+                                .getMemberBySurrogateKey(dimensionAggregatorInfo.getDim(), dimSurrogate,
+                                        columnaraggreagtorInfo.getSlices(), columnaraggreagtorInfo.getCurrentSliceIndex()).toString();
+                        dataBasedOnDataType = DataTypeConverter.getDataBasedOnDataType((String)dataBasedOnDataType,
+                                dimensionAggregatorInfo.getDim().getDataType());
                     }
-                    else
+                    if(null!=dataBasedOnDataType)
                     {
-                        currentMsrRowData[dimCountAndDistinctCountAGGIndex[i][j]].agg(dimSurrogate, null, 0, 0);
+                        currentMsrRowData[dimCountAndDistinctCountAGGIndex[i][j]].agg(dimSurrogate);
                     }
                 }
                 else
                 {
-                    currentMsrRowData[dimCountAndDistinctCountAGGIndex[i][j]].agg(complexSurrogates, null, 0, 0);
-                    dataBasedOnDataType = complexType.getDataBasedOnDataTypeFromSurrogates(this.columnaraggreagtorInfo.getSlices(), ByteBuffer.wrap(complexSurrogates), this.columnaraggreagtorInfo.getDimensions());
+                    currentMsrRowData[dimCountAndDistinctCountAGGIndex[i][j]].agg(dimSurrogate);
                 }
             }
-            
             for(int j = 0;j < dimAggNormalIndex[i].length;j++)
             {
                 if(dataBasedOnDataType== null)
@@ -199,7 +152,7 @@ public class DimensionDataAggreagtor
 
                 if(dataBasedOnDataType instanceof Double)
                 {
-                    currentMsrRowData[dimAggNormalIndex[i][j]].agg(dataBasedOnDataType, null, 0, 0);
+                    currentMsrRowData[dimAggNormalIndex[i][j]].agg(dataBasedOnDataType);
                 }
                 else if(!((String)dataBasedOnDataType).equals(MolapCommonConstants.MEMBER_DEFAULT_VAL))
                 {
@@ -207,7 +160,7 @@ public class DimensionDataAggreagtor
                             SqlStatement.Type.DOUBLE);
                     if(null != dataBasedOnDataType)
                     {
-                        currentMsrRowData[dimAggNormalIndex[i][j]].agg(dataBasedOnDataType, null, 0, 0);
+                        currentMsrRowData[dimAggNormalIndex[i][j]].agg(dataBasedOnDataType);
                     }
                 }
             }
@@ -222,7 +175,7 @@ public class DimensionDataAggreagtor
                 }
                 if(dataBasedOnDataType instanceof Double)
                 {
-                    currentMsrRowData[dimAggMaxMinIndex[i][j]].agg(dataBasedOnDataType, null, 0, 0);
+                    currentMsrRowData[dimAggMaxMinIndex[i][j]].agg(dataBasedOnDataType);
                 }
                 else if(!((String)dataBasedOnDataType).equals(MolapCommonConstants.MEMBER_DEFAULT_VAL))
                 {
@@ -230,87 +183,10 @@ public class DimensionDataAggreagtor
                             dimensionAggregatorInfo.getDim().getDataType());
                     if(null != dataBasedOnDataType)
                     {
-                        currentMsrRowData[dimAggMaxMinIndex[i][j]].agg(dataBasedOnDataType, null, 0, 0);
+                        currentMsrRowData[dimAggMaxMinIndex[i][j]].agg(dataBasedOnDataType);
                     }
                 }
             }
-        
-        }
-        else
-        {
-            aggregateDirectDurrogateDims(keyValue,currentMsrRowData,dimensionAggregatorInfo.getDim(),i,dimensionsRowWrapper);
-            
-        }
-        
-        }
-        
-    }
-
-    /**
-     * For handling aggregation in case of direct surrogate keys columns.
-     * @param keyValue
-     * @param currentMsrRowData
-     * @param dim
-     * @param index
-     * @param dimensionsRowWrapper
-     */
-    private void aggregateDirectDurrogateDims(AbstractColumnarScanResult keyValue,
-            MeasureAggregator[] currentMsrRowData, Dimension dim,int index, ByteArrayWrapper dimensionsRowWrapper)
-    {
-        //since new byte array wrapper is been created and send for aggregation again system has to set the data to the byte array wrapper
-        if(null==dimensionsRowWrapper.getDirectSurrogateKeyList() || dimensionsRowWrapper.getDirectSurrogateKeyList().isEmpty() )
-        {
-            dimensionsRowWrapper.addToDirectSurrogateKeyList(keyValue.getHighCardinalityDimDataForAgg(dim));
-        }
-        String data = new String(keyValue.getHighCardinalityDimDataForAgg(dim));
-        if(MolapCommonConstants.MEMBER_DEFAULT_VAL.equals(data))
-        {
-            return;
-        }
-        
-        //Logic is for distinct count of dimensions, passing the members as string itself
-        for(int j = 0;j < dimCountAndDistinctCountAGGIndex[index].length;j++)
-        {
-
-                currentMsrRowData[dimCountAndDistinctCountAGGIndex[index][j]].agg(data,
-                  null, 0, 0);
-        }
-
-        Object dataBasedOnDataType = DataTypeConverter.getDataBasedOnDataType(data, dim.getDataType());
-        if(null==dataBasedOnDataType)
-        {
-            return;
-        }
-        //for handling other aggregations like sum and avg for normal dimensions
-        for(int j = 0;j < dimAggNormalIndex[index].length;j++)
-        {
-            if(dataBasedOnDataType == null)
-            {
-                dataBasedOnDataType = new Member(keyValue.getHighCardinalityDimDataForAgg(dim));
-            }
-            // Do not convert to double as the aggregator may work on
-            // different data types. Min & Max can work for String,
-            // TimeStamp,etc
-
-            if(dataBasedOnDataType instanceof Double)
-            {
-                currentMsrRowData[dimAggNormalIndex[index][j]].agg(dataBasedOnDataType, null, 0, 0);
-            }
-            else if(!(dataBasedOnDataType.toString()).equals(MolapCommonConstants.MEMBER_DEFAULT_VAL))
-            {
-                dataBasedOnDataType = DataTypeConverter.getDataBasedOnDataType(dataBasedOnDataType.toString(),
-                        SqlStatement.Type.DOUBLE);
-                if(null != dataBasedOnDataType)
-                {
-                    currentMsrRowData[dimAggNormalIndex[index][j]].agg(dataBasedOnDataType, null, 0, 0);
-                }
-            }
         }
-        //for handling max and min aggegator, passing the members as per the selected data type
-        for(int j = 0;j < dimAggMaxMinIndex[index].length;j++)
-        {
-             currentMsrRowData[dimAggMaxMinIndex[index][j]].agg(dataBasedOnDataType, null, 0, 0);
-        }
-
     }
 }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/measure/AggregateTableAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/measure/AggregateTableAggregator.java
index c00439e..054c1c9 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/measure/AggregateTableAggregator.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/measure/AggregateTableAggregator.java
@@ -4,6 +4,7 @@ import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 import com.huawei.unibi.molap.engine.columnar.aggregator.ColumnarAggregatorInfo;
 import com.huawei.unibi.molap.engine.columnar.keyvalue.AbstractColumnarScanResult;
+import com.huawei.unibi.molap.olap.SqlStatement;
 import com.huawei.unibi.molap.util.MolapUtil;
 
 public class AggregateTableAggregator extends FactTableAggregator
@@ -27,15 +28,17 @@ public class AggregateTableAggregator extends FactTableAggregator
     public void aggregateMeasure(AbstractColumnarScanResult keyValue, MeasureAggregator[] currentMsrRowData)
     {
         byte[] byteValue= null;
-        double doubleValue= 0;
+        Object measureValue= 0;
         for(int i = 0;i < noOfMeasuresInQuery;i++)
         {
             if(type[i]==MolapCommonConstants.SUM_COUNT_VALUE_MEASURE)
             {
-                doubleValue = keyValue.getNormalMeasureValue(measureOrdinal[i]);
-                if(uniqueValues[measureOrdinal[i]] != doubleValue)
+                SqlStatement.Type dataType = this.columnaraggreagtorInfo.getDataTypes()[this.columnaraggreagtorInfo
+                        .getMeasureStartIndex() + measureOrdinal[i]];
+                measureValue = keyValue.getNormalMeasureValue(measureOrdinal[i], dataType);
+                if(!uniqueValues[measureOrdinal[i]].equals(measureValue))
                 {
-                    currentMsrRowData[columnaraggreagtorInfo.getMeasureStartIndex() + i].agg(doubleValue, null, 0, 0);
+                    currentMsrRowData[columnaraggreagtorInfo.getMeasureStartIndex() + i].agg(measureValue);
                 }
             }
             else
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/measure/FactTableAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/measure/FactTableAggregator.java
index cc9a161..9c0a412 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/measure/FactTableAggregator.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/measure/FactTableAggregator.java
@@ -3,19 +3,19 @@ package com.huawei.unibi.molap.engine.columnar.aggregator.impl.measure;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 import com.huawei.unibi.molap.engine.columnar.aggregator.ColumnarAggregatorInfo;
 import com.huawei.unibi.molap.engine.columnar.keyvalue.AbstractColumnarScanResult;
+import com.huawei.unibi.molap.olap.SqlStatement;
 
 public class FactTableAggregator extends MeasureDataAggregator
 {
     private boolean[] isMeasureExists;
     
-    private double[] measureDefaultValue;
+    private Object[] measureDefaultValue;
     
     public FactTableAggregator(ColumnarAggregatorInfo columnaraggreagtorInfo)
     {
         super(columnaraggreagtorInfo);   
         this.isMeasureExists=columnaraggreagtorInfo.getIsMeasureExistis();
         this.measureDefaultValue=columnaraggreagtorInfo.getMsrDefaultValue();
-        
     }
     
     /**
@@ -26,16 +26,27 @@ public class FactTableAggregator extends MeasureDataAggregator
      */
     public void aggregateMeasure(AbstractColumnarScanResult keyValue, MeasureAggregator[] currentMsrRowData)
     {
+        Object value = null;
+        SqlStatement.Type dataType = null;
         for(int i = 0;i < noOfMeasuresInQuery;i++)
         {
-            double value = isMeasureExists[i]?keyValue.getNormalMeasureValue(measureOrdinal[i]):measureDefaultValue[i];
-            if(isMeasureExists[i] && uniqueValues[measureOrdinal[i]] != value)
+            if(isMeasureExists[i])
             {
-                currentMsrRowData[columnaraggreagtorInfo.getMeasureStartIndex()+i].agg(value, null, 0, 0);
+                dataType = this.columnaraggreagtorInfo.getDataTypes()[this.columnaraggreagtorInfo
+                        .getMeasureStartIndex() + measureOrdinal[i]];
+                value = keyValue.getNormalMeasureValue(measureOrdinal[i], dataType);
+            }
+            else
+            {
+                value = measureDefaultValue[i];
+            }
+            if(isMeasureExists[i] && !uniqueValues[measureOrdinal[i]].equals(value))
+            {
+                currentMsrRowData[columnaraggreagtorInfo.getMeasureStartIndex()+i].agg(value);
             }
             else if(!isMeasureExists[i])
             {
-                currentMsrRowData[columnaraggreagtorInfo.getMeasureStartIndex()+i].agg(measureDefaultValue[i], null, 0, 0);
+                currentMsrRowData[columnaraggreagtorInfo.getMeasureStartIndex()+i].agg(measureDefaultValue[i]);
             }
         }
     }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/measure/MeasureDataAggregator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/measure/MeasureDataAggregator.java
index e933d8d..5773365 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/measure/MeasureDataAggregator.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/aggregator/impl/measure/MeasureDataAggregator.java
@@ -13,7 +13,7 @@ public abstract class MeasureDataAggregator
     
     protected int noOfMeasuresInQuery;
 
-    protected double[] uniqueValues;
+    protected Object[] uniqueValues;
     
     protected int[] measureOrdinal;
     
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/datastoreblockprocessor/impl/FilterDataStoreProcessor.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/datastoreblockprocessor/impl/FilterDataStoreProcessor.java
index 2064691..27bd6ca 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/datastoreblockprocessor/impl/FilterDataStoreProcessor.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/datastoreblockprocessor/impl/FilterDataStoreProcessor.java
@@ -97,10 +97,7 @@ public class FilterDataStoreProcessor extends AbstractColumnarDataStoreProcessor
                         .getAllSelectedDimensions()[i]];
 //                if(columnarDataStoreBlockInfo.getIsUniqueBlock()[columnarDataStoreBlockInfo.getAllSelectedDimensions()[i]])
 //                {
-                if(null!=keyBlocks[i].getColumnarKeyStoreMetadata().getDataIndex())
-                {
                     keyBlocks[i].unCompress();
-                }
 //                }
               //CHECKSTYLE:ON
             }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/keyvalue/AbstractColumnarScanResult.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/keyvalue/AbstractColumnarScanResult.java
index 26bc9f2..c2a83f9 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/keyvalue/AbstractColumnarScanResult.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/keyvalue/AbstractColumnarScanResult.java
@@ -1,26 +1,13 @@
 package com.huawei.unibi.molap.engine.columnar.keyvalue;
 
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
-import com.huawei.iweb.platform.logging.LogService;
-import com.huawei.iweb.platform.logging.LogServiceFactory;
 import com.huawei.unibi.molap.datastorage.store.columnar.ColumnarKeyStoreDataHolder;
 import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
-import com.huawei.unibi.molap.engine.wrappers.ByteArrayWrapper;
-import com.huawei.unibi.molap.engine.complex.querytypes.GenericQueryType;
-import com.huawei.unibi.molap.engine.util.MolapEngineLogEvent;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
+import com.huawei.unibi.molap.olap.SqlStatement;
 import com.huawei.unibi.molap.util.ByteUtil;
 
 public abstract class AbstractColumnarScanResult
 {
-    private static final LogService LOGGER = LogServiceFactory.getLogService(AbstractColumnarScanResult.class.getName());
-    
     private int totalNumberOfRows;
 
     protected int currentRow = -1;
@@ -37,8 +24,7 @@ public abstract class AbstractColumnarScanResult
 
     private int[] selectedDimensionIndex;
 
-    protected ColumnarKeyStoreDataHolder[] columnarKeyStoreDataHolder;
-
+    private ColumnarKeyStoreDataHolder[] columnarKeyStoreDataHolder;
 
     public AbstractColumnarScanResult(int keySize, int[] selectedDimensionIndex)
     {
@@ -50,11 +36,6 @@ public abstract class AbstractColumnarScanResult
     {
         this.columnarKeyStoreDataHolder = columnarKeyStoreDataHolder;
     }
-    
-    public int getKeyBlockLength()
-    {
-        return columnarKeyStoreDataHolder.length;
-    }
 
     public void setMeasureBlock(MolapReadDataHolder[] measureBlocks)
     {
@@ -85,18 +66,12 @@ public abstract class AbstractColumnarScanResult
         currentRow=-1;
     }
     
-    protected byte[] getKeyArray(int columnIndex, ByteArrayWrapper keyVal)
+    protected byte[] getKeyArray(int columnIndex)
     {
         byte[] completeKeyArray = new byte[keySize];
         int destinationPosition = 0;
         for(int i = 0;i < selectedDimensionIndex.length;i++)
         {
-            if(columnarKeyStoreDataHolder[selectedDimensionIndex[i]].getColumnarKeyStoreMetadata().isDirectSurrogateColumn())
-            {
-                //Incase of high cardinality system has to update the byte array with high cardinality dimension values.
-                updateByteArrayWithDirectSurrogateKeyVal(keyVal,columnIndex,columnarKeyStoreDataHolder[selectedDimensionIndex[i]]);
-                continue;
-            }
             if(!columnarKeyStoreDataHolder[selectedDimensionIndex[i]].getColumnarKeyStoreMetadata().isSorted())
             {
                 System.arraycopy(columnarKeyStoreDataHolder[selectedDimensionIndex[i]].getKeyBlockData(),
@@ -122,138 +97,12 @@ public abstract class AbstractColumnarScanResult
         rowCounter++;
         return completeKeyArray;
     }
-    
-    /**
-     * Incase of high cardinality system has to update the byte array with high cardinality dimension values separately
-     * since its not part of Key generator. Based on column reverse index value the high cardinality data has been get
-     * from the mapOfColumnarKeyBlockDataForDirectSurroagtes.
-     * 
-     * @param key
-     * @param colIndex
-     * @param columnarKeyStoreDataHolder
-     */
-    private void updateByteArrayWithDirectSurrogateKeyVal(ByteArrayWrapper key, int colIndex,
-            ColumnarKeyStoreDataHolder columnarKeyStoreDataHolder)
-    {
-
-        Map<Integer, byte[]> mapOfColumnarKeyBlockDataForDirectSurroagtes = columnarKeyStoreDataHolder
-                .getColumnarKeyStoreMetadata().getMapOfColumnarKeyBlockDataForDirectSurroagtes();
-        int[] columnIndexArray = columnarKeyStoreDataHolder.getColumnarKeyStoreMetadata().getColumnIndex();
-        int[] columnReverseIndexArray = columnarKeyStoreDataHolder.getColumnarKeyStoreMetadata()
-                .getColumnReverseIndex();
-
-        if(null != mapOfColumnarKeyBlockDataForDirectSurroagtes)
-        {
-            if(null != columnReverseIndexArray)
-            {
-
-                key.addToDirectSurrogateKeyList(mapOfColumnarKeyBlockDataForDirectSurroagtes
-                        .get(columnReverseIndexArray[colIndex]));
-            }
-            else
-            {
-                key.addToDirectSurrogateKeyList(mapOfColumnarKeyBlockDataForDirectSurroagtes
-                        .get(colIndex));
-            }
-
-        }
-
-    }
-    
-    
-    public byte[] getKeyDataStore()
-    {
-        byte[] completeKeyArray = new byte[keySize];
-        for(int i = 0;i < selectedDimensionIndex.length;i++)
-        {
-            if(columnarKeyStoreDataHolder[selectedDimensionIndex[i]].getColumnarKeyStoreMetadata().isDirectSurrogateColumn())
-            {
-                return columnarKeyStoreDataHolder[selectedDimensionIndex[i]].getKeyBlockData();
-            }
-
-        }
-        
-        return completeKeyArray;
-    }
-
-    protected List<byte[]> getKeyArrayWithComplexTypes(int columnIndex, Map<Integer, GenericQueryType> complexQueryDims)
-    {
-//        byte[] completeKeyArray = new byte[keySize];
-//        int destinationPosition = 0;
-        int keyArrayLength = 0;
-        List<byte[]> completeComplexKey = new ArrayList<byte[]>();
-        List<byte[]> completePrimitiveKey = new ArrayList<byte[]>();
-        for(int i = 0;i < selectedDimensionIndex.length;i++)
-        {
-            GenericQueryType complexType = complexQueryDims.get(selectedDimensionIndex[i]);
-            if(complexType == null)
-            {
-                byte[] currentColBytes = new byte[columnarKeyStoreDataHolder[selectedDimensionIndex[i]].getColumnarKeyStoreMetadata()
-                                                  .getEachRowSize()];
-                if(!columnarKeyStoreDataHolder[selectedDimensionIndex[i]].getColumnarKeyStoreMetadata().isSorted())
-                {
-                    System.arraycopy(columnarKeyStoreDataHolder[selectedDimensionIndex[i]].getKeyBlockData(),
-                            columnarKeyStoreDataHolder[selectedDimensionIndex[i]].getColumnarKeyStoreMetadata()
-                            .getColumnReverseIndex()[columnIndex]
-                                    * columnarKeyStoreDataHolder[selectedDimensionIndex[i]].getColumnarKeyStoreMetadata()
-                                    .getEachRowSize(), currentColBytes, 0,
-                                    columnarKeyStoreDataHolder[selectedDimensionIndex[i]].getColumnarKeyStoreMetadata()
-                                    .getEachRowSize());
-                }
-                else
-                {
-                    
-                    System.arraycopy(columnarKeyStoreDataHolder[selectedDimensionIndex[i]].getKeyBlockData(), columnIndex
-                            * columnarKeyStoreDataHolder[selectedDimensionIndex[i]].getColumnarKeyStoreMetadata()
-                            .getEachRowSize(), currentColBytes, 0,
-                            columnarKeyStoreDataHolder[selectedDimensionIndex[i]].getColumnarKeyStoreMetadata()
-                            .getEachRowSize());
-                }
-                completePrimitiveKey.add(currentColBytes);
-                keyArrayLength += currentColBytes.length;
-            }
-            else
-            {
-                try
-                {
-                    ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
-                    DataOutputStream dataOutput = new DataOutputStream(byteStream);
-                    complexType.parseBlocksAndReturnComplexColumnByteArray(columnarKeyStoreDataHolder, columnIndex, dataOutput);
-                    completeComplexKey.add(byteStream.toByteArray());
-//                    keyArrayLength += byteStream.toByteArray().length;
-                    byteStream.close();
-                }
-                catch(IOException e)
-                {
-                    LOGGER.error(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, e);
-                }
-                i += (complexType.getColsCount() - 1);
-            }
-        }
-        byte[] completeKeyArray = new byte[keyArrayLength];
-        int l=0;
-        for(byte[] key : completePrimitiveKey)
-        {
-            for(int i=0;i<key.length;i++)
-            {
-                completeKeyArray[l++] = key[i];
-            }
-        }
-        completeComplexKey.add(completeKeyArray);
-        rowCounter++;
-        return completeComplexKey;
-    }
 
     protected int getSurrogateKey(int index, int dimOrdinal)
     {
         return columnarKeyStoreDataHolder[dimOrdinal].getSurrogateKey(index);
     }
     
-    protected void getComplexSurrogateKey(int index, GenericQueryType complexType, DataOutputStream dataOutputStream) throws IOException
-    {
-        complexType.parseBlocksAndReturnComplexColumnByteArray(columnarKeyStoreDataHolder, index, dataOutputStream);
-    }
-    
     public int getNotNullCount(byte[] notNullByteArray, Dimension dim)
     {
         int start=ByteUtil.UnsafeComparer.INSTANCE.compareTo(
@@ -275,20 +124,11 @@ public abstract class AbstractColumnarScanResult
         }
         return totalNumberOfRows-count;
     }
-    public abstract double getNormalMeasureValue(int measureOrdinal);
+    public abstract Object getNormalMeasureValue(int measureOrdinal, SqlStatement.Type dataType);
 
     public abstract byte[] getCustomMeasureValue(int measureOrdinal);
 
-    public abstract byte[] getKeyArray(ByteArrayWrapper key);
     public abstract byte[] getKeyArray();
-
-    public abstract List<byte[]> getKeyArrayWithComplexTypes(Map<Integer, GenericQueryType> complexQueryDims);
     
     public abstract int getDimDataForAgg(int dimOrdinal);
-
-    public abstract byte[] getHighCardinalityDimDataForAgg(Dimension dimension);
-    public abstract void getComplexDimDataForAgg(GenericQueryType complexType, DataOutputStream dataOutputStream) throws IOException;
-
-
-
 }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/keyvalue/FilterScanResult.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/keyvalue/FilterScanResult.java
index 03e3a38..c0c99ba 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/keyvalue/FilterScanResult.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/keyvalue/FilterScanResult.java
@@ -1,28 +1,26 @@
 package com.huawei.unibi.molap.engine.columnar.keyvalue;
 
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.util.List;
-import java.util.Map;
-
-import com.huawei.unibi.molap.datastorage.store.columnar.ColumnarKeyStoreMetadata;
-import com.huawei.unibi.molap.engine.wrappers.ByteArrayWrapper;
-import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
-
-
-import com.huawei.unibi.molap.engine.complex.querytypes.GenericQueryType;
 
+import com.huawei.unibi.molap.olap.SqlStatement;
 
 public class FilterScanResult extends AbstractColumnarScanResult
 {
-    public FilterScanResult(int keySize, int[] selectedDimensionIndex) 
+    public FilterScanResult(int keySize, int[] selectedDimensionIndex)
     {
         super(keySize, selectedDimensionIndex);
     }
 
-    public double getNormalMeasureValue(int measureOrdinal)
+    public Object getNormalMeasureValue(int measureOrdinal, SqlStatement.Type dataType)
     {
-        return measureBlocks[measureOrdinal].getReadableDoubleValueByIndex(rowMapping[currentRow]);
+        switch (dataType)
+        {
+            case DECIMAL:
+                return measureBlocks[measureOrdinal].getReadableBigDecimalValueByIndex(rowMapping[currentRow]);
+            case BIGINT:
+                return measureBlocks[measureOrdinal].getReadableLongValueByIndex(rowMapping[currentRow]);
+            default:
+                return measureBlocks[measureOrdinal].getReadableDoubleValueByIndex(rowMapping[currentRow]);
+        }
     }
 
     public byte[] getCustomMeasureValue(int measureOrdinal)
@@ -30,15 +28,10 @@ public class FilterScanResult extends AbstractColumnarScanResult
         return measureBlocks[measureOrdinal].getReadableByteArrayValueByIndex(rowMapping[currentRow]);
     }
 
-    public byte[] getKeyArray(ByteArrayWrapper key)
-    {
-        ++currentRow;
-        return getKeyArray(rowMapping[++sourcePosition],key);
-    }
-    public List<byte[]> getKeyArrayWithComplexTypes(Map<Integer, GenericQueryType> complexQueryDims)
+    public byte[] getKeyArray()
     {
         ++currentRow;
-        return getKeyArrayWithComplexTypes(rowMapping[++sourcePosition], complexQueryDims);
+        return getKeyArray(rowMapping[++sourcePosition]);
     }
 
     @Override
@@ -46,36 +39,4 @@ public class FilterScanResult extends AbstractColumnarScanResult
     {
         return getSurrogateKey(rowMapping[currentRow], dimOrdinal);
     }
-
-    @Override
-    public byte[] getKeyArray()
-    {
-        ++currentRow;
-        return getKeyArray(rowMapping[++sourcePosition],null);
-    }
-
-    @Override
-    public byte[] getHighCardinalityDimDataForAgg(Dimension dimension)
-    {
-        ColumnarKeyStoreMetadata columnarKeyStoreMetadata = columnarKeyStoreDataHolder[dimension.getOrdinal()]
-                .getColumnarKeyStoreMetadata();
-        if(null != columnarKeyStoreMetadata.getMapOfColumnarKeyBlockDataForDirectSurroagtes())
-        {
-            Map<Integer, byte[]> mapOfDirectSurrogates = columnarKeyStoreMetadata
-                    .getMapOfColumnarKeyBlockDataForDirectSurroagtes();
-            if(null==columnarKeyStoreMetadata.getColumnReverseIndex())
-            {
-                return mapOfDirectSurrogates.get(rowMapping[++sourcePosition]);
-            }
-            return mapOfDirectSurrogates.get(columnarKeyStoreMetadata.getColumnReverseIndex()[rowMapping[++sourcePosition]]);
-        }
-        return null;
-
-    }
-    
-    @Override
-    public void getComplexDimDataForAgg(GenericQueryType complexType, DataOutputStream dataOutputStream) throws IOException
-    {
-        getComplexSurrogateKey(rowMapping[currentRow], complexType, dataOutputStream);
-    }
 }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/keyvalue/NonFilterScanResult.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/keyvalue/NonFilterScanResult.java
index 7e63a5e..ad71a4b 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/keyvalue/NonFilterScanResult.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/columnar/keyvalue/NonFilterScanResult.java
@@ -1,16 +1,7 @@
 package com.huawei.unibi.molap.engine.columnar.keyvalue;
 
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.util.List;
-import java.util.Map;
-
-import com.huawei.unibi.molap.datastorage.store.columnar.ColumnarKeyStoreMetadata;
-import com.huawei.unibi.molap.engine.wrappers.ByteArrayWrapper;
-import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
-import com.huawei.unibi.molap.engine.complex.querytypes.GenericQueryType;
-
 
+import com.huawei.unibi.molap.olap.SqlStatement;
 
 public class NonFilterScanResult extends AbstractColumnarScanResult
 {
@@ -18,68 +9,31 @@ public class NonFilterScanResult extends AbstractColumnarScanResult
     {
         super(keySize,selectedDimensionIndex);
     }
-    public double getNormalMeasureValue(int measureOrdinal)
+    public Object getNormalMeasureValue(int measureOrdinal, SqlStatement.Type dataType)
     {
-        return measureBlocks[measureOrdinal].getReadableDoubleValueByIndex(currentRow);
+        switch (dataType)
+        {
+            case BIGINT:
+                return measureBlocks[measureOrdinal].getReadableLongValueByIndex(currentRow);
+            case DECIMAL:
+                return measureBlocks[measureOrdinal].getReadableBigDecimalValueByIndex(currentRow);
+            default:
+                return measureBlocks[measureOrdinal].getReadableDoubleValueByIndex(currentRow);
+        }
     }
     public byte[] getCustomMeasureValue(int measureOrdinal)
     {
         return measureBlocks[measureOrdinal].getReadableByteArrayValueByIndex(currentRow);
     }
     
-    public byte[] getKeyArray(ByteArrayWrapper keyVal)
-    {
-        ++currentRow;
-        return getKeyArray(++sourcePosition,keyVal);
-    }
-
-    public List<byte[]> getKeyArrayWithComplexTypes(Map<Integer, GenericQueryType> complexQueryDims)
+    public byte[] getKeyArray()
     {
         ++currentRow;
-        return getKeyArrayWithComplexTypes(++sourcePosition, complexQueryDims);
+        return getKeyArray(++sourcePosition);
     }
     
-    
-    
     public int getDimDataForAgg(int dimOrdinal)
     {
         return getSurrogateKey(currentRow, dimOrdinal);
     }
-    @Override
-    public byte[] getKeyArray()
-    {
-        ++currentRow;
-        return getKeyArray(++sourcePosition,null);
-    }
-    @Override
-    public byte[] getHighCardinalityDimDataForAgg(Dimension dimension)
-    {
-        
-            ColumnarKeyStoreMetadata columnarKeyStoreMetadata = columnarKeyStoreDataHolder[dimension.getOrdinal()]
-                    .getColumnarKeyStoreMetadata();
-            if(null != columnarKeyStoreMetadata.getMapOfColumnarKeyBlockDataForDirectSurroagtes())
-            {
-                Map<Integer, byte[]> mapOfDirectSurrogates = columnarKeyStoreMetadata
-                        .getMapOfColumnarKeyBlockDataForDirectSurroagtes();
-                if(null==columnarKeyStoreMetadata.getColumnReverseIndex())
-                {
-                    return mapOfDirectSurrogates.get(currentRow);
-                }
-                return mapOfDirectSurrogates.get(columnarKeyStoreMetadata.getColumnReverseIndex()[currentRow]);
-            }
-            return null;
-            // TODO Auto-generated method stub
-
-        
-
-    }
-   
-    
-
-    @Override
-    public void getComplexDimDataForAgg(GenericQueryType complexType, DataOutputStream dataOutputStream)
-            throws IOException
-    {
-        getComplexSurrogateKey(currentRow, complexType, dataOutputStream);
-    }
 }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/complex/querytypes/ArrayQueryType.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/complex/querytypes/ArrayQueryType.java
deleted file mode 100644
index 8ede4cd..0000000
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/complex/querytypes/ArrayQueryType.java
+++ /dev/null
@@ -1,219 +0,0 @@
-package com.huawei.unibi.molap.engine.complex.querytypes;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.List;
-
-import org.apache.spark.sql.types.ArrayType;
-import org.apache.spark.sql.types.DataType;
-import org.apache.spark.sql.types.GenericArrayData;
-
-import com.huawei.unibi.molap.datastorage.store.columnar.ColumnarKeyStoreDataHolder;
-import com.huawei.unibi.molap.engine.datastorage.InMemoryCube;
-import com.huawei.unibi.molap.engine.evaluators.BlockDataHolder;
-import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
-
-public class ArrayQueryType implements GenericQueryType {
-	
-	private GenericQueryType children;
-	
-	private String name;
-	
-	private String parentname;
-	
-	private int blockIndex;
-	
-	private int keyOrdinalForQuery;
-
-	@Override
-	public void addChildren(GenericQueryType children) {
-		if(this.getName().equals(children.getParentname()))
-		{
-			this.children = children;
-		}
-		else
-		{
-			this.children.addChildren(children);
-		}
-	}
-	
-	public ArrayQueryType(String name, String parentname, int blockIndex)
-	{
-		this.name = name;
-		this.parentname = parentname;
-		this.blockIndex = blockIndex;
-	}
-	
-	@Override
-	public void setName(String name) {
-		this.name = name;
-	}
-	
-	@Override
-	public String getName() {
-		return name;
-	}
-	
-	@Override
-	public void setParentname(String parentname) {
-		this.parentname = parentname;
-		
-	}
-
-	@Override
-	public String getParentname() {
-		return parentname;
-	}
-	
-	@Override
-	public void getAllPrimitiveChildren(List<GenericQueryType> primitiveChild) {
-		if (children instanceof PrimitiveQueryType) 
-		{
-			primitiveChild.add(children);
-		}
-		else
-		{
-			children.getAllPrimitiveChildren(primitiveChild);
-		}
-	}
-	
-	
-	@Override
-	public int getSurrogateIndex() {
-		return 0;
-	}
-
-	@Override
-	public void setSurrogateIndex(int surrIndex) {
-		
-	}
-	
-	@Override
-	public int getBlockIndex()
-    {
-        return blockIndex;
-    }
-	
-	@Override
-    public void setBlockIndex(int blockIndex)
-    {
-        this.blockIndex = blockIndex;
-    }
-	
-	@Override
-	public int getColsCount() {
-		return children.getColsCount() + 1;
-	}
-	
-    @Override
-    public void parseBlocksAndReturnComplexColumnByteArray(ColumnarKeyStoreDataHolder[] columnarKeyStoreDataHolder, int rowNumber, DataOutputStream dataOutputStream) throws IOException
-    {
-        byte[] input = new byte[8];
-        if(!columnarKeyStoreDataHolder[blockIndex].getColumnarKeyStoreMetadata().isSorted())
-        {
-            System.arraycopy(columnarKeyStoreDataHolder[blockIndex].getKeyBlockData(),
-                    columnarKeyStoreDataHolder[blockIndex].getColumnarKeyStoreMetadata()
-                    .getColumnReverseIndex()[rowNumber]
-                            * columnarKeyStoreDataHolder[blockIndex].getColumnarKeyStoreMetadata()
-                            .getEachRowSize(), input, 0,
-                            columnarKeyStoreDataHolder[blockIndex].getColumnarKeyStoreMetadata()
-                            .getEachRowSize());
-        }
-        else
-        {
-            
-            System.arraycopy(columnarKeyStoreDataHolder[blockIndex].getKeyBlockData(), rowNumber
-                    * columnarKeyStoreDataHolder[blockIndex].getColumnarKeyStoreMetadata()
-                    .getEachRowSize(), input, 0,
-                    columnarKeyStoreDataHolder[blockIndex].getColumnarKeyStoreMetadata()
-                    .getEachRowSize());
-        }
-        
-        ByteBuffer byteArray = ByteBuffer.wrap(input);
-        int dataLength = byteArray.getInt();
-        dataOutputStream.writeInt(dataLength);
-        if(dataLength == 0)
-        {
-//            b.putInt(0);
-        }
-        else
-        {
-            int columnIndex = byteArray.getInt();
-            for(int i=0;i<dataLength;i++)
-            {
-                children.parseBlocksAndReturnComplexColumnByteArray(columnarKeyStoreDataHolder, columnIndex++, dataOutputStream);
-            }
-        }
-    }
-    
-    @Override
-    public void parseAndGetResultBytes(ByteBuffer complexData, DataOutputStream dataOutput) throws IOException
-    {
-        int dataLength = complexData.getInt();
-        dataOutput.writeInt(dataLength);
-        for(int i=0;i<dataLength;i++)
-        {
-            children.parseAndGetResultBytes(complexData, dataOutput);
-        }
-    }
-
-    @Override
-    public void setKeySize(int[] keyBlockSize)
-    {
-        children.setKeySize(keyBlockSize);        
-    }
-
-    @Override
-    public Object getDataBasedOnDataTypeFromSurrogates(List<InMemoryCube> slices, ByteBuffer surrogateData, Dimension[] dimensions)
-    {
-        int dataLength = surrogateData.getInt();
-        Object[] data = new Object[dataLength];
-        for(int i=0;i<dataLength;i++)
-        {
-            data[i] = children.getDataBasedOnDataTypeFromSurrogates(slices, surrogateData, dimensions);
-        }
-        return new GenericArrayData(data);
-    }
-    
-    @Override
-    public DataType getSchemaType()
-    {
-        return new ArrayType(children.getSchemaType(), true);
-    }
-    
-    @Override
-    public void setKeyOrdinalForQuery(int keyOrdinalForQuery)
-    {
-        this.keyOrdinalForQuery = keyOrdinalForQuery;
-    }
-
-    @Override
-    public int getKeyOrdinalForQuery()
-    {
-        return keyOrdinalForQuery;
-    }
-    
-    @Override
-    public void fillRequiredBlockData(BlockDataHolder blockDataHolder)
-    {
-        if(null==blockDataHolder.getColumnarKeyStore()[blockIndex])
-        {
-            blockDataHolder.getColumnarKeyStore()[blockIndex] = blockDataHolder
-                    .getLeafDataBlock().getColumnarKeyStore(blockDataHolder.getFileHolder(),
-                            blockIndex,
-                            false);
-        }
-        else
-        {
-            if(!blockDataHolder.getColumnarKeyStore()[blockIndex]
-                    .getColumnarKeyStoreMetadata().isUnCompressed())
-            {
-                blockDataHolder.getColumnarKeyStore()[blockIndex].unCompress();
-            }
-        }
-        
-        children.fillRequiredBlockData(blockDataHolder);
-    }
-
-}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/complex/querytypes/GenericQueryType.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/complex/querytypes/GenericQueryType.java
deleted file mode 100644
index 254edde..0000000
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/complex/querytypes/GenericQueryType.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package com.huawei.unibi.molap.engine.complex.querytypes;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.List;
-
-import org.apache.spark.sql.types.DataType;
-
-import com.huawei.unibi.molap.datastorage.store.columnar.ColumnarKeyStoreDataHolder;
-import com.huawei.unibi.molap.engine.datastorage.InMemoryCube;
-import com.huawei.unibi.molap.engine.evaluators.BlockDataHolder;
-import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
-
-public interface GenericQueryType {
-	
-	void setName(String name);
-	
-	String getName();
-
-	void setParentname(String parentname);
-	
-	String getParentname();
-	
-	void setBlockIndex(int blockIndex);
-	
-	int getBlockIndex();
-	
-	void addChildren(GenericQueryType children);
-	
-	void getAllPrimitiveChildren(List<GenericQueryType> primitiveChild);
-	
-	int getSurrogateIndex();
-	
-	void setSurrogateIndex(int surrIndex);
-	
-	int getColsCount();
-	
-	void setKeySize(int[] keyBlockSize);
-	
-	void setKeyOrdinalForQuery(int keyOrdinalForQuery);
-	
-	int getKeyOrdinalForQuery();
-	
-	void parseBlocksAndReturnComplexColumnByteArray(ColumnarKeyStoreDataHolder[] columnarKeyStoreDataHolder, int rowNumber, DataOutputStream dataOutputStream) throws IOException;
-	
-	DataType getSchemaType();
-	
-	Object getDataBasedOnDataTypeFromSurrogates(List<InMemoryCube> slices, ByteBuffer surrogateData, Dimension[] dimensions);
-	
-	void parseAndGetResultBytes(ByteBuffer complexData, DataOutputStream dataOutput) throws IOException;
-	
-	void fillRequiredBlockData(BlockDataHolder blockDataHolder);
-	
-}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/complex/querytypes/PrimitiveQueryType.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/complex/querytypes/PrimitiveQueryType.java
deleted file mode 100644
index 699e79f..0000000
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/complex/querytypes/PrimitiveQueryType.java
+++ /dev/null
@@ -1,212 +0,0 @@
-package com.huawei.unibi.molap.engine.complex.querytypes;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.math.BigInteger;
-import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
-import java.util.List;
-
-import org.apache.spark.sql.types.BooleanType;
-import org.apache.spark.sql.types.DataType;
-import org.apache.spark.sql.types.DoubleType;
-import org.apache.spark.sql.types.IntegerType;
-import org.apache.spark.sql.types.LongType;
-import org.apache.spark.sql.types.StringType;
-import org.apache.spark.sql.types.TimestampType;
-import org.apache.spark.unsafe.types.UTF8String;
-
-import com.huawei.unibi.molap.constants.MolapCommonConstants;
-import com.huawei.unibi.molap.datastorage.store.columnar.ColumnarKeyStoreDataHolder;
-import com.huawei.unibi.molap.engine.datastorage.InMemoryCube;
-import com.huawei.unibi.molap.engine.evaluators.BlockDataHolder;
-import com.huawei.unibi.molap.engine.util.DataTypeConverter;
-import com.huawei.unibi.molap.engine.util.QueryExecutorUtility;
-import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
-import com.huawei.unibi.molap.olap.SqlStatement;
-
-public class PrimitiveQueryType implements GenericQueryType {
-
-	private int index;
-	
-	private String name;
-	private String parentname;
-	
-	private int keySize;
-	
-	private int blockIndex;
-	
-	private SqlStatement.Type dataType;
-	
-	public PrimitiveQueryType(String name, String parentname, int blockIndex, SqlStatement.Type dataType)
-	{
-		this.name = name;
-		this.parentname = parentname;
-		this.blockIndex = blockIndex;
-		this.dataType = dataType;
-	}
-	
-	@Override
-	public void addChildren(GenericQueryType children) {
-
-	}
-
-	@Override
-	public void setName(String name) {
-		this.name = name;
-	}
-	
-	@Override
-	public String getName() {
-		return name;
-	}
-
-	@Override
-	public void setParentname(String parentname) {
-		this.parentname = parentname;
-		
-	}
-
-	@Override
-	public String getParentname() {
-		return parentname;
-	}
-	
-	@Override
-	public void getAllPrimitiveChildren(List<GenericQueryType> primitiveChild) {
-
-	}
-
-	@Override
-	public int getSurrogateIndex() {
-		return index;
-	}
-
-	@Override
-	public void setSurrogateIndex(int surrIndex) {
-		index = surrIndex;
-	}
-	
-	@Override
-    public int getBlockIndex()
-    {
-        return blockIndex;
-    }
-    
-    @Override
-    public void setBlockIndex(int blockIndex)
-    {
-        this.blockIndex = blockIndex;
-    }
-
-	@Override
-	public int getColsCount() {
-		return 1;
-	}
-
-	@Override
-    public void parseBlocksAndReturnComplexColumnByteArray(ColumnarKeyStoreDataHolder[] columnarKeyStoreDataHolder, int rowNumber, DataOutputStream dataOutputStream) throws IOException
-    {
-        byte[] currentVal = new byte[columnarKeyStoreDataHolder[blockIndex].getColumnarKeyStoreMetadata().getEachRowSize()];
-        if(!columnarKeyStoreDataHolder[blockIndex].getColumnarKeyStoreMetadata().isSorted())
-        {
-            System.arraycopy(columnarKeyStoreDataHolder[blockIndex].getKeyBlockData(),
-                    columnarKeyStoreDataHolder[blockIndex].getColumnarKeyStoreMetadata()
-                    .getColumnReverseIndex()[rowNumber]
-                            * columnarKeyStoreDataHolder[blockIndex].getColumnarKeyStoreMetadata().
-                            getEachRowSize(), currentVal, 0, columnarKeyStoreDataHolder[blockIndex].
-                            getColumnarKeyStoreMetadata().getEachRowSize());
-        }
-        else
-        {
-            System.arraycopy(columnarKeyStoreDataHolder[blockIndex].getKeyBlockData(), rowNumber
-                    * columnarKeyStoreDataHolder[blockIndex].getColumnarKeyStoreMetadata().getEachRowSize(), 
-                    currentVal, 0, columnarKeyStoreDataHolder[blockIndex].getColumnarKeyStoreMetadata().getEachRowSize());
-        }
-        dataOutputStream.write(currentVal);
-    }
-	
-	@Override
-    public void setKeySize(int[] keyBlockSize)
-    {
-        this.keySize = keyBlockSize[this.blockIndex];        
-    }
-	
-	@Override
-    public Object getDataBasedOnDataTypeFromSurrogates(List<InMemoryCube> slices, ByteBuffer surrogateData, Dimension[] dimensions)
-    {
-	    byte[] data = new byte[keySize];
-        surrogateData.get(data);
-        String memberData = QueryExecutorUtility.getMemberBySurrogateKey(dimensions[blockIndex], new BigInteger(data).intValue(), slices).toString();
-        Object actualData = DataTypeConverter.getDataBasedOnDataType(
-                memberData.equals(MolapCommonConstants.MEMBER_DEFAULT_VAL) ? null : memberData,
-                        dimensions[blockIndex].getDataType());
-        if(dimensions[blockIndex].getDataType() == SqlStatement.Type.STRING)
-        {
-            byte[] dataBytes = ((String)actualData).getBytes(Charset.defaultCharset());
-            return UTF8String.fromBytes(dataBytes);
-        }
-        return actualData;
-    }
-	
-	@Override
-    public void parseAndGetResultBytes(ByteBuffer complexData, DataOutputStream dataOutput) throws IOException
-    {
-	    
-//	    dataOutput.write();
-    }
-	
-	@Override
-    public DataType getSchemaType()
-    {
-	    switch(dataType)
-        {
-            case INT:
-                return new IntegerType();
-            case DOUBLE:
-                return new DoubleType();
-            case LONG:
-                return new LongType();
-            case BOOLEAN:
-                return new BooleanType();
-            case TIMESTAMP:
-                return new TimestampType();
-            default:
-                return new StringType();
-        }
-    }
-
-    @Override
-    public void setKeyOrdinalForQuery(int keyOrdinalForQuery)
-    {
-        // TODO Auto-generated method stub
-        
-    }
-
-    @Override
-    public int getKeyOrdinalForQuery()
-    {
-        // TODO Auto-generated method stub
-        return 0;
-    }
-
-    @Override
-    public void fillRequiredBlockData(BlockDataHolder blockDataHolder)
-    {
-        if(null==blockDataHolder.getColumnarKeyStore()[blockIndex])
-        {
-            blockDataHolder.getColumnarKeyStore()[blockIndex] = blockDataHolder
-                    .getLeafDataBlock().getColumnarKeyStore(blockDataHolder.getFileHolder(),
-                            blockIndex,
-                            false);
-        }
-        else
-        {
-            if(!blockDataHolder.getColumnarKeyStore()[blockIndex]
-                    .getColumnarKeyStoreMetadata().isUnCompressed())
-            {
-                blockDataHolder.getColumnarKeyStore()[blockIndex].unCompress();
-            }
-        }
-    }
-}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/complex/querytypes/StructQueryType.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/complex/querytypes/StructQueryType.java
deleted file mode 100644
index e6e7f91..0000000
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/complex/querytypes/StructQueryType.java
+++ /dev/null
@@ -1,241 +0,0 @@
-package com.huawei.unibi.molap.engine.complex.querytypes;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.spark.sql.catalyst.expressions.GenericInternalRowWithSchema;
-import org.apache.spark.sql.types.DataType;
-import org.apache.spark.sql.types.Metadata;
-import org.apache.spark.sql.types.StructField;
-import org.apache.spark.sql.types.StructType;
-
-import com.huawei.unibi.molap.datastorage.store.columnar.ColumnarKeyStoreDataHolder;
-import com.huawei.unibi.molap.engine.datastorage.InMemoryCube;
-import com.huawei.unibi.molap.engine.evaluators.BlockDataHolder;
-import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
-
-public class StructQueryType implements GenericQueryType {
-	
-	private List<GenericQueryType> children = new ArrayList<GenericQueryType>();
-	private String name;
-	private String parentname;
-	private int blockIndex;
-	private int keyOrdinalForQuery;
-	
-	@Override
-	public void addChildren(GenericQueryType newChild) {
-		if(this.getName().equals(newChild.getParentname()))
-		{
-			this.children.add(newChild);
-		}
-		else
-		{
-			for(GenericQueryType child : this.children)
-			{
-				child.addChildren(newChild);
-			}
-		}
-		
-	}
-	
-	public StructQueryType(String name, String parentname, int blockIndex)
-	{
-		this.name = name;
-		this.parentname = parentname;
-		this.blockIndex = blockIndex;
-	}
-	
-	@Override
-	public void setName(String name) {
-		this.name = name;
-	}
-	
-	@Override
-	public String getName() {
-		return name;
-	}
-	
-	@Override
-	public void setParentname(String parentname) {
-		this.parentname = parentname;
-		
-	}
-
-	@Override
-	public String getParentname() {
-		return parentname;
-	}
-	
-	@Override
-	public void getAllPrimitiveChildren(List<GenericQueryType> primitiveChild) {
-		for(int i=0;i<children.size();i++)
-		{
-		    GenericQueryType child = children.get(i);
-			if (child instanceof PrimitiveQueryType) 
-			{
-				primitiveChild.add(child);
-			}
-			else
-			{
-				child.getAllPrimitiveChildren(primitiveChild);
-			}
-		}
-	}
-	
-	@Override
-	public int getSurrogateIndex() {
-		return 0;
-	}
-
-	@Override
-	public void setSurrogateIndex(int surrIndex) {
-		
-	}
-	
-	@Override
-    public int getBlockIndex()
-    {
-        return blockIndex;
-    }
-    
-    @Override
-    public void setBlockIndex(int blockIndex)
-    {
-        this.blockIndex = blockIndex;
-    }
-	
-	@Override
-	public int getColsCount() {
-		int colsCount = 1;
-		for(int i=0;i<children.size();i++)
-		{
-			colsCount += children.get(i).getColsCount();
-		}
-		return colsCount;
-	}
-	
-	
-	@Override
-    public void parseBlocksAndReturnComplexColumnByteArray(ColumnarKeyStoreDataHolder[] columnarKeyStoreDataHolder, int rowNumber, DataOutputStream dataOutputStream) throws IOException
-    {
-        byte[] input = new byte[8];
-        if(!columnarKeyStoreDataHolder[blockIndex].getColumnarKeyStoreMetadata().isSorted())
-        {
-            System.arraycopy(columnarKeyStoreDataHolder[blockIndex].getKeyBlockData(),
-                    columnarKeyStoreDataHolder[blockIndex].getColumnarKeyStoreMetadata()
-                    .getColumnReverseIndex()[rowNumber]
-                            * columnarKeyStoreDataHolder[blockIndex].getColumnarKeyStoreMetadata()
-                            .getEachRowSize(), input, 0,
-                            columnarKeyStoreDataHolder[blockIndex].getColumnarKeyStoreMetadata()
-                            .getEachRowSize());
-        }
-        else
-        {
-            
-            System.arraycopy(columnarKeyStoreDataHolder[blockIndex].getKeyBlockData(), rowNumber
-                    * columnarKeyStoreDataHolder[blockIndex].getColumnarKeyStoreMetadata()
-                    .getEachRowSize(), input, 0,
-                    columnarKeyStoreDataHolder[blockIndex].getColumnarKeyStoreMetadata()
-                    .getEachRowSize());
-        }
-        
-        ByteBuffer byteArray = ByteBuffer.wrap(input);
-        int childElement = byteArray.getInt();
-        dataOutputStream.writeInt(childElement);
-        if(childElement == 0)
-        {
-//            b.putInt(0);
-        }
-        else
-        {
-            for(int i=0;i<childElement;i++)
-            {
-                children.get(i).parseBlocksAndReturnComplexColumnByteArray(columnarKeyStoreDataHolder, rowNumber, dataOutputStream);
-            }
-        }
-    }
-	
-	@Override
-    public void parseAndGetResultBytes(ByteBuffer complexData, DataOutputStream dataOutput) throws IOException
-    {
-        int childElement = complexData.getInt();
-        dataOutput.writeInt(childElement);
-        for(int i=0;i<childElement;i++)
-        {
-            children.get(i).parseAndGetResultBytes(complexData, dataOutput);
-        }
-    }
-	
-	@Override
-    public void setKeySize(int[] keyBlockSize)
-    {
-	    for(int i=0;i<children.size();i++)
-	    {
-	        children.get(i).setKeySize(keyBlockSize);
-	    }
-    }
-	
-	@Override
-    public Object getDataBasedOnDataTypeFromSurrogates(List<InMemoryCube> slices, ByteBuffer surrogateData, Dimension[] dimensions)
-    {
-        int childLength = surrogateData.getInt();
-        Object[] fields = new Object[childLength];
-        for(int i=0;i<childLength;i++)
-        {
-            fields[i]  = children.get(i).getDataBasedOnDataTypeFromSurrogates(slices, surrogateData, dimensions);
-        }
-            
-        return new GenericInternalRowWithSchema(fields, (StructType)getSchemaType());
-    }
-	
-	@Override
-	public DataType getSchemaType()
-	{
-	    StructField[] fields = new StructField[children.size()];
-        for(int i=0;i<children.size();i++)
-        {
-            fields[i]  = new StructField(children.get(i).getName(), children.get(i).getSchemaType(), true, Metadata.empty());
-        }
-        return new StructType(fields);
-	}
-
-    @Override
-    public void setKeyOrdinalForQuery(int keyOrdinalForQuery)
-    {
-        this.keyOrdinalForQuery = keyOrdinalForQuery;
-    }
-
-    @Override
-    public int getKeyOrdinalForQuery()
-    {
-        return keyOrdinalForQuery;
-    }
-    
-    @Override
-    public void fillRequiredBlockData(BlockDataHolder blockDataHolder)
-    {
-        if(null==blockDataHolder.getColumnarKeyStore()[blockIndex])
-        {
-            blockDataHolder.getColumnarKeyStore()[blockIndex] = blockDataHolder
-                    .getLeafDataBlock().getColumnarKeyStore(blockDataHolder.getFileHolder(),
-                            blockIndex,
-                            false);
-        }
-        else
-        {
-            if(!blockDataHolder.getColumnarKeyStore()[blockIndex]
-                    .getColumnarKeyStoreMetadata().isUnCompressed())
-            {
-                blockDataHolder.getColumnarKeyStore()[blockIndex].unCompress();
-            }
-        }
-        
-        for(int i=0;i<children.size();i++)
-        {
-            children.get(i).fillRequiredBlockData(blockDataHolder);
-        }
-    }
-}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/CubeDataStore.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/CubeDataStore.java
index c2a5048..29d4000 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/CubeDataStore.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/CubeDataStore.java
@@ -14,9 +14,7 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
 
 import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
@@ -39,7 +37,6 @@ import com.huawei.unibi.molap.engine.util.MolapEngineLogEvent;
 import com.huawei.unibi.molap.keygenerator.KeyGenerator;
 import com.huawei.unibi.molap.keygenerator.columnar.impl.MultiDimKeyVarLengthEquiSplitGenerator;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Cube;
-import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Measure;
 import com.huawei.unibi.molap.metadata.SliceMetaData;
 import com.huawei.unibi.molap.util.MolapProperties;
@@ -102,17 +99,17 @@ public class CubeDataStore
     /**
      * unique value
      */
-    private double[] uniqueValue;
+    private Object[] uniqueValue;
     
     /**
      * min value
      */
-    private double[] minValue;
+    private Object[] minValue;
     
     /**
      * min value
      */
-    private double[] minValueFactForAgg;
+    private Object[] minValueFactForAgg;
     /**
      * type
      */
@@ -156,7 +153,6 @@ public class CubeDataStore
         boolean hasFactCount = hasFactCount();
         this.smd = smd;
         List<Measure> measures = metaCube.getMeasures(table);
-        prepareComplexDimensions(metaCube.getDimensions(table));
         aggregateNames = new ArrayList<String>(MolapCommonConstants.CONSTANT_SIZE_TEN);
         if(hasFactCount)
         {
@@ -183,35 +179,6 @@ public class CubeDataStore
         System.arraycopy(dimCardinality, 0, this.dimCardinality, 0, dimCardinality.length);
     }
 
-    private void prepareComplexDimensions(List<Dimension> currentDimTables)
-    {
-        Map<String, ArrayList<Dimension>> complexDimensions = new HashMap<String, ArrayList<Dimension>>();
-        for(int i = 0;i < currentDimTables.size();i++)
-        {
-            ArrayList<Dimension> dimensions = complexDimensions.get(currentDimTables.get(i).getHierName());
-            if(dimensions != null)
-            {
-                dimensions.add(currentDimTables.get(i));
-            }
-            else
-            {
-                dimensions = new ArrayList<Dimension>();
-                dimensions.add(currentDimTables.get(i));
-            }
-            complexDimensions.put(currentDimTables.get(i).getHierName(), dimensions);
-        }
-        
-        for (Map.Entry<String, ArrayList<Dimension>> entry : complexDimensions.entrySet())
-        {
-            int[] blockIndexsForEachComplexType = new int[entry.getValue().size()];
-            for(int i=0;i<entry.getValue().size();i++)
-            {
-                blockIndexsForEachComplexType[i] = entry.getValue().get(i).getDataBlockIndex();
-            }
-            entry.getValue().get(0).setAllApplicableDataBlockIndexs(blockIndexsForEachComplexType);
-        }
-    }
-    
     /**
      * Gets the DataStore
      * @param keyGen
@@ -253,7 +220,7 @@ public class CubeDataStore
         }
     }
 
-    public boolean loadDataFromFile(String filesLocaton, int startAndEndKeySize)
+    public boolean loadDataFromFile(String filesLocaton)
     {
         // added for get the MDKey size by liupeng 00204190.
         MolapFile file = FileFactory.getMolapFile(filesLocaton, FileFactory.getFileType(filesLocaton));
@@ -261,8 +228,7 @@ public class CubeDataStore
         int numberOfValues = metaCube.getMeasures(tableName).size() + (hasFactCount ? 1 : 0);
         StandardLogService.setThreadName(StandardLogService.getPartitionID(metaCube.getOnlyCubeName()), null);
         checkIsColumnar(numberOfValues);
-//        int keySize = keyGenerator.getKeySizeInBytes();
-        int keySize = startAndEndKeySize;
+        int keySize = keyGenerator.getKeySizeInBytes();
         int msrCount =  smd.getMeasures().length;
         List<DataInputStream> streams = new ArrayList<DataInputStream>(MolapCommonConstants.CONSTANT_SIZE_TEN);
         if(file.isDirectory())
@@ -321,7 +287,7 @@ public class CubeDataStore
             }
             else
             {
-                data.buildColumnar(streams, hasFactCount(),metaCube);
+                data.buildColumnar(streams, hasFactCount());
             }
 //            }
             
@@ -454,42 +420,24 @@ public class CubeDataStore
             {
                 dimSet = keyGenerator.getDimCount();
             }
-            int[] keyBlockSize = null;
-            
-            // if there is no single dims present (i.e only high card dims is present.)
-            if(this.dimCardinality.length > 0)
+            int[] keyBlockSize = new MultiDimKeyVarLengthEquiSplitGenerator(
+                    MolapUtil.getIncrementedCardinalityFullyFilled(this.dimCardinality.clone()), (byte)dimSet)
+                    .getBlockKeySize();
+
+            aggKeyBlock = new boolean[dimCardinality.length];
+            boolean isAggKeyBlock = Boolean.parseBoolean(MolapCommonConstants.AGGREAGATE_COLUMNAR_KEY_BLOCK_DEFAULTVALUE);
+            if(isAggKeyBlock)
             {
-                keyBlockSize = new MultiDimKeyVarLengthEquiSplitGenerator(
-                        MolapUtil.getIncrementedCardinalityFullyFilled(this.dimCardinality.clone()), (byte)dimSet)
-                        .getBlockKeySize();
-
-                aggKeyBlock = new boolean[dimCardinality.length];
-                boolean isAggKeyBlock = Boolean
-                        .parseBoolean(MolapCommonConstants.AGGREAGATE_COLUMNAR_KEY_BLOCK_DEFAULTVALUE);
-                if(isAggKeyBlock)
+                int highCardinalityValue = Integer.parseInt(MolapProperties.getInstance().getProperty(
+                        MolapCommonConstants.HIGH_CARDINALITY_VALUE,
+                        MolapCommonConstants.HIGH_CARDINALITY_VALUE_DEFAULTVALUE));
+                for(int i = 0;i < dimCardinality.length;i++)
                 {
-                    int highCardinalityValue = Integer.parseInt(MolapProperties.getInstance().getProperty(
-                            MolapCommonConstants.HIGH_CARDINALITY_VALUE,
-                            MolapCommonConstants.HIGH_CARDINALITY_VALUE_DEFAULTVALUE));
-                    for(int i = 0;i < dimCardinality.length;i++)
+                    if(dimCardinality[i] < highCardinalityValue)
                     {
-						//Array or Struct column will not be compressed using run-length as cardinality does not apply
-	                    if(dimCardinality[i] == 0)
-						{
-                        	aggKeyBlock[i] = false;
-						}
-                        else if(dimCardinality[i] < highCardinalityValue)
-                        {
-                            aggKeyBlock[i] = true;
-                        }
+                        aggKeyBlock[i] = true;
                     }
                 }
-
-            }
-            else
-            {
-                keyBlockSize = new int[0];
-                aggKeyBlock = new boolean[0];
             }
             data = getDataStoreDS(keyGenerator, numberOfValues, keyBlockSize, aggKeyBlock,true);
         }
@@ -500,19 +448,6 @@ public class CubeDataStore
         }
     }
 
-    private int[] getKeyBlockSizeWithComplexTypes(int[] dimCardinality)
-    {
-        int[] keyBlockSize = new int[dimCardinality.length];
-        for(int i=0;i<dimCardinality.length;i++)
-        {
-            if(dimCardinality[i] == 0)
-                keyBlockSize[i] = 8;
-            else
-                keyBlockSize[i] = new MultiDimKeyVarLengthEquiSplitGenerator(new int[]{dimCardinality[i]}, (byte)1)
-                  .getBlockKeySize()[0];
-        }
-        return keyBlockSize;
-    }
 //    public void loadDataFromSlices(List<CubeDataStore> dataStores, String fileStore)
 //    {
 //        List<Scanner> scanners = new ArrayList<Scanner>(MolapCommonConstants.CONSTANT_SIZE_TEN);
@@ -657,12 +592,12 @@ public class CubeDataStore
         return keyGenerator;
     }
 
-    public double[] getUniqueValue()
+    public Object[] getUniqueValue()
     {
         return uniqueValue;
     }
     
-    public double[] getMinValue()
+    public Object[] getMinValue()
     {
         return minValue;
     }
@@ -678,7 +613,7 @@ public class CubeDataStore
     /**
      * @return the minValueFactForAgg
      */
-    public double[] getMinValueFactForAgg()
+    public Object[] getMinValueFactForAgg()
     {
         return minValueFactForAgg;
     }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/HierarchyBtreeStore.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/HierarchyBtreeStore.java
index 7c610d5..9d4532a 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/HierarchyBtreeStore.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/HierarchyBtreeStore.java
@@ -27,7 +27,6 @@ import com.huawei.unibi.molap.engine.datastorage.tree.CSBTreeLeafNode;
 import com.huawei.unibi.molap.engine.scanner.Scanner;
 import com.huawei.unibi.molap.engine.schema.metadata.Pair;
 import com.huawei.unibi.molap.keygenerator.KeyGenerator;
-import com.huawei.unibi.molap.metadata.MolapMetadata.Cube;
 import com.huawei.unibi.molap.util.MolapProperties;
 
 /**
@@ -492,7 +491,7 @@ public class HierarchyBtreeStore implements DataStore
     }
 
     @Override
-    public void buildColumnar(List<DataInputStream> factStream, boolean hasFactCount,Cube cube)
+    public void buildColumnar(List<DataInputStream> factStream, boolean hasFactCount)
     {
         // TODO Auto-generated method stub
         
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/InMemoryCube.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/InMemoryCube.java
index 3aabfaa..2d3639e 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/InMemoryCube.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/InMemoryCube.java
@@ -11,9 +11,7 @@
 package com.huawei.unibi.molap.engine.datastorage;
 
 import java.io.File;
-import java.util.ArrayList;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -245,19 +243,16 @@ public class InMemoryCube implements Comparable<InMemoryCube>
      */
     public void loadCacheFromFile(String fileStore, String tableName, boolean loadOnlyLevelFiles)
     {
-        ExecutorService executorService = Executors.newFixedThreadPool(1);
+        ExecutorService executorService = Executors.newFixedThreadPool(5);
         String cubeUniqueName = schemaName + '_' + cubeName;
         MolapFile file = FileFactory.getMolapFile(fileStore, FileFactory.getFileType(fileStore));
         if(file.isDirectory())
         {
             getDimensionCardinality(file, tableName);
-//            keyGenerator = KeyGeneratorFactory.getKeyGenerator(dimensionCardinality);
-            keyGenerator = KeyGeneratorFactory.getKeyGenerator(findRequiredDimensionForStartAndEndKey());
-            int startAndEndKeySizeWithPrimitives = KeyGeneratorFactory.getKeyGenerator(findRequiredDimensionForStartAndEndKey()).getKeySizeInBytes();
-            keyGenerator.setStartAndEndKeySizeWithOnlyPrimitives(startAndEndKeySizeWithPrimitives);
+            keyGenerator = KeyGeneratorFactory.getKeyGenerator(dimensionCardinality);
         }
         // Process fact and aggregate data cache
-        if(!loadOnlyLevelFiles)
+        if(!loadOnlyLevelFiles && dimensionCardinality.length>0)
         {
             for(String table : metaCube.getTablesList())
             {
@@ -266,8 +261,7 @@ public class InMemoryCube implements Comparable<InMemoryCube>
                     continue;
                 }
                 CubeDataStore dataCache = new CubeDataStore(table, metaCube, rsStore.getSliceMetaCache(table),keyGenerator, dimensionCardinality);
-                //add start and end key size with only primitives
-                if(dataCache.loadDataFromFile(fileStore, keyGenerator.getStartAndEndKeySizeWithOnlyPrimitives()))
+                if(dataCache.loadDataFromFile(fileStore))
                 {
                     dataCacheMap.put(table, dataCache);
                 }
@@ -279,7 +273,7 @@ public class InMemoryCube implements Comparable<InMemoryCube>
         for(int i = 0;i < rolapCube.dimensions.length;i++)
         {
             dimension = rolapCube.dimensions[i];
-            if(dimension.visible && !dimension.highCardinality)
+            if(dimension.visible)
             {
                 DimensionHierarichyStore cache = new DimensionHierarichyStore(dimension, membersCache, cubeUniqueName,
                         factTableName, schema);
@@ -316,24 +310,6 @@ public class InMemoryCube implements Comparable<InMemoryCube>
         this.tableName=tableName;
     }
     
-    
-    private int[] findRequiredDimensionForStartAndEndKey()
-    {
-        List<Integer> dimCardinalities = new ArrayList<Integer>();
-        for(int dimCard : dimensionCardinality)
-        {
-            if(dimCard != 0)
-                dimCardinalities.add(dimCard);
-            else
-                break;
-        }
-        int[] primitiveDimsForKey = new int[dimCardinalities.size()];
-        for(int i=0;i<dimCardinalities.size();i++)
-        {
-            primitiveDimsForKey[i] = dimCardinalities.get(i);
-        }
-        return primitiveDimsForKey;
-    }
     /**
      * @param file
      */
@@ -524,16 +500,7 @@ public class InMemoryCube implements Comparable<InMemoryCube>
         int loadNumber = -1;
         try
         {
-            if(isLoadMerged(loadName))
-            {
-                String loadNum = loadName.substring(loadName.indexOf('_') + 1,
-                        loadName.indexOf(MolapCommonConstants.MERGERD_EXTENSION));
-                loadNumber = Integer.parseInt(loadNum);
-            }
-            else
-            {
-                loadNumber = Integer.parseInt(loadName.substring(lastIndexOf + 5));
-            }
+            loadNumber= Integer.parseInt(loadName.substring(lastIndexOf + 5));
         }
         catch(NumberFormatException e)
         {
@@ -548,33 +515,17 @@ public class InMemoryCube implements Comparable<InMemoryCube>
     public int compareTo(InMemoryCube memCubeInstance)
     {
         String loadNameOfCurrntObj = this.getLoadName();
-        String loadNameCurrntObj;
-        
-        if(isLoadMerged(loadNameOfCurrntObj))
-        {
-             loadNameCurrntObj = loadNameOfCurrntObj.substring(loadNameOfCurrntObj.indexOf('_')+1,loadNameOfCurrntObj.indexOf(MolapCommonConstants.MERGERD_EXTENSION));
-        }
-        else
-        {
-         loadNameCurrntObj = loadNameOfCurrntObj.substring(loadNameOfCurrntObj.lastIndexOf('_')+1,
+        String loadNameCurrntObj = loadNameOfCurrntObj.substring(loadNameOfCurrntObj.lastIndexOf('_')+1,
                 loadNameOfCurrntObj.length());
-        }
         int idOfCurrentObj = Integer.parseInt(loadNameCurrntObj);
         String loadNameOfComparableObj = memCubeInstance.getLoadName();
-        
-        if(isLoadMerged(loadNameOfComparableObj))
-        {
-            loadNameOfComparableObj = loadNameOfComparableObj.substring(loadNameOfComparableObj.indexOf('_')+1,loadNameOfComparableObj.indexOf(MolapCommonConstants.MERGERD_EXTENSION));
-        }
-        else
-        {
         loadNameOfComparableObj = loadNameOfComparableObj.substring(loadNameOfComparableObj.lastIndexOf('_')+1,
                 loadNameOfComparableObj.length());
-        }
         int idOfCompObj = Integer.parseInt(loadNameOfComparableObj);
         return idOfCurrentObj - idOfCompObj;
     }
     
+      
     @Override
     public boolean equals(Object obj) 
     {
@@ -610,18 +561,4 @@ public class InMemoryCube implements Comparable<InMemoryCube>
     {
         return dimensionCardinality;
     }
-    
-    /**
-     * To check if this is a merged load or not.
-     * @param loadName
-     * @return
-     */
-    private boolean isLoadMerged(String loadName)
-    {
-         if(loadName.contains(MolapCommonConstants.MERGERD_EXTENSION))
-         {
-             return true;
-         }
-        return false;
-    }
 }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/InMemoryCubeStore.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/InMemoryCubeStore.java
index 636ca09..91b442c 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/InMemoryCubeStore.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/InMemoryCubeStore.java
@@ -772,7 +772,7 @@ public final class InMemoryCubeStore
                     while(itrForSliceList.hasNext())
                     {
                         InMemoryCube slice = itrForSliceList.next();
-                        String sliceName = slice.getLoadName().substring(slice.getLoadName().indexOf('_') + 1,
+                        String sliceName = slice.getLoadName().substring(slice.getLoadName().lastIndexOf('_') + 1,
                                 slice.getLoadName().length());
                         if(listLoadFolders.contains(slice.getLoadName()) && null != sliceUpdatedLoadPaths
                                 && !sliceUpdatedLoadPaths.contains(sliceName))
@@ -1193,29 +1193,8 @@ public final class InMemoryCubeStore
                         String firstFolder = o1.getAbsolutePath().substring(firstFolderIndex);
                         String secondFolder = o2.getAbsolutePath().substring(secondFolderIndex);
                         //
-                        int f1 = -1;
-                        int f2 = -1;
-                        try
-                        {
-                         f1 = Integer.parseInt(firstFolder.split("_")[1]);
-                        }
-                        catch(NumberFormatException e)
-                        {
-                            String loadName = (firstFolder.split("_")[1]);
-                          f1 =  Integer.parseInt(loadName.substring(0, loadName.indexOf(MolapCommonConstants.MERGERD_EXTENSION)));
-                            
-                        }
-                        try
-                        {
-                         f2 = Integer.parseInt(secondFolder.split("_")[1]);
-                        }
-                        catch(NumberFormatException e)
-                        {
-                            String loadName = (secondFolder.split("_")[1]);
-                          f2 =  Integer.parseInt(loadName.substring(0, loadName.indexOf(MolapCommonConstants.MERGERD_EXTENSION)));
-                            
-                        }
-//                        int f2 = Integer.parseInt(secondFolder.split("_")[1]);
+                        int f1 = Integer.parseInt(firstFolder.split("_")[1]);
+                        int f2 = Integer.parseInt(secondFolder.split("_")[1]);
                         return (f1 < f2) ? -1 : (f1 == f2 ? 0 : 1);
                     }
                     catch(Exception e)
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/MemberStore.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/MemberStore.java
index 951b7ad..35fa291 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/MemberStore.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/MemberStore.java
@@ -111,7 +111,7 @@ public class MemberStore
             this.levelName = rolapLevel.getName();
             
             String datatype = rolapLevel.type; 
-            if(datatype.equals("Numeric") ||datatype.equals("Integer"))
+            if(datatype.equals("Numeric") || datatype.equals("Integer") || datatype.equals("BigInt"))
             {//CHECKSTYLE:ON
                 memberDataType = DataType.NUMBER;
             }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/storeInterfaces/DataStore.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/storeInterfaces/DataStore.java
index 01cb604..28131fa 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/storeInterfaces/DataStore.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/storeInterfaces/DataStore.java
@@ -16,7 +16,6 @@ import com.huawei.unibi.molap.datastorage.store.FileHolder;
 import com.huawei.unibi.molap.datastorage.store.compression.ValueCompressionModel;
 import com.huawei.unibi.molap.engine.datastorage.streams.DataInputStream;
 import com.huawei.unibi.molap.engine.scanner.Scanner;
-import com.huawei.unibi.molap.metadata.MolapMetadata.Cube;
 
 /**
  * @author R00900208
@@ -51,7 +50,7 @@ public interface DataStore
 
     void build(List<DataInputStream> factStream, boolean hasFactCount);
     
-    void buildColumnar(List<DataInputStream> factStream, boolean hasFactCount,Cube cube);
+    void buildColumnar(List<DataInputStream> factStream, boolean hasFactCount);
 
     //public void build(List<DataInputStream> factStreams, List<String> aggregateNames, boolean hasFact_count);
 
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/storeInterfaces/KeyValue.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/storeInterfaces/KeyValue.java
index 7b99279..6e43d37 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/storeInterfaces/KeyValue.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/storeInterfaces/KeyValue.java
@@ -23,6 +23,7 @@ import java.util.Arrays;
 import com.huawei.unibi.molap.datastorage.store.FileHolder;
 import com.huawei.unibi.molap.datastorage.store.MeasureDataWrapper;
 import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder;
+import com.huawei.unibi.molap.engine.aggregator.util.AggUtil;
 import com.huawei.unibi.molap.keygenerator.KeyGenerator;
 
 /**
@@ -220,11 +221,29 @@ public class KeyValue
         return backKeyArray;
     }
 
-    public double getValue(int col)
+    public Object getValue(int col)
     {
-        return msrData[col].getReadableDoubleValueByIndex(row);//[row];//.get(row, col);
+        switch(AggUtil.getMeasureType(col))   //get measure type and distinguish the get methods of MolapReadDataHolder
+        {
+            case BIGINT:
+                return msrData[col].getReadableLongValueByIndex(row);
+            case DECIMAL:
+                return msrData[col].getReadableBigDecimalValueByIndex(row);
+            default:
+                return msrData[col].getReadableDoubleValueByIndex(row);
+        }
     }
-    
+
+    /**
+     * get the MolapReadDataHolder[] for agg(MolapReadDataHolder newVal,int index)
+     * @return
+     */
+    public MolapReadDataHolder getMsrData(int col)
+    {
+        return msrData[col];
+    }
+
+
     public byte[] getByteArrayValue(int col)
     {
         return msrData[col].getReadableByteArrayValueByIndex(row);//[row];//.get(row, col);
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/streams/impl/FileDataInputStream.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/streams/impl/FileDataInputStream.java
index 01888c3..bd404a2 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/streams/impl/FileDataInputStream.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/streams/impl/FileDataInputStream.java
@@ -220,7 +220,6 @@ public class FileDataInputStream extends AbstractFileDataInputStream
             for(int i=0;i<columnMinMaxData.length;i++)
             {
                 columnMinMaxData[i]=new byte[buffer.getInt()];
-                //TODO read the short value inorder to get the column min max data for direct surrogate
                 buffer.get(columnMinMaxData[i]);
             }
             info.setColumnMinMaxData(columnMinMaxData);
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/tree/CSBTree.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/tree/CSBTree.java
index faff41e..3506377 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/tree/CSBTree.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/tree/CSBTree.java
@@ -27,7 +27,6 @@ import com.huawei.unibi.molap.engine.util.MolapEngineLogEvent;
 import com.huawei.unibi.molap.keygenerator.KeyGenerator;
 import com.huawei.unibi.molap.metadata.LeafNodeInfo;
 import com.huawei.unibi.molap.metadata.LeafNodeInfoColumnar;
-import com.huawei.unibi.molap.metadata.MolapMetadata.Cube;
 import com.huawei.unibi.molap.util.MolapProperties;
 
 /**
@@ -290,7 +289,7 @@ private void setRangeSplitvalue()
         return nTotalKeys;
     }
 
-    public void buildColumnar(List<DataInputStream> sources, boolean hasFactCount,Cube metaCube)
+    public void buildColumnar(List<DataInputStream> sources, boolean hasFactCount)
     {
         long num = 0;
         int groupCounter;
@@ -328,7 +327,7 @@ private void setRangeSplitvalue()
                             fileHolder = FileFactory.getFileHolder(FileFactory.getFileType(leafNodeInfo.getFileName()));
                         }
                         curNode = new CSBTreeColumnarLeafNode(leafNodeInfo.getNumberOfKeys(), keyBlockSize, isFileStore, fileHolder,
-                                leafNodeInfo, compressionModel,nodeNumber++,metaCube);
+                                leafNodeInfo, compressionModel,nodeNumber++);
                         nLeaf++;
     
                         if(prevNode != null)
@@ -363,8 +362,7 @@ private void setRangeSplitvalue()
 //        rangeVals = caclulateRanges(num, nodeGroups, rangeVals, fileHolder);
         if(num == 0)
         {
-//            root = new CSBInternalNode(upperMaxEntry, keyGenerator.getKeySizeInBytes(), tableName);
-            root = new CSBInternalNode(upperMaxEntry, keyGenerator.getStartAndEndKeySizeWithOnlyPrimitives(), tableName);
+            root = new CSBInternalNode(upperMaxEntry, keyGenerator.getKeySizeInBytes(), tableName);
             return;
         }
         findCurrentNode(nInternal, curNode, nodeGroups, currentGroup, interNSKeyList);
@@ -490,9 +488,7 @@ private void setRangeSplitvalue()
             for(int i = 0;i < nHigh;i++)
             {
                 // Create a new internal node
-//                curNode = new CSBInternalNode(upperMaxEntry, keyGenerator.getKeySizeInBytes(), tableName);
-                curNode = new CSBInternalNode(upperMaxEntry, keyGenerator.getStartAndEndKeySizeWithOnlyPrimitives(), tableName);
-                
+                curNode = new CSBInternalNode(upperMaxEntry, keyGenerator.getKeySizeInBytes(), tableName);
 
                 // Allocate a new node group if current node group is full
                 groupCounter = i % (upperMaxChildren);
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/tree/CSBTreeColumnarLeafNode.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/tree/CSBTreeColumnarLeafNode.java
index 4bc1529..fc26b10 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/tree/CSBTreeColumnarLeafNode.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/datastorage/tree/CSBTreeColumnarLeafNode.java
@@ -1,7 +1,5 @@
 package com.huawei.unibi.molap.engine.datastorage.tree;
 
-import java.nio.ByteBuffer;
-
 import com.huawei.unibi.molap.datastorage.store.FileHolder;
 import com.huawei.unibi.molap.datastorage.store.MeasureDataWrapper;
 import com.huawei.unibi.molap.datastorage.store.NodeMeasureDataStore;
@@ -12,8 +10,6 @@ import com.huawei.unibi.molap.datastorage.util.StoreFactory;
 import com.huawei.unibi.molap.engine.datastorage.storeInterfaces.KeyValue;
 import com.huawei.unibi.molap.engine.schema.metadata.Pair;
 import com.huawei.unibi.molap.metadata.LeafNodeInfoColumnar;
-import com.huawei.unibi.molap.metadata.MolapMetadata.Cube;
-import com.huawei.unibi.molap.olap.MolapDef.CubeDimension;
 import com.huawei.unibi.molap.util.MolapUtil;
 
 public class CSBTreeColumnarLeafNode extends CSBNode
@@ -54,7 +50,7 @@ public class CSBTreeColumnarLeafNode extends CSBNode
     private byte[][] columnMaxData;
     
     public CSBTreeColumnarLeafNode(int maxKeys, int[] eachBlockSize, boolean isFileStore, FileHolder fileHolder,
-            LeafNodeInfoColumnar leafNodeInfo, ValueCompressionModel compressionModel, long nodeNumber,Cube metaCube)
+            LeafNodeInfoColumnar leafNodeInfo, ValueCompressionModel compressionModel, long nodeNumber)
     {
         nKeys = leafNodeInfo.getNumberOfKeys();
         keyStore = StoreFactory.createColumnarKeyStore(MolapUtil.getColumnarKeyStoreInfo(leafNodeInfo, eachBlockSize), fileHolder,isFileStore);
@@ -65,36 +61,14 @@ public class CSBTreeColumnarLeafNode extends CSBNode
         byte[][] columnMinMaxData=leafNodeInfo.getColumnMinMaxData();
         this.columnMinData=new byte[columnMinMaxData.length][];
         this.columnMaxData=new byte[columnMinMaxData.length][];
-        com.huawei.unibi.molap.olap.MolapDef.Cube cubeXml=metaCube.getCube();
-        CubeDimension[] cubeDimensions=cubeXml.dimensions;
-        for(int i = 0;i < columnMinMaxData.length;i++)
+        for(int i=0;i<columnMinMaxData.length;i++)
         {
-
-            //For high cardinality dimension engine has to ignore the length and store the min and max value
-            //of dimension members.
-            if(cubeDimensions[i].highCardinality || i >= eachBlockSize.length)
-            {
-                ByteBuffer byteBuffer = ByteBuffer.allocate(columnMinMaxData[i].length);
-                byteBuffer.put(columnMinMaxData[i]);
-                byteBuffer.flip();
-                short minLength = byteBuffer.getShort();
-                this.columnMinData[i] = new byte[minLength];
-                byteBuffer.get(this.columnMinData[i]);
-                short maxLength = byteBuffer.getShort();
-                this.columnMaxData[i] = new byte[maxLength];
-                byteBuffer.get(this.columnMaxData[i]);
-
-            }
-            else
-            {
-            this.columnMinData[i] = new byte[eachBlockSize[i]];
+            this.columnMinData[i]=new byte[eachBlockSize[i]];
             System.arraycopy(columnMinMaxData[i], 0, this.columnMinData[i], 0, eachBlockSize[i]);
-
-            this.columnMaxData[i] = new byte[eachBlockSize[i]];
+            
+            this.columnMaxData[i]=new byte[eachBlockSize[i]];
             System.arraycopy(columnMinMaxData[i], eachBlockSize[i], this.columnMaxData[i], 0, eachBlockSize[i]);
-            }
         }
-        
         this.factFileName=leafNodeInfo.getFileName();
     }
 
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/directinterface/impl/MolapQueryParseUtil.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/directinterface/impl/MolapQueryParseUtil.java
index 805ece0..3e5679d 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/directinterface/impl/MolapQueryParseUtil.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/directinterface/impl/MolapQueryParseUtil.java
@@ -475,7 +475,7 @@ public final class MolapQueryParseUtil
         String selectedTableName = null;
         double minNoOfrecords = 0;
         MeasureMetaDataModel model = null;
-        double[] maxValue = null;
+        Object[] maxValue = null;
         Iterator<String> aggTblItr = aggtables.iterator();
         while(aggTblItr.hasNext())
         {
@@ -503,7 +503,7 @@ public final class MolapQueryParseUtil
                         model = ValueCompressionUtil.readMeasureMetaDataFile(msrMetadataFilePath,
                                 tableMeasureCountMapping.get(aggTableName));
                         maxValue = model.getMaxValue();
-                        recordCount = recordCount + maxValue[maxValue.length - 1];
+                        recordCount = recordCount + (double)maxValue[maxValue.length - 1];
                     }
                 }
             }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/AbstractConditionalEvalutor.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/AbstractConditionalEvalutor.java
index 476ea28..b520c54 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/AbstractConditionalEvalutor.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/AbstractConditionalEvalutor.java
@@ -11,7 +11,6 @@ import com.huawei.unibi.molap.engine.expression.conditional.BinaryConditionalExp
 import com.huawei.unibi.molap.engine.expression.conditional.ConditionalExpression;
 import com.huawei.unibi.molap.engine.filters.measurefilter.util.FilterUtil;
 import com.huawei.unibi.molap.engine.schema.metadata.FilterEvaluatorInfo;
-import com.huawei.unibi.molap.olap.SqlStatement.Type;
 
 public abstract class AbstractConditionalEvalutor implements FilterEvaluator
 {
@@ -59,19 +58,16 @@ public abstract class AbstractConditionalEvalutor implements FilterEvaluator
                     // If imei=imei comes in filter condition then we need to skip processing of right expression.
                     // This flow has reached here assuming that this is a single column expression.
                     //  we need to check if the other expression contains column expression or not in depth.
-                    if(FilterUtil.checkIfExpressionContainsColumn(rightExp))
+                    if(checkIfExpressionContainsColumn(rightExp))
                     {
                         isExpressionResolve = true;
                     }
                     else
                     {
                         dimColumnEvaluatorInfo.setColumnIndex(columnExpression.getDim().getOrdinal());
-                        if(!columnExpression.getDim().isHighCardinalityDim())
-                        {
                         dimColumnEvaluatorInfo.setNeedCompressedData(info.getSlices().get(info.getCurrentSliceIndex())
                                 .getDataCache(info.getFactTableName()).getAggKeyBlock()[columnExpression.getDim()
                                 .getOrdinal()]);
-                        }
                         dimColumnEvaluatorInfo.setFilterValues(FilterUtil.getFilterList(info, rightExp, columnExpression,
                                 this.isIncludeFilter));
                     }
@@ -89,19 +85,16 @@ public abstract class AbstractConditionalEvalutor implements FilterEvaluator
                     // if imei=imei comes in filter condition then we need to skip processing of right expression.
                     // This flow has reached here assuming that this is a single column expression.
                     //  we need to check if the other expression contains column expression or not in depth.
-                    if(FilterUtil.checkIfExpressionContainsColumn(leftExp))
+                    if(checkIfExpressionContainsColumn(leftExp))
                     {
                         isExpressionResolve = true;
                     }
                     else
                     {
                         dimColumnEvaluatorInfo.setColumnIndex(columnExpression.getDim().getOrdinal());
-                        if(!columnExpression.getDim().isHighCardinalityDim())
-                        {
                         dimColumnEvaluatorInfo.setNeedCompressedData(info.getSlices().get(info.getCurrentSliceIndex())
                                 .getDataCache(info.getFactTableName()).getAggKeyBlock()[columnExpression.getDim()
                                 .getOrdinal()]);
-                        }
                         dimColumnEvaluatorInfo.setFilterValues(FilterUtil.getFilterList(info, leftExp, columnExpression,
                                 isIncludeFilter));
                     }
@@ -118,24 +111,35 @@ public abstract class AbstractConditionalEvalutor implements FilterEvaluator
             ConditionalExpression conditionalExpression = (ConditionalExpression)exp;
             List<ColumnExpression> columnList = conditionalExpression.getColumnList();
             dimColumnEvaluatorInfo.setColumnIndex(columnList.get(0).getDim().getOrdinal());
-            if(!columnList.get(0).getDim().isHighCardinalityDim())
-            {
             dimColumnEvaluatorInfo.setNeedCompressedData(info.getSlices().get(info.getCurrentSliceIndex())
                     .getDataCache(info.getFactTableName()).getAggKeyBlock()[columnList.get(0).getDim().getOrdinal()]);
-            }
-            if(columnList.get(0).getDim().isHighCardinalityDim())
-            {
-                dimColumnEvaluatorInfo.setFilterValues(FilterUtil.getFilterList(info, exp, columnList.get(0),isIncludeFilter));
-            }
-            else if(!(columnList.get(0).getDim().getDataType() == Type.ARRAY || columnList.get(0).getDim().getDataType() == Type.STRUCT))
-            {
-            	dimColumnEvaluatorInfo.setFilterValues(FilterUtil.getFilterListForAllMembers(info, exp, columnList.get(0),isIncludeFilter));
-            }
+            dimColumnEvaluatorInfo.setFilterValues(FilterUtil.getFilterListForAllMembers(info, exp, columnList.get(0),isIncludeFilter));
         }
         dimColEvaluatorInfoList.add(dimColumnEvaluatorInfo);
     }
 
- 
+    /**
+     * This method will check if a given expression contains a column expression recursively.
+     * 
+     * @param right
+     * @return
+     */
+    private boolean checkIfExpressionContainsColumn(Expression expression)
+    {
+        if(expression instanceof ColumnExpression)
+        {
+            return true;
+        }
+        for(Expression child: expression.getChildren())
+        {
+            if(checkIfExpressionContainsColumn(child))
+            {
+                return true;
+            }
+        }
+        
+        return false;
+    }
 
     public FilterEvaluator getLeft()
     {
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/DimColumnEvaluatorInfo.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/DimColumnEvaluatorInfo.java
index fb2405d..bee68c9 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/DimColumnEvaluatorInfo.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/DimColumnEvaluatorInfo.java
@@ -1,9 +1,7 @@
 package com.huawei.unibi.molap.engine.evaluators;
 
 import java.util.List;
-import java.util.Map;
 
-import com.huawei.unibi.molap.engine.complex.querytypes.GenericQueryType;
 import com.huawei.unibi.molap.engine.datastorage.InMemoryCube;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
 
@@ -39,8 +37,6 @@ public class DimColumnEvaluatorInfo
      * dims
      */
     private Dimension dims;
-
-    private Dimension[] dimensions;
     
     /**
      * rowIndex
@@ -53,28 +49,6 @@ public class DimColumnEvaluatorInfo
     
     private String defaultValue;
     
-    private Map<Integer, GenericQueryType> complexTypesWithBlockStartIndex; 
-
-    public Map<Integer, GenericQueryType> getComplexTypesWithBlockStartIndex()
-    {
-        return complexTypesWithBlockStartIndex;
-    }
-
-    public void setComplexTypesWithBlockStartIndex(Map<Integer, GenericQueryType> complexTypesWithBlockStartIndex)
-    {
-        this.complexTypesWithBlockStartIndex = complexTypesWithBlockStartIndex;
-    }
-    
-    public Dimension[] getDimensions()
-    {
-        return dimensions;
-    }
-
-    public void setDimensions(Dimension[] dimensions)
-    {
-        this.dimensions = dimensions;
-    }
-    
     public int getColumnIndex()
     {
         return columnIndex;
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/MsrColumnEvalutorInfo.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/MsrColumnEvalutorInfo.java
index 5ee436d..c9fb668 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/MsrColumnEvalutorInfo.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/MsrColumnEvalutorInfo.java
@@ -8,13 +8,13 @@ public class MsrColumnEvalutorInfo
     
     private boolean isCustomMeasureValue;
     
-    private double uniqueValue;
+    private Object uniqueValue;
     
     private String aggregator;
     
     private boolean isMeasureExistsInCurrentSlice=true;
     
-    private double defaultValue;
+    private Object defaultValue;
 
     public int getColumnIndex()
     {
@@ -46,12 +46,12 @@ public class MsrColumnEvalutorInfo
         this.isCustomMeasureValue = isCustomMeasureValue;
     }
 
-    public double getUniqueValue()
+    public Object getUniqueValue()
     {
         return uniqueValue;
     }
 
-    public void setUniqueValue(double uniqueValue)
+    public void setUniqueValue(Object uniqueValue)
     {
         this.uniqueValue = uniqueValue;
     }
@@ -86,7 +86,7 @@ public class MsrColumnEvalutorInfo
         this.isMeasureExistsInCurrentSlice = isMeasureExistsInCurrentSlice;
     }
 
-    public double getDefaultValue()
+    public Object getDefaultValue()
     {
         return defaultValue;
     }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/conditional/dimcolumns/NonUniqueBlockEqualsEvalutor.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/conditional/dimcolumns/NonUniqueBlockEqualsEvalutor.java
index ef554b3..bec1928 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/conditional/dimcolumns/NonUniqueBlockEqualsEvalutor.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/conditional/dimcolumns/NonUniqueBlockEqualsEvalutor.java
@@ -1,8 +1,6 @@
 package com.huawei.unibi.molap.engine.evaluators.conditional.dimcolumns;
 
-import java.nio.ByteBuffer;
 import java.util.BitSet;
-import java.util.Map;
 
 import com.huawei.unibi.molap.datastorage.store.columnar.ColumnarKeyStoreDataHolder;
 import com.huawei.unibi.molap.engine.evaluators.AbstractConditionalEvalutor;
@@ -37,63 +35,13 @@ public class NonUniqueBlockEqualsEvalutor extends AbstractConditionalEvalutor
 
     private BitSet getFilteredIndexes(ColumnarKeyStoreDataHolder keyBlockArray, int numerOfRows)
     {
-        if(keyBlockArray.getColumnarKeyStoreMetadata().isDirectSurrogateColumn())
-        {
-            return setDirectKeyFilterIndexToBitSet(keyBlockArray,numerOfRows);
-        }
-        else if(null!=keyBlockArray.getColumnarKeyStoreMetadata().getColumnIndex())
+        if(null!=keyBlockArray.getColumnarKeyStoreMetadata().getColumnIndex())
         {
             return setFilterdIndexToBitSetWithColumnIndex(keyBlockArray,numerOfRows);
         }
-
         return setFilterdIndexToBitSet(keyBlockArray,numerOfRows);
     }
     
-    private BitSet setDirectKeyFilterIndexToBitSet(ColumnarKeyStoreDataHolder keyBlockArray, int numerOfRows)
-    {
-        BitSet bitSet = new BitSet(numerOfRows);
-        Map<Integer, byte[]> mapOfColumnarKeyBlockDataForDirectSurroagtes = keyBlockArray
-                .getColumnarKeyStoreMetadata().getMapOfColumnarKeyBlockDataForDirectSurroagtes();
-        byte[][] filterValues = dimColEvaluatorInfoList.get(0).getFilterValues();
-        int[] columnIndexArray = keyBlockArray.getColumnarKeyStoreMetadata().getColumnIndex();
-        int[] columnReverseIndexArray = keyBlockArray.getColumnarKeyStoreMetadata()
-                .getColumnReverseIndex();
-        for(int i = 0;i < filterValues.length;i++)
-        {
-            byte[] filterVal = filterValues[i];
-            if(null != mapOfColumnarKeyBlockDataForDirectSurroagtes)
-            {
-
-                if(null != columnIndexArray)
-                {
-                    for(int index : columnIndexArray)
-                    {
-                        byte[] directSurrogate = mapOfColumnarKeyBlockDataForDirectSurroagtes.get(columnReverseIndexArray[index]);
-                        if(ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterVal, directSurrogate) == 0)
-                        {
-                            bitSet.set(index);
-                        }
-                    }
-                }
-                else if(null != columnReverseIndexArray)
-                {
-
-                    for(int index : columnReverseIndexArray)
-                    {
-                        byte[] directSurrogate = mapOfColumnarKeyBlockDataForDirectSurroagtes.get(columnReverseIndexArray[index]);
-                        if(ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterVal, directSurrogate) == 0)
-                        {
-                            bitSet.set(index);
-                        }
-                    }
-                }
-
-            }
-        }
-        return bitSet;
-        
-    }
-
     private BitSet setFilterdIndexToBitSetWithColumnIndex(ColumnarKeyStoreDataHolder keyBlockArray, int numerOfRows)
     {
         int[] columnIndex = keyBlockArray.getColumnarKeyStoreMetadata().getColumnIndex();
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/conditional/dimcolumns/NonUniqueBlockNotEqualsEvaluator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/conditional/dimcolumns/NonUniqueBlockNotEqualsEvaluator.java
index 34c5dea..7d7f2a8 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/conditional/dimcolumns/NonUniqueBlockNotEqualsEvaluator.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/conditional/dimcolumns/NonUniqueBlockNotEqualsEvaluator.java
@@ -1,7 +1,6 @@
 package com.huawei.unibi.molap.engine.evaluators.conditional.dimcolumns;
 
 import java.util.BitSet;
-import java.util.Map;
 
 import com.huawei.unibi.molap.datastorage.store.columnar.ColumnarKeyStoreDataHolder;
 import com.huawei.unibi.molap.engine.evaluators.AbstractConditionalEvalutor;
@@ -35,11 +34,6 @@ public class NonUniqueBlockNotEqualsEvaluator extends AbstractConditionalEvaluto
 
     private BitSet getFilteredIndexes(ColumnarKeyStoreDataHolder keyStoreArray, int numerOfRows)
     {
-        //For high cardinality dimensions.
-        if(keyStoreArray.getColumnarKeyStoreMetadata().isDirectSurrogateColumn())
-        {
-            return setDirectKeyFilterIndexToBitSet(keyStoreArray,numerOfRows);
-        }
         if(null!=keyStoreArray.getColumnarKeyStoreMetadata().getColumnIndex())
         {
             return setFilterdIndexToBitSetWithColumnIndex(keyStoreArray,numerOfRows);
@@ -47,53 +41,6 @@ public class NonUniqueBlockNotEqualsEvaluator extends AbstractConditionalEvaluto
         return setFilterdIndexToBitSet(keyStoreArray,numerOfRows);
     }
     
-    private BitSet setDirectKeyFilterIndexToBitSet(ColumnarKeyStoreDataHolder keyBlockArray, int numerOfRows)
-    {
-        BitSet bitSet = new BitSet(numerOfRows);
-        bitSet.flip(0,numerOfRows);
-        Map<Integer, byte[]> mapOfColumnarKeyBlockDataForDirectSurroagtes = keyBlockArray
-                .getColumnarKeyStoreMetadata().getMapOfColumnarKeyBlockDataForDirectSurroagtes();
-        byte[][] filterValues = dimColEvaluatorInfoList.get(0).getFilterValues();
-        int[] columnIndexArray = keyBlockArray.getColumnarKeyStoreMetadata().getColumnIndex();
-        int[] columnReverseIndexArray = keyBlockArray.getColumnarKeyStoreMetadata()
-                .getColumnReverseIndex();
-        for(int i = 0;i < filterValues.length;i++)
-        {
-            byte[] filterVal = filterValues[i];
-            if(null != mapOfColumnarKeyBlockDataForDirectSurroagtes)
-            {
-
-                if(null != columnReverseIndexArray)
-                {
-                    for(int index : columnIndexArray)
-                    {
-                        byte[] directSurrogate = mapOfColumnarKeyBlockDataForDirectSurroagtes.get(columnReverseIndexArray[index]);
-                        if(ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterVal, directSurrogate) == 0)
-                        {
-                            bitSet.flip(index);
-                        }
-                    }
-                }
-                else if(null != columnIndexArray)
-                {
-
-                    for(int index : columnIndexArray)
-                    {
-                        byte[] directSurrogate = mapOfColumnarKeyBlockDataForDirectSurroagtes.get(columnIndexArray[index]);
-                        if(ByteUtil.UnsafeComparer.INSTANCE.compareTo(filterVal, directSurrogate) == 0)
-                        {
-                            bitSet.flip(index);
-                        }
-                    }
-                }
-
-            }
-        }
-        return bitSet;
-        
-    }
-
-    
     private BitSet setFilterdIndexToBitSetWithColumnIndex(ColumnarKeyStoreDataHolder keyBlockArray, int numerOfRows)
     {
         int[] columnIndex = keyBlockArray.getColumnarKeyStoreMetadata().getColumnIndex();
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/conditional/row/RowLevelFilterEvalutor.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/conditional/row/RowLevelFilterEvalutor.java
index 55334ad..6b64ce2 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/conditional/row/RowLevelFilterEvalutor.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/evaluators/conditional/row/RowLevelFilterEvalutor.java
@@ -1,20 +1,13 @@
 package com.huawei.unibi.molap.engine.evaluators.conditional.row;
 
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
 import java.util.BitSet;
 import java.util.List;
 
 import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
-import com.huawei.unibi.molap.datastorage.store.columnar.ColumnarKeyStoreDataHolder;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 import com.huawei.unibi.molap.engine.aggregator.util.AggUtil;
-import com.huawei.unibi.molap.engine.complex.querytypes.GenericQueryType;
-import com.huawei.unibi.molap.engine.datastorage.InMemoryCube;
 import com.huawei.unibi.molap.engine.datastorage.Member;
 import com.huawei.unibi.molap.engine.evaluators.AbstractConditionalEvalutor;
 import com.huawei.unibi.molap.engine.evaluators.BlockDataHolder;
@@ -31,9 +24,8 @@ import com.huawei.unibi.molap.engine.schema.metadata.FilterEvaluatorInfo;
 import com.huawei.unibi.molap.engine.util.DataTypeConverter;
 import com.huawei.unibi.molap.engine.util.MolapEngineLogEvent;
 import com.huawei.unibi.molap.engine.util.QueryExecutorUtility;
-import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Measure;
-import com.huawei.unibi.molap.olap.SqlStatement.Type;
+import com.huawei.unibi.molap.olap.SqlStatement;
 
 public class RowLevelFilterEvalutor extends AbstractConditionalEvalutor
 {
@@ -65,8 +57,6 @@ public class RowLevelFilterEvalutor extends AbstractConditionalEvalutor
                     dimColumnEvaluatorInfo.setSlices(info.getSlices());
                     dimColumnEvaluatorInfo.setCurrentSliceIndex(info.getCurrentSliceIndex());
                     dimColumnEvaluatorInfo.setDims(columnExpression.getDim());
-                    dimColumnEvaluatorInfo.setComplexTypesWithBlockStartIndex(info.getComplexTypesWithBlockStartIndex());
-                    dimColumnEvaluatorInfo.setDimensions(info.getDimensions());
                     int newDimensionIndex = QueryExecutorUtility.isNewDimension(
                             info.getNewDimension(), columnExpression.getDim());
                     if(newDimensionIndex>-1)
@@ -84,7 +74,7 @@ public class RowLevelFilterEvalutor extends AbstractConditionalEvalutor
                 {
                     msrColumnEvalutorInfo = new MsrColumnEvalutorInfo();
                     msrColumnEvalutorInfo.setRowIndex(index++);
-                    msrColumnEvalutorInfo.setAggregator(((Measure)columnExpression.getDim()).getAggName());
+                    msrColumnEvalutorInfo.setAggregator(((Measure) columnExpression.getDim()).getAggName());
                     int measureIndex=QueryExecutorUtility.isNewMeasure(info.getNewMeasures(), ((Measure)columnExpression.getDim()));
                     // if measure is found then index returned will be > 0 .
                     // else it will be -1 . here if the measure is a newly added
@@ -113,28 +103,20 @@ public class RowLevelFilterEvalutor extends AbstractConditionalEvalutor
     {
         for(DimColumnEvaluatorInfo dimColumnEvaluatorInfo:dimColEvaluatorInfoList)
         {
-            if(dimColumnEvaluatorInfo.getDims().getDataType() != Type.ARRAY  && dimColumnEvaluatorInfo.getDims().getDataType() != Type.STRUCT)
+            if(null==blockDataHolder.getColumnarKeyStore()[dimColumnEvaluatorInfo.getColumnIndex()])
             {
-                if(null==blockDataHolder.getColumnarKeyStore()[dimColumnEvaluatorInfo.getColumnIndex()])
-                {
-                    blockDataHolder.getColumnarKeyStore()[dimColumnEvaluatorInfo.getColumnIndex()] = blockDataHolder
-                            .getLeafDataBlock().getColumnarKeyStore(blockDataHolder.getFileHolder(),
-                                    dimColumnEvaluatorInfo.getColumnIndex(),
-                                    false);
-                }
-                else
-                {
-                    if(!blockDataHolder.getColumnarKeyStore()[dimColumnEvaluatorInfo.getColumnIndex()]
-                            .getColumnarKeyStoreMetadata().isUnCompressed())
-                    {
-                        blockDataHolder.getColumnarKeyStore()[dimColumnEvaluatorInfo.getColumnIndex()].unCompress();
-                    }
-                }
+                blockDataHolder.getColumnarKeyStore()[dimColumnEvaluatorInfo.getColumnIndex()] = blockDataHolder
+                        .getLeafDataBlock().getColumnarKeyStore(blockDataHolder.getFileHolder(),
+                                dimColumnEvaluatorInfo.getColumnIndex(),
+                                false);
             }
             else
             {
-                GenericQueryType complexType = dimColumnEvaluatorInfo.getComplexTypesWithBlockStartIndex().get(dimColumnEvaluatorInfo.getColumnIndex());
-                complexType.fillRequiredBlockData(blockDataHolder);
+                if(!blockDataHolder.getColumnarKeyStore()[dimColumnEvaluatorInfo.getColumnIndex()]
+                        .getColumnarKeyStoreMetadata().isUnCompressed())
+                {
+                    blockDataHolder.getColumnarKeyStore()[dimColumnEvaluatorInfo.getColumnIndex()].unCompress();
+                }
             }
         }
         
@@ -183,77 +165,30 @@ public class RowLevelFilterEvalutor extends AbstractConditionalEvalutor
         String memberString= null;
         for(DimColumnEvaluatorInfo dimColumnEvaluatorInfo:dimColEvaluatorInfoList)
         {
-            if(dimColumnEvaluatorInfo.getDims().getDataType() != Type.ARRAY  && dimColumnEvaluatorInfo.getDims().getDataType() != Type.STRUCT)
-            {
-                if(!dimColumnEvaluatorInfo.isDimensionExistsInCurrentSilce())
-                {
-                    record[dimColumnEvaluatorInfo.getRowIndex()]=dimColumnEvaluatorInfo.getDefaultValue();
-                }
-                Member member = QueryExecutorUtility.getMemberBySurrogateKey(dimColumnEvaluatorInfo
-                        .getDims(), blockDataHolder.getColumnarKeyStore()[dimColumnEvaluatorInfo.getColumnIndex()]
-                        .getSurrogateKey(index), dimColumnEvaluatorInfo.getSlices(),dimColumnEvaluatorInfo.getCurrentSliceIndex());
-                
-                if(null != member)
-                {
-                    memberString = member.toString();
-                    if(memberString.equals(MolapCommonConstants.MEMBER_DEFAULT_VAL))
-                    {
-                        memberString=null;
-                    }
-                }
-                record[dimColumnEvaluatorInfo.getRowIndex()] = DataTypeConverter.getDataBasedOnDataType(memberString,dimColumnEvaluatorInfo.getDims().getDataType());
-            }
-            if(dimColumnEvaluatorInfo.getDims().isHighCardinalityDim())
+            if(!dimColumnEvaluatorInfo.isDimensionExistsInCurrentSilce())
             {
-                ColumnarKeyStoreDataHolder columnarKeyStoreDataHolder=blockDataHolder.getColumnarKeyStore()[dimColumnEvaluatorInfo.getColumnIndex()];
-                if(null!=columnarKeyStoreDataHolder.getColumnarKeyStoreMetadata().getMapOfColumnarKeyBlockDataForDirectSurroagtes())
-                {
-                    Member member = readMemberBasedOnDirectSurrogate(dimColumnEvaluatorInfo, columnarKeyStoreDataHolder,index);
-                    if(null != member)
-                    {
-                        memberString = member.toString();
-                        if(memberString.equals(MolapCommonConstants.MEMBER_DEFAULT_VAL))
-                        {
-                            memberString=null;
-                        }
-                    }
-                    record[dimColumnEvaluatorInfo.getRowIndex()] = DataTypeConverter.getDataBasedOnDataType(memberString,dimColumnEvaluatorInfo.getDims().getDataType());
-                }
-                else
-                {
-                    continue;
-                }
+                record[dimColumnEvaluatorInfo.getRowIndex()]=dimColumnEvaluatorInfo.getDefaultValue();
             }
-            else
-            {
             Member member = QueryExecutorUtility.getMemberBySurrogateKey(dimColumnEvaluatorInfo
                     .getDims(), blockDataHolder.getColumnarKeyStore()[dimColumnEvaluatorInfo.getColumnIndex()]
                     .getSurrogateKey(index), dimColumnEvaluatorInfo.getSlices(),dimColumnEvaluatorInfo.getCurrentSliceIndex());
             
             if(null != member)
             {
-                try
-                {
-                    GenericQueryType complexType = dimColumnEvaluatorInfo.getComplexTypesWithBlockStartIndex().get(dimColumnEvaluatorInfo.getColumnIndex());
-                    ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
-                    DataOutputStream dataOutputStream = new DataOutputStream(byteStream);
-                    complexType.parseBlocksAndReturnComplexColumnByteArray(blockDataHolder.getColumnarKeyStore(), index, dataOutputStream);
-                    record[dimColumnEvaluatorInfo.getRowIndex()] = complexType.getDataBasedOnDataTypeFromSurrogates(
-                            dimColumnEvaluatorInfo.getSlices(), ByteBuffer.wrap(byteStream.toByteArray()),
-                            dimColumnEvaluatorInfo.getDimensions());
-                    byteStream.close();
-                }
-                catch(IOException e)
+                memberString = member.toString();
+                if(memberString.equals(MolapCommonConstants.MEMBER_DEFAULT_VAL))
                 {
-                    LOGGER.info(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, e, e.getMessage());
+                    memberString=null;
                 }
-                
             }
+            record[dimColumnEvaluatorInfo.getRowIndex()] = DataTypeConverter.getDataBasedOnDataType(memberString,dimColumnEvaluatorInfo.getDims().getDataType());
         }
-       }
-        
+        SqlStatement.Type msrType;
+        Object msrValue;
         for(MsrColumnEvalutorInfo msrColumnEvalutorInfo : msrColEvalutorInfoList)
         {
+            msrType = AggUtil.getMeasureType(msrColumnEvalutorInfo
+                    .getColumnIndex());
             // if measure doesnt exist then set the default value.
             if(!msrColumnEvalutorInfo.isMeasureExistsInCurrentSlice())
             {
@@ -263,55 +198,55 @@ public class RowLevelFilterEvalutor extends AbstractConditionalEvalutor
             {
                 if(msrColumnEvalutorInfo.isCustomMeasureValue())
                 {
-                    MeasureAggregator aggregator = AggUtil.getAggregator(msrColumnEvalutorInfo.getAggregator(),false,false, null, false, 0);
-                    
+                    MeasureAggregator aggregator = AggUtil.getAggregator(msrColumnEvalutorInfo.getAggregator(), false, null, false, 0, msrType);
                     aggregator.merge(blockDataHolder.getMeasureBlocks()[msrColumnEvalutorInfo
                             .getColumnIndex()].getReadableByteArrayValueByIndex(index));
-                    record[msrColumnEvalutorInfo.getRowIndex()] = aggregator.getValue();
-                }
-                else if(msrColumnEvalutorInfo.getUniqueValue() == blockDataHolder.getMeasureBlocks()[msrColumnEvalutorInfo
-                        .getColumnIndex()].getReadableDoubleValueByIndex(index))
-                {
-                    record[msrColumnEvalutorInfo.getRowIndex()] = null;
+                    switch(msrType)
+                    {
+                        case BIGINT:
+                            record[msrColumnEvalutorInfo.getRowIndex()] = aggregator.getLongValue();
+                            break;
+                        case DECIMAL:
+                            record[msrColumnEvalutorInfo.getRowIndex()] = aggregator.getBigDecimalValue();
+                            break;
+                        default:
+                            record[msrColumnEvalutorInfo.getRowIndex()] = aggregator.getDoubleValue();
+                    }
                 }
+//                else if(msrColumnEvalutorInfo.getUniqueValue() == blockDataHolder.getMeasureBlocks()[msrColumnEvalutorInfo
+//                        .getColumnIndex()].getReadableDoubleValueByIndex(index))
+//                {
+//                    record[msrColumnEvalutorInfo.getRowIndex()] = null;
+//                }
                 else
                 {
-                    record[msrColumnEvalutorInfo.getRowIndex()] = blockDataHolder.getMeasureBlocks()[msrColumnEvalutorInfo
-                            .getColumnIndex()].getReadableDoubleValueByIndex(index);
+                    switch(msrType)
+                    {
+                        case BIGINT:
+                            msrValue = blockDataHolder.getMeasureBlocks()[msrColumnEvalutorInfo.getColumnIndex()]
+                                    .getReadableLongValueByIndex(index);
+                            break;
+                        case DECIMAL:
+                            msrValue = blockDataHolder.getMeasureBlocks()[msrColumnEvalutorInfo.getColumnIndex()]
+                                    .getReadableBigDecimalValueByIndex(index);
+                            break;
+                        default:
+                            msrValue = blockDataHolder.getMeasureBlocks()[msrColumnEvalutorInfo.getColumnIndex()]
+                                    .getReadableDoubleValueByIndex(index);
+                    }
+                    if(msrColumnEvalutorInfo.getUniqueValue().equals(msrValue))
+                    {
+                        record[msrColumnEvalutorInfo.getRowIndex()] = null;
+                    }
+                    else
+                    {
+                        record[msrColumnEvalutorInfo.getRowIndex()] = msrValue;
+                    }
                 }
             }
         }
         row.setValues(record);
     }
-
-    /**
-     * Reading the blocks for direct surrogates.
-     * @param dimColumnEvaluatorInfo
-     * @param columnarKeyStoreDataHolder
-     * @param index 
-     * @return
-     */
-    private Member readMemberBasedOnDirectSurrogate(DimColumnEvaluatorInfo dimColumnEvaluatorInfo,
-            ColumnarKeyStoreDataHolder columnarKeyStoreDataHolder, int index)
-    {
-        byte[] directSurrogates;
-        if(null != columnarKeyStoreDataHolder.getColumnarKeyStoreMetadata().getColumnReverseIndex())
-        {
-            // Getting the data for direct surrogates.
-            directSurrogates=columnarKeyStoreDataHolder
-                    .getColumnarKeyStoreMetadata()
-                    .getMapOfColumnarKeyBlockDataForDirectSurroagtes()
-                    .get(columnarKeyStoreDataHolder.getColumnarKeyStoreMetadata().getColumnReverseIndex()[index]);
-        }
-        else
-        {
-            directSurrogates=   columnarKeyStoreDataHolder.getColumnarKeyStoreMetadata()
-                    .getMapOfColumnarKeyBlockDataForDirectSurroagtes()
-                    .get(index);
-        }
-        Member member =new Member(directSurrogates);
-        return member;
-    }
     
     @Override
     public BitSet isScanRequired(byte[][] blockMaxValue, byte[][] blockMinValue)
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/MolapQueryExecutorModel.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/MolapQueryExecutorModel.java
index ad346c0..26641cc 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/MolapQueryExecutorModel.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/MolapQueryExecutorModel.java
@@ -15,12 +15,9 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
-import org.apache.spark.Accumulator;
-
 import com.huawei.datasight.molap.core.load.LoadMetadataDetails;
 import com.huawei.unibi.molap.engine.aggregator.CustomMolapAggregateExpression;
 import com.huawei.unibi.molap.engine.aggregator.dimension.DimensionAggregatorInfo;
-import com.huawei.unibi.molap.engine.complex.querytypes.GenericQueryType;
 import com.huawei.unibi.molap.engine.directinterface.impl.MeasureSortModel;
 import com.huawei.unibi.molap.engine.expression.Expression;
 import com.huawei.unibi.molap.engine.filters.measurefilter.GroupMeasureFilterModel;
@@ -31,6 +28,8 @@ import com.huawei.unibi.molap.metadata.MolapMetadata.Cube;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Measure;
 
+import org.apache.spark.Accumulator;
+
 /**
  * Its a model object for MolapExecutor interface
  * @author R00900208
@@ -82,11 +81,6 @@ public class MolapQueryExecutorModel implements Serializable
     private Map<Dimension, MolapFilterInfo> constraintsAfterTopN;
 
     /**
-     * constraints 
-     */
-    private Map<String, GenericQueryType> complexDimensionsMap;
-
-    /**
      * msrFilterModels
      */
     private List<GroupMeasureFilterModel> msrFilterModelsTopN;
@@ -341,16 +335,6 @@ public class MolapQueryExecutorModel implements Serializable
         this.dims = dims;
     }
 
-    public Map<String, GenericQueryType> getComplexDimensionsMap()
-    {
-        return complexDimensionsMap;
-    }
-
-    public void setComplexDimensionsMap(Map<String, GenericQueryType> complexDimensionsMap)
-    {
-        this.complexDimensionsMap = complexDimensionsMap;
-    }
-    
     /**
      * @return the msrs
      */
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/calcexp/impl/MolapSingleMeasureFunction.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/calcexp/impl/MolapSingleMeasureFunction.java
index 8f4582c..144de23 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/calcexp/impl/MolapSingleMeasureFunction.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/calcexp/impl/MolapSingleMeasureFunction.java
@@ -14,6 +14,7 @@ import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 //import mondrian.mdx.MemberExpr;
 //import mondrian.olap.Exp;
 //import mondrian.rolap.RolapBaseCubeMeasure;
+import com.huawei.unibi.molap.engine.aggregator.util.AggUtil;
 import com.huawei.unibi.molap.olap.Exp;
 
 /**
@@ -39,11 +40,24 @@ public class MolapSingleMeasureFunction extends AbstractMolapCalcFunction
     }
 
 
-
+// TODO Jay:maybe need to change for query
     @Override
     public double calculate(MeasureAggregator[] msrAggs)
     {
-        return msrAggs[index].isFirstTime()?0:msrAggs[index].getValue();
+        double value;
+        switch (AggUtil.getMeasureType(AggUtil.measureOrdinal[index]))
+        {
+            case BIGINT:
+                value = msrAggs[index].getLongValue();
+                break;
+            case DECIMAL:
+                value = msrAggs[index].getBigDecimalValue().doubleValue();
+                break;
+            default:
+                value = msrAggs[index].getDoubleValue();
+        }
+
+        return msrAggs[index].isFirstTime()?0:value;
     }
 
     @Override
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/groupby/GroupByHolder.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/groupby/GroupByHolder.java
index d9eda63..760a2b8 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/groupby/GroupByHolder.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/groupby/GroupByHolder.java
@@ -215,7 +215,7 @@ public class GroupByHolder
     {
         CalculatedMeasureAggregator aggregator = new CalculatedMeasureAggregatorImpl(calcFunction);
         aggregator.calculateCalcMeasure(aggs);
-        return aggregator.getValue();
+        return aggregator.getDoubleValue();
     }
     
     /**
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/AbstractQueryExecutor.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/AbstractQueryExecutor.java
index 4affafc..9543c08 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/AbstractQueryExecutor.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/AbstractQueryExecutor.java
@@ -27,8 +27,10 @@ import com.huawei.unibi.molap.engine.util.QueryExecutorUtility;
 import com.huawei.unibi.molap.keygenerator.KeyGenException;
 import com.huawei.unibi.molap.keygenerator.KeyGenerator;
 import com.huawei.unibi.molap.keygenerator.factory.KeyGeneratorFactory;
+import com.huawei.unibi.molap.metadata.MolapMetadata.Cube;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Measure;
+import com.huawei.unibi.molap.olap.SqlStatement;
 
 /**
  * Abstract class used for query execution and to use to initialize all the properties used for query execution
@@ -57,7 +59,6 @@ public abstract class AbstractQueryExecutor implements QueryExecutor
         if(dimList != null)
         {
             executerProperties.dimTables = dimList.toArray(new Dimension[dimList.size()]);
-            executerProperties.complexDimensionsMap = QueryExecutorUtility.getComplexDimensionsMap(executerProperties.dimTables);
         }
         Long threadID = Thread.currentThread().getId();
         List<Long> sliceIds = QueryMapper.getSlicesForThread(threadID);
@@ -121,9 +122,9 @@ public abstract class AbstractQueryExecutor implements QueryExecutor
         executerProperties.uniqueValue = QueryExecutorUtility.updateUniqueForSlices(queryModel.getFactTable(),
                 queryModel.isAggTable(), executerProperties.slices);
         
-        double[] msrMinValue = QueryExecutorUtility.getMinValueOfSlices(queryModel.getFactTable(),
+        Object[] msrMinValue = QueryExecutorUtility.getMinValueOfSlices(queryModel.getFactTable(),
                 queryModel.isAggTable(), executerProperties.slices);
-        
+
         executerProperties.dimSortOrder = new byte[0];
         
         int aggTypeCount = queryModel.getMsrs().size() + queryModel.getExpressions().size();
@@ -134,39 +135,37 @@ public abstract class AbstractQueryExecutor implements QueryExecutor
             aggTypeCount+=iterator.next().getAggList().size();
         }
         executerProperties.aggTypes= new String[aggTypeCount];
-        executerProperties.isHighCardinality=new boolean[aggTypeCount];
+        executerProperties.dataTypes = new SqlStatement.Type[aggTypeCount];
+        Cube cube = queryModel.getCube();
         int index=0;
         iterator = queryModel.getDimensionAggInfo().iterator();
         for(int i = 0;i < queryModel.getDimensionAggInfo().size();i++)
         {
-            DimensionAggregatorInfo dimAggInfo=queryModel.getDimensionAggInfo().get(i);
-            if(null!=dimAggInfo)
-            {
-               
-                if(dimAggInfo.getDim().isHighCardinalityDim())
-                {
-                    executerProperties.isHighCardinality[index]=true;
-                }
-               // executerProperties.a
-            }
-            List<String> aggList = iterator.next().getAggList();
+            DimensionAggregatorInfo info = iterator.next();
+            Dimension dimension = cube.getDimension(info.getColumnName(), cube.getFactTableName());
+            List<String> aggList = info.getAggList();
             for(int j = 0;j < aggList.size();j++)
             {
-
                 executerProperties.aggTypes[index] = aggList.get(j);
+                executerProperties.dataTypes[index] = SqlStatement.Type.STRING;
                 index++;
             }
         }
         
         for(int i = 0;i < queryModel.getExpressions().size();i++)
         {
-            executerProperties.aggTypes[index++] = MolapCommonConstants.CUSTOM;
+            executerProperties.aggTypes[index] = MolapCommonConstants.CUSTOM;
+            executerProperties.dataTypes[index] = SqlStatement.Type.STRING;
+            index++;
         }
         
         
         for(int i = 0;i < queryModel.getMsrs().size();i++)
         {
-            executerProperties.aggTypes[index++] = queryModel.getMsrs().get(i).getAggName();
+            Measure measure = queryModel.getMsrs().get(i);
+            executerProperties.aggTypes[index] = measure.getAggName();
+            executerProperties.dataTypes[index] = measure.getDataType();
+            index++;
         }
         
         executerProperties.aggExpressionStartIndex = executerProperties.aggTypes.length
@@ -176,7 +175,13 @@ public abstract class AbstractQueryExecutor implements QueryExecutor
                 - queryModel.getMsrs().size();
         
 
-        executerProperties.msrMinValue = new double[executerProperties.aggTypes.length];
+        executerProperties.msrMinValue = new Object[executerProperties.aggTypes.length];
+
+        // force initialize object[]
+        for(int j = 0; j < executerProperties.aggTypes.length; j++)
+        {
+            executerProperties.msrMinValue[j] = 0.0;
+        }
 
 //        System.arraycopy(msrMinValue, 0, executerProperties.msrMinValue, executerProperties.measureStartIndex,
 //                queryModel.getMsrs().size());
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/ColumnarSliceExecuter.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/ColumnarSliceExecuter.java
index d0eb9f4..368168f 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/ColumnarSliceExecuter.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/ColumnarSliceExecuter.java
@@ -7,7 +7,6 @@ import com.huawei.iweb.platform.logging.LogServiceFactory;
 import com.huawei.iweb.platform.logging.impl.StandardLogService;
 import com.huawei.unibi.molap.datastorage.store.FileHolder;
 import com.huawei.unibi.molap.datastorage.store.impl.FileFactory;
-import com.huawei.unibi.molap.engine.cache.QueryExecutorUtil;
 import com.huawei.unibi.molap.engine.columnar.aggregator.ColumnarAggregatorInfo;
 import com.huawei.unibi.molap.engine.columnar.datastoreblockprocessor.ColumnarDataStoreBlockProcessorInfo;
 import com.huawei.unibi.molap.engine.columnar.datastoreblockprocessor.DataStoreBlockProcessor;
@@ -67,11 +66,7 @@ public class ColumnarSliceExecuter implements Callable<Void>
         columnarStorageScannerInfo.setScannedResultProcessor(scannedResultProcessor);
         columnarStorageScannerInfo.setRestructurHolder(info.getRestructureHolder());
         columnarStorageScannerInfo.setAutoAggregateTableRequest(info.isCustomMeasure());
-        //int [] queryDimOrdinalValue=QueryExecutorUtil.removeHighCardinalityDimOrdinal(info.getQueryDimOrdinal(),info.getQueryDimensions());
-        if(null != info.getColumnarSplitter())
-        {
-            columnarStorageScannerInfo.setKeySize(info.getColumnarSplitter().getKeySizeByBlock(info.getQueryDimOrdinal()));
-        }
+        columnarStorageScannerInfo.setKeySize(info.getColumnarSplitter().getKeySizeByBlock(info.getQueryDimOrdinal()));
         columnarStorageScannerInfo.setFileHolder(fileHolder);
         columnarStorageScannerInfo.setDimColumnCount(info.getTotalNumerOfDimColumns());
         columnarStorageScannerInfo.setMsrColumnCount(info.getTotalNumberOfMeasuresInTable());
@@ -107,7 +102,6 @@ public class ColumnarSliceExecuter implements Callable<Void>
         aggregatorInfo.setCubeUniqueName(sliceInfo.getSlice().getCubeUniqueName());
         aggregatorInfo.setMeasureOrdinal(sliceInfo.getMeasureOrdinal());
         aggregatorInfo.setAggType(sliceInfo.getAggType());
-        aggregatorInfo.setHighCardinalityType(sliceInfo.getHighCardinalityTypes());
         aggregatorInfo.setCustomExpressions(sliceInfo.getCustomExpressions());
         aggregatorInfo.setMsrMinValue(sliceInfo.getMsrMinValue());
         aggregatorInfo.setMeasureStartIndex(sliceInfo.getMeasureStartIndex());
@@ -125,9 +119,7 @@ public class ColumnarSliceExecuter implements Callable<Void>
         aggregatorInfo.setExpressionStartIndex(sliceInfo.getExpressionStartIndex());
         aggregatorInfo.setMsrDefaultValue(sliceInfo.getMsrDefaultValue());
         aggregatorInfo.setIsMeasureExistis(sliceInfo.getIsMeasureExistis());
-        aggregatorInfo.setQueryDimensionsLength(sliceInfo.getQueryDimensions().length);
-        aggregatorInfo.setComplexQueryDims(sliceInfo.getComplexQueryDimensions());
-        aggregatorInfo.setDimensions(sliceInfo.getDimensions());
+        aggregatorInfo.setDataTypes(sliceInfo.getDataTypes());
         return aggregatorInfo;
     }
 
@@ -136,11 +128,7 @@ public class ColumnarSliceExecuter implements Callable<Void>
         ColumnarDataStoreBlockProcessorInfo blockProcessorInfo = new ColumnarDataStoreBlockProcessorInfo();
         blockProcessorInfo.setDimensionIndexes(sliceInfo.getQueryDimOrdinal());
         blockProcessorInfo.setFileHolder(fileHolder);
-        //int [] queryDimOrdinalValue=QueryExecutorUtil.removeHighCardinalityDimOrdinal(sliceInfo.getQueryDimOrdinal(),sliceInfo.getQueryDimensions());
-        if(null != sliceInfo.getColumnarSplitter())
-        {
-            blockProcessorInfo.setKeySize(sliceInfo.getColumnarSplitter().getKeySizeByBlock(sliceInfo.getQueryDimOrdinal()));
-        }
+        blockProcessorInfo.setKeySize(sliceInfo.getColumnarSplitter().getKeySizeByBlock(sliceInfo.getQueryDimOrdinal()));
         blockProcessorInfo.setMeasureIndexes(sliceInfo.getMeasureOrdinal());
         blockProcessorInfo.setAutoGeneratedAggTableExecution(sliceInfo.isCustomMeasure());
         blockProcessorInfo.setTotalNumberOfMeasures(sliceInfo.getTotalNumberOfMeasuresInTable());
@@ -150,8 +138,6 @@ public class ColumnarSliceExecuter implements Callable<Void>
         return blockProcessorInfo;
     }
     
-
-
     private DataStoreBlockProcessor getDataStoreBlockProcessor(SliceExecutionInfo sliceInfo)
     {
         DataStoreBlockProcessor blockProcessor = null;
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/QueryExecuterProperties.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/QueryExecuterProperties.java
index 36e007a..b060973 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/QueryExecuterProperties.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/QueryExecuterProperties.java
@@ -1,13 +1,12 @@
 package com.huawei.unibi.molap.engine.executer.impl;
 
 import java.util.List;
-import java.util.Map;
 
-import com.huawei.unibi.molap.engine.complex.querytypes.GenericQueryType;
 import com.huawei.unibi.molap.engine.datastorage.InMemoryCube;
 import com.huawei.unibi.molap.keygenerator.KeyGenerator;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Measure;
+import com.huawei.unibi.molap.olap.SqlStatement;
 
 public class QueryExecuterProperties
 {
@@ -32,11 +31,6 @@ public class QueryExecuterProperties
     protected Dimension[] dimTables;
 
     /**
-     * dimension table array
-     */
-    protected Map<String,GenericQueryType> complexDimensionsMap;
-    
-    /**
      * list of active slices present for execution
      */
     protected List<InMemoryCube> slices;
@@ -49,7 +43,7 @@ public class QueryExecuterProperties
     /**
      * uniqueValue
      */
-    protected double[] uniqueValue;
+    protected Object[] uniqueValue;
     
     /**
      * mask bytes ranges
@@ -104,7 +98,7 @@ public class QueryExecuterProperties
     /**
      * msrMinValue
      */
-    protected double[] msrMinValue;
+    protected Object[] msrMinValue;
 
     /**
      * isFunctionQuery
@@ -131,7 +125,10 @@ public class QueryExecuterProperties
      * sortDimIndexex
      */
     protected byte[] sortDimIndexes;
-
-    protected boolean[] isHighCardinality;
+    
+    /**
+     * array of sql datatypes of mesaures and dimensions
+     */
+    protected SqlStatement.Type[] dataTypes;
     
 }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/QueryExecutorImpl.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/QueryExecutorImpl.java
index d5a6acb..e99f466 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/QueryExecutorImpl.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/QueryExecutorImpl.java
@@ -1,13 +1,10 @@
 package com.huawei.unibi.molap.engine.executer.impl;
 
 import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Collections;
-import java.util.Set;
 
 import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
@@ -16,7 +13,7 @@ import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.datastorage.store.filesystem.MolapFile;
 import com.huawei.unibi.molap.datastorage.store.impl.FileFactory;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
-import com.huawei.unibi.molap.engine.aggregator.dimension.DimensionAggregatorInfo;
+import com.huawei.unibi.molap.engine.aggregator.util.AggUtil;
 import com.huawei.unibi.molap.engine.cache.QueryExecutorUtil;
 import com.huawei.unibi.molap.engine.datastorage.InMemoryCube;
 import com.huawei.unibi.molap.engine.datastorage.Member;
@@ -78,8 +75,8 @@ public class QueryExecutorImpl extends AbstractQueryExecutor
         }
         // below method will be used to initialize all the properties required
         // for query execution
+        AggUtil.initMeasureType(queryModel);
         initQuery(queryModel);
-        
         // need to handle count(*)
         if(queryModel.isCountStarQuery() && null == queryModel.getFilterExpression() && queryModel.getDims().length < 1
                 && queryModel.getMsrs().size() < 2 && queryModel.getDimensionAggInfo().size() < 1 && queryModel.getExpressions().size()==0)
@@ -303,7 +300,6 @@ public class QueryExecutorImpl extends AbstractQueryExecutor
         Dimension[] sortDims=getSelectedQueryDimensions(queryModel.getSortedDimensions(),queryDimensions);
         holder.metaData = sliceMataData;
         holder.setKeyGenerator(slice.getKeyGenerator(queryModel.getFactTable()));
-        holder.setQueryDimsCount(queryDimensions.length);
         if(!executerProperties.globalKeyGenerator.equals(slice.getKeyGenerator(queryModel.getFactTable())))
         {
             holder.updateRequired = true;
@@ -311,10 +307,10 @@ public class QueryExecutorImpl extends AbstractQueryExecutor
         Measure[] measures = queryModel.getMsrs().toArray(new Measure[queryModel.getMsrs().size()]);
         int[] measureOrdinal = new int[measures.length];
         boolean[] msrExists = new boolean[measures.length];
-        double[] newMsrsDftVal = new double[measures.length];
+        Object[] newMsrsDftVal = new Object[measures.length];
         RestructureUtil.updateMeasureInfo(sliceMataData, measures, measureOrdinal, msrExists, newMsrsDftVal);
         
-        double[] sliceUniqueValues = null;
+        Object[] sliceUniqueValues = null;
         if(null!=slice.getDataCache(queryModel.getFactTable()))
         {
             sliceUniqueValues = slice.getDataCache(queryModel.getFactTable()).getUniqueValue();
@@ -322,9 +318,6 @@ public class QueryExecutorImpl extends AbstractQueryExecutor
         SliceExecutionInfo info = new SliceExecutionInfo();
         
         FilterEvaluatorInfo filterInfo = getFilterInfo(queryModel, currentSliceIndex,sliceMataData);
-        filterInfo.setComplexTypesWithBlockStartIndex(QueryExecutorUtility.getAllComplexTypesBlockStartIndex(executerProperties.complexDimensionsMap));
-        QueryExecutorUtility.getComplexDimensionsKeySize(executerProperties.complexDimensionsMap, executerProperties.slices.get(currentSliceIndex).getDimensionCardinality());
-        filterInfo.setDimensions(executerProperties.dimTables);
         if(null!=queryModel.getFilterExpression() && null!=slice.getDataCache(queryModel.getFactTable()))
         {
             info.setFilterEvaluatorTree(FilterUtil.getFilterEvaluator(queryModel.getFilterExpression(),
@@ -370,11 +363,8 @@ public class QueryExecutorImpl extends AbstractQueryExecutor
         info.setSortedDimensionsIndex(executerProperties.sortDimIndexes);
         info.setDimensionMaskKeys(QueryExecutorUtility.getMaksedKeyForSorting(sortDims,
                 executerProperties.globalKeyGenerator, maskedByteRangeForSorting, executerProperties.maskByteRanges));
-        if(slice.getDimensionCardinality().length > 0)
-        {
-            info.setColumnarSplitter(new MultiDimKeyVarLengthEquiSplitGenerator(MolapUtil
-                    .getIncrementedCardinalityFullyFilled(slice.getDimensionCardinality()), (byte)1));
-        }
+        info.setColumnarSplitter(new MultiDimKeyVarLengthEquiSplitGenerator(
+                MolapUtil.getIncrementedCardinalityFullyFilled(slice.getDimensionCardinality()), (byte)1));
         info.setLimit(queryModel.getLimit());
         info.setDetailQuery(queryModel.isDetailQuery());
         info.setTotalNumerOfDimColumns(queryModel.getCube().getDimensions(queryModel.getFactTable()).size());
@@ -422,72 +412,35 @@ public class QueryExecutorImpl extends AbstractQueryExecutor
             RestructureUtil.updateDimensionAggInfo(queryModel.getDimensionAggInfo(), sliceMataData.getDimensions());
         }
         info.setQueryDimOrdinal(QueryExecutorUtility.getSelectedDimnesionIndex(queryDimensions));
-        info.setComplexQueryDimensions(QueryExecutorUtility.getAllComplexTypesBlockStartIndex(executerProperties.complexDimensionsMap));
-        info.setDimensions(executerProperties.dimTables);
-        getApplicableDataBlocksForAggDims(queryModel.getDimensionAggInfo(), currentDimTables);
         info.setAllSelectedDimensions(QueryExecutorUtility.getAllSelectedDiemnsion(queryDimensions,
                 queryModel.getDimensionAggInfo(),executerProperties.aggExpDimensions));
         info.setCurrentSliceIndex(currentSliceIndex);
         info.setMsrMinValue(executerProperties.msrMinValue);
         info.setAggType(executerProperties.aggTypes);
-        info.setHighCardinalityType(executerProperties.isHighCardinality);
         info.setAllSelectedMeasures(QueryExecutorUtility.getAllSelectedMeasureOrdinals(measures,executerProperties.aggExpMeasures,sliceMataData.getMeasures()));
         info.setMeasureStartIndex(executerProperties.measureStartIndex);
         info.setExpressionStartIndex(executerProperties.aggExpressionStartIndex);
         info.setIsMeasureExistis(msrExists);
         info.setMsrDefaultValue(newMsrsDftVal);
-        
+        info.setDataTypes(executerProperties.dataTypes);
 //        updateDimensionAggregatorInfo(queryModel.getDimensionAggInfo(), slice.getDataCache(queryModel.getFactTable()));
         return info;
     }
     
-    
-    private void getApplicableDataBlocksForAggDims(List<DimensionAggregatorInfo> dimensionAggInfo, Dimension[] currentDimTables)
-    {
-        List<Dimension> selectedQueryDimensions = new ArrayList<Dimension>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
-        for(int i = 0;i < dimensionAggInfo.size();i++)
-        {
-            Dimension dim = dimensionAggInfo.get(i).getDim();
-            for(int j = 0;j < currentDimTables.length;j++)
-            {
-                if(dim.equals(currentDimTables[j]))
-                {
-                    dim.setDataBlockIndex(currentDimTables[j].getDataBlockIndex());
-                    dim.setAllApplicableDataBlockIndexs(currentDimTables[j].getAllApplicableDataBlockIndexs());
-                    selectedQueryDimensions.add(dim);
-                    break;
-                }
-            }
-        }
-    }
-        
     private Dimension[] getSelectedQueryDimensions(Dimension[] dims, Dimension[] currentDimTables)
     {
-//            Map<String, ArrayList<Dimension>> complexTypesMap = prepareComplexDimensions(currentDimTables);
         List<Dimension> selectedQueryDimensions = new ArrayList<Dimension>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
-        Set<String> dimensionGroup = new LinkedHashSet<String>();
         for(int i = 0;i < dims.length;i++)
         {
-            dimensionGroup.add(dims[i].getHierName());
             for(int j = 0;j < currentDimTables.length;j++)
             {
-                if(dims[i].getTableName().equals(currentDimTables[j].getTableName()) && dims[i].getDimName().equals(currentDimTables[j].getDimName()))
+                if(dims[i].equals(currentDimTables[j]))
                 {
-                    dims[i].setDataBlockIndex(currentDimTables[j].getDataBlockIndex());
-                    dims[i].setAllApplicableDataBlockIndexs(currentDimTables[j].getAllApplicableDataBlockIndexs());
                     selectedQueryDimensions.add(dims[i]);
                     break;
                 }
             }
         }
-//        for(String dimension : dimensionGroup)
-//        {
-//            for(Dimension d : complexTypesMap.get(dimension))
-//            {
-//                
-//                selectedQueryDimensions.add(d);
-//            }
-//        }
         return selectedQueryDimensions.toArray(new Dimension[selectedQueryDimensions.size()]);
     }
     
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/QueryResultPreparator.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/QueryResultPreparator.java
index 3a78691..df1fdfd 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/QueryResultPreparator.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/QueryResultPreparator.java
@@ -1,11 +1,9 @@
 package com.huawei.unibi.molap.engine.executer.impl;
 
-import java.nio.ByteBuffer;
+import java.math.BigDecimal;
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
 
 import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
@@ -15,7 +13,7 @@ import com.huawei.unibi.molap.engine.aggregator.dimension.DimensionAggregatorInf
 import com.huawei.unibi.molap.engine.aggregator.impl.CountAggregator;
 import com.huawei.unibi.molap.engine.aggregator.impl.DistinctCountAggregator;
 import com.huawei.unibi.molap.engine.aggregator.impl.DistinctStringCountAggregator;
-import com.huawei.unibi.molap.engine.complex.querytypes.GenericQueryType;
+import com.huawei.unibi.molap.engine.aggregator.util.AggUtil;
 import com.huawei.unibi.molap.engine.datastorage.Member;
 import com.huawei.unibi.molap.engine.executer.MolapQueryExecutorModel;
 import com.huawei.unibi.molap.engine.executer.pagination.impl.QueryResult;
@@ -74,23 +72,17 @@ public class QueryResultPreparator
         {
             return new ChunkResult();
         }
-        Dimension[] dims = queryModel.getDims();
-        int dimensionCount = dims.length;
+        int dimensionCount = queryModel.getDims().length;
         int size = dimensionCount + executerProperties.aggTypes.length;
         updatedWithCurrentUnique(result,queryModel.getMsrs());
         Object[][] resultData = new Object[result.size()][size];
         QueryResultIterator iterator = result.iterator();
         long[] keyArray = null;
         int currentRow = 0;
-        Map<Integer,Integer> ordinalAndResultIndexMap=getHighCardinalityIndexInResult(dims);
-        
         if(!executerProperties.isFunctionQuery && dimensionCount==0 && size==0 && result.size()>0)
         {
             return getEmptyChunkResult(result.size());
         }
-        queryModel.setComplexDimensionsMap(QueryExecutorUtility.getComplexDimensionsMap(executerProperties.dimTables));
-        QueryExecutorUtility.getComplexDimensionsKeySize(queryModel.getComplexDimensionsMap(), executerProperties.slices.get(currentSliceIndex).getDimensionCardinality());
-        Map<String, Integer> complexQueryIndexes = QueryExecutorUtility.getComplexQueryIndexes(queryModel.getDims(), executerProperties.dimTables);
         while(iterator.hasNext())
         {
             ByteArrayWrapper keyWrapper = iterator.getKey();
@@ -98,29 +90,9 @@ public class QueryResultPreparator
                     executerProperties.maskedBytes);
             
             //CHECKSTYLE:OFF Approval No:Approval-V1R2C10_006
-            int index = 0;
             for(int i = 0;i < dimensionCount;i++)
             {
-                if(dims[i].isHighCardinalityDim() && null != keyWrapper.getDirectSurrogateKeyList())
-                {
-                    resultData[currentRow][i] =  keyWrapper.getDirectSurrogateKeyList().get(ordinalAndResultIndexMap.get(dims[i].getOrdinal()));
-                }
-                else
-                {
-                    if(dims[i].isHighCardinalityDim())
-                    {
-                        continue;
-                    }
-                    GenericQueryType complexType = queryModel.getComplexDimensionsMap().get(queryModel.getDims()[i].getColName());
-	                if(complexType == null)
-	                {
-	                    resultData[currentRow][i] = (int)keyArray[queryModel.getDims()[i].getOrdinal()];
-	                }
-	                else
-	                {
-	                    resultData[currentRow][i] = keyWrapper.getComplexTypeData(complexQueryIndexes.get(queryModel.getDims()[i].getColName()));
-	                }
-                }
+                resultData[currentRow][i] = (int)keyArray[queryModel.getDims()[i].getOrdinal()];
             }
             //CHECKSTYLE:ON
             
@@ -128,8 +100,21 @@ public class QueryResultPreparator
             
             if(executerProperties.isFunctionQuery)
             {
-                Double sizeOfList= d[0].getValue();
-                return getEmptyChunkResult(sizeOfList.intValue());
+                switch(AggUtil.getMeasureType(AggUtil.measureOrdinal[0]))
+                {
+                    case BIGINT:
+
+                        Long sizeOfListL= d[0].getLongValue();
+                        return getEmptyChunkResult(sizeOfListL.intValue());
+                    case DECIMAL:
+
+                        BigDecimal sizeOfListD= d[0].getBigDecimalValue();
+                        return getEmptyChunkResult(sizeOfListD.intValue());
+                    default:
+
+                        Double sizeOfList= d[0].getDoubleValue();
+                        return getEmptyChunkResult(sizeOfList.intValue());
+                }
             }
             
             //CHECKSTYLE:OFF Approval No:Approval-V1R2C10_001
@@ -148,27 +133,6 @@ public class QueryResultPreparator
         return getResult(queryModel,resultData);
     }
 
-    private Map<Integer,Integer> getHighCardinalityIndexInResult(Dimension[] dims)
-    {
-        Map<Integer,Integer> ordinalAndResultIndexMap = new HashMap<>();
-        Dimension[] dimTables = executerProperties.dimTables;
-        int index=0;
-        for(int i = 0;i < dimTables.length;i++)
-        {
-            if(dimTables[i].isHighCardinalityDim())
-            {
-                for(int j = 0;j < dims.length;j++)
-                {
-                    if(dims[j].equals(dimTables[i]))
-                    {
-                        ordinalAndResultIndexMap.put(dims[j].getOrdinal(),index++);
-                    }
-                }
-            }
-        }
-        return ordinalAndResultIndexMap;
-    }
-    
     private ChunkResult getEmptyChunkResult(int size)
     {
         List<MolapKey> keys = new ArrayList<MolapKey>(size);
@@ -222,43 +186,21 @@ public class QueryResultPreparator
             row = new Object[recordSize];
             for(int i = 0;i < dimensionCount;i++)
             {
-                boolean isComplexType = false;
-                Object complexData = null;
-                GenericQueryType complexType = queryModel.getComplexDimensionsMap().get(queryModel.getDims()[i].getColName());
-                if(surrogateResult[i][columnIndex] instanceof byte[] && complexType == null)
-                {
-                    member = new Member((byte[])surrogateResult[i][columnIndex]);
-                }
-                else if(executerProperties.sortDimIndexes[i]==1)
+                if(executerProperties.sortDimIndexes[i]==1)
                 {
                     member = QueryExecutorUtility.getActualMemberBySortedKey(queryModel.getDims()[i],(Integer)surrogateResult[i][columnIndex], executerProperties.slices);
                 }
                 else
                 {
-                    if(complexType == null)
-                    {
-                        member = QueryExecutorUtility.getMemberBySurrogateKey(queryModel.getDims()[i],(Integer)surrogateResult[i][columnIndex], executerProperties.slices);
-                    }
-                    else
-                    {
-                        
-                        isComplexType = true;
-                        complexData = complexType.getDataBasedOnDataTypeFromSurrogates(executerProperties.slices, 
-                                ByteBuffer.wrap((byte[])surrogateResult[i][columnIndex]), executerProperties.dimTables);
-                    }
+                    member = QueryExecutorUtility.getMemberBySurrogateKey(queryModel.getDims()[i],(Integer)surrogateResult[i][columnIndex], executerProperties.slices);
                 }
 
-                if(!isComplexType)
-                {
                     memString = member.toString();
                     row[queryModel.getDims()[i].getQueryOrder()] = DataTypeConverter.getDataBasedOnDataType(
                             memString.equals(MolapCommonConstants.MEMBER_DEFAULT_VAL) ? null : memString,
                             queryModel.getDims()[i].getDataType());
-                }
-                else
-                {
-                    row[queryModel.getDims()[i].getQueryOrder()] = complexData;
-                }
+                
+
             }
             MeasureAggregator[] msrAgg = new MeasureAggregator[executerProperties.aggTypes.length];
             fillMeasureValueForAggGroupByQuery(queryModel, surrogateResult, dimensionCount, columnIndex,msrAgg);
@@ -307,7 +249,23 @@ public class QueryResultPreparator
                     }
                     else
                     {
-                        row[queryModel.getMsrs().get(i).getQueryOrder()] = msrAgg[executerProperties.measureStartIndex+i].getValue();
+//                        row[queryModel.getMsrs().get(i).getQueryOrder()] = msrAgg[executerProperties.measureStartIndex+i].getValue();
+                        Object msrVal;
+                        switch(AggUtil.getMeasureType(AggUtil.measureOrdinal[i]))
+                        {
+                            case BIGINT:
+                                msrVal = msrAgg[executerProperties.measureStartIndex+i].getLongValue();
+                                break;
+                            case DECIMAL:
+                                msrVal = msrAgg[executerProperties.measureStartIndex+i].getBigDecimalValue();
+                                break;
+                            default:
+                                msrVal = msrAgg[executerProperties.measureStartIndex+i].getDoubleValue();
+                        }
+                        row[queryModel.getMsrs().get(i).getQueryOrder()] =
+                                DataTypeConverter.getMeasureDataBasedOnDataType(
+                                        msrVal.equals(MolapCommonConstants.MEMBER_DEFAULT_VAL) ? null : msrVal,
+                                        queryModel.getMsrs().get(i).getDataType());     // mod by ggin
                     }
                 }
                 int index=0;
@@ -316,7 +274,17 @@ public class QueryResultPreparator
                     DimensionAggregatorInfo dimensionAggregatorInfo = queryModel.getDimensionAggInfo().get(i);
                     for(int j = 0;j < dimensionAggregatorInfo.getOrderList().size();j++)
                     {
-                        row[dimensionAggregatorInfo.getOrderList().get(j)] = msrAgg[index++].getValue();
+                        switch (queryModel.getDims()[i].getDataType())
+                        {
+                            case BIGINT:
+                                row[dimensionAggregatorInfo.getOrderList().get(j)] = msrAgg[index++].getLongValue();
+                                break;
+                            case DECIMAL:
+                                row[dimensionAggregatorInfo.getOrderList().get(j)] = msrAgg[index++].getBigDecimalValue();
+                                break;
+                            default:
+                                row[dimensionAggregatorInfo.getOrderList().get(j)] = msrAgg[index++].getDoubleValue();
+                        }
                     }
                 }
             }
@@ -382,17 +350,13 @@ public class QueryResultPreparator
                         && partitionColumns.contains(dimensionAggregatorInfo.getColumnName())
                         && dimensionAggregatorInfo.getAggList().get(j).equals(MolapCommonConstants.DISTINCT_COUNT))
                 {
-                    double value = ((MeasureAggregator)surrogateResult[dimensionCount + rowIndex][columnIndex])
-                            .getValue();
+                    double value = ((DistinctCountAggregator)surrogateResult[dimensionCount + rowIndex][columnIndex]).getDoubleValue();
                     MeasureAggregator countAggregator = new CountAggregator();
                     countAggregator.setNewValue(value);
                     v[index++] = countAggregator;
                 }
                 else
                 {
-                    if(surrogateResult[dimensionCount + rowIndex][columnIndex] instanceof DistinctCountAggregator)
-                    {
-                    
                     Iterator<Integer> iterator = ((DistinctCountAggregator)surrogateResult[dimensionCount + rowIndex][columnIndex])
                             .getBitMap().iterator();
                     if(null != mappedDim)
@@ -400,8 +364,7 @@ public class QueryResultPreparator
                         MeasureAggregator distinctCountAggregator = new DistinctCountAggregator(0);
                         while(iterator.hasNext())
                         {
-                            distinctCountAggregator.agg(getGlobalSurrogates(mappedDim, iterator.next()),
-                                    null, 0, 0);
+                            distinctCountAggregator.agg(getGlobalSurrogates(mappedDim, iterator.next()));
                         }
                         v[index++] = distinctCountAggregator;
                         currentSliceIndex=0;
@@ -416,19 +379,12 @@ public class QueryResultPreparator
                                     executerProperties.slices).toString();
                              if(!member.equals(MolapCommonConstants.MEMBER_DEFAULT_VAL))
                              {
-                                distinctCountAggregatorObjct.agg(member, null, 0, 0);
+                                distinctCountAggregatorObjct.agg(member);
                              }
                         }
                         v[index++] = distinctCountAggregatorObjct;
                     }
                 }
-                
-                else
-                {
-                    v[index++] = ((MeasureAggregator)surrogateResult[dimensionCount
-                                                                     + rowIndex][columnIndex]);
-                }
-                }
             }
         }
     }
@@ -484,14 +440,14 @@ public class QueryResultPreparator
                                         (Integer)iterator.next(), executerProperties.slices).toString();
                                 if(!member.equals(MolapCommonConstants.MEMBER_DEFAULT_VAL))
                                 {
-                                    distinctCountAggregatorObjct.agg(member, null, 0, 0);
+                                    distinctCountAggregatorObjct.agg(member);
                                 }
                             }
                             v[executerProperties.measureStartIndex + i] = distinctCountAggregatorObjct;
                         }
                         else
                         {
-                            double value = ((DistinctCountAggregator)surrogateResult[dimensionCount + rowIndex][columnIndex]).getValue();
+                            double value = ((DistinctCountAggregator)surrogateResult[dimensionCount + rowIndex][columnIndex]).getDoubleValue();
                             MeasureAggregator countAggregator = new CountAggregator();
                             countAggregator.setNewValue(value);
                             v[executerProperties.measureStartIndex + i] = countAggregator;
@@ -507,8 +463,7 @@ public class QueryResultPreparator
 
                         while(iterator.hasNext())
                         {
-                            distinctCountAggregator.agg(getGlobalSurrogates(mappedDim, iterator.next() - minValue),
-                                    null, 0, 0);
+                            distinctCountAggregator.agg(getGlobalSurrogates(mappedDim, iterator.next() - minValue));
                         }
                         v[executerProperties.measureStartIndex + i] = distinctCountAggregator;
                         currentSliceIndex = 0;
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/RestructureHolder.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/RestructureHolder.java
index cefddc4..7f4e77f 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/RestructureHolder.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/RestructureHolder.java
@@ -41,21 +41,6 @@ public class RestructureHolder
     public int[] maskedByteRanges;
     
     /**
-     * maskedByteRanges
-     */
-    private int queryDimsCount;
-    
-    public int getQueryDimsCount()
-    {
-        return queryDimsCount;
-    }
-
-    public void setQueryDimsCount(int queryDimsCount)
-    {
-        this.queryDimsCount = queryDimsCount;
-    }
-
-    /**
      * holder keyGenerator;
      */
     private KeyGenerator keyGenerator;
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/RestructureUtil.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/RestructureUtil.java
index 70ca21d..c88f357 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/RestructureUtil.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/RestructureUtil.java
@@ -1,10 +1,8 @@
 package com.huawei.unibi.molap.engine.executer.impl;
 
-import java.util.ArrayList;
 import java.util.Iterator;
-import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Set;
+import java.util.ArrayList;
 
 import com.huawei.unibi.molap.engine.aggregator.dimension.DimensionAggregatorInfo;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
@@ -34,21 +32,10 @@ public final class RestructureUtil
         boolean found/* = false*/;
         int len = 0;
         String[] sMetaDims = sliceMataData.getDimensions();
-//        Set<String> queryDimGroup = new LinkedHashSet<String>();
-//        for(Dimension dim : queryDims)
-//        {
-//            queryDimGroup.add(dim.getHierName());
-//        }
 //        Dimension[] currentDimTables = new Dimension[sMetaDims.length];
         List<Dimension> crntDims= new ArrayList<Dimension>();
         for(int i = 0;i < executerProperties.dimTables.length;i++)
         {
-            if(executerProperties.dimTables[i].isHighCardinalityDim())
-            {
-                crntDims.add(executerProperties.dimTables[i]);
-                continue;
-            }
-            
             found = false;
             for(int j = 0;j < sMetaDims.length;j++)
             {
@@ -73,11 +60,6 @@ public final class RestructureUtil
         len = 0;
         for(int i = 0;i < queryDims.length;i++)
         {
-            if(queryDims[i].isHighCardinalityDim())
-            {
-                currentDimList.add(queryDims[i]);
-                continue;
-            }
             for(int j = 0;j < sMetaDims.length;j++)
             {
                 if(sMetaDims[j].equals(queryDims[i].getActualTableName() + '_' + queryDims[i].getColName()))
@@ -93,7 +75,7 @@ public final class RestructureUtil
     }
     
     public static void updateMeasureInfo(SliceMetaData sliceMataData, Measure[] measures, int[] measureOrdinal,
-            boolean[] msrExists, double[] newMsrsDftVal)
+            boolean[] msrExists, Object[] newMsrsDftVal)
     {
         String[] sMetaMsrs = sliceMataData.getMeasures();
         updateMsr(sliceMataData, measures, measureOrdinal, msrExists, newMsrsDftVal, sMetaMsrs);
@@ -108,7 +90,7 @@ public final class RestructureUtil
      * @param sMetaMsrs
      */
     public static void updateMsr(SliceMetaData sliceMataData, Measure[] measures, int[] measureOrdinal,
-            boolean[] msrExists, double[] newMsrsDftVal, String[] sMetaMsrs)
+            boolean[] msrExists, Object[] newMsrsDftVal, String[] sMetaMsrs)
     {
         for(int i = 0;i < measures.length;i++)
         {
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/comparator/MaksedByteComparatorBAW.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/comparator/MaksedByteComparatorBAW.java
index 45031cf..817f069 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/comparator/MaksedByteComparatorBAW.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/comparator/MaksedByteComparatorBAW.java
@@ -17,10 +17,8 @@ W20tYoR6LAutUU7D+aAzbIfkaLUlyYFdUciKZ6SlowK7Xje8wpoLeloKH/xwvA==*/
 package com.huawei.unibi.molap.engine.executer.impl.comparator;
 
 import java.util.Comparator;
-import java.util.List;
 
 import com.huawei.unibi.molap.engine.executer.pagination.impl.DataFileWriter.KeyValueHolder;
-import com.huawei.unibi.molap.util.ByteUtil.UnsafeComparer;
 
 /**
  * Project Name NSE V3R7C00 
@@ -57,11 +55,6 @@ public class MaksedByteComparatorBAW implements Comparator<KeyValueHolder>
         this.maskedKey=maskedKey;
     }
 
-    public MaksedByteComparatorBAW(byte sortOrder)
-    {
-        this.sortOrder=sortOrder;
-    }
-
     /**
      * This method will be used to compare two byte array
      * @param o1
@@ -70,11 +63,9 @@ public class MaksedByteComparatorBAW implements Comparator<KeyValueHolder>
     @Override
     public int compare(KeyValueHolder byteArrayWrapper1, KeyValueHolder byteArrayWrapper2)
     {
-        int cmp = 0;
+        int cmp=0;
         byte[] o1 = byteArrayWrapper1.key.getMaskedKey();
         byte[] o2 = byteArrayWrapper2.key.getMaskedKey();
-        if(null!=index)
-        {
         for(int i = 0;i < index.length;i++)
         {
             int a = (o1[index[i]] & this.maskedKey[i]) & 0xff;
@@ -82,36 +73,15 @@ public class MaksedByteComparatorBAW implements Comparator<KeyValueHolder>
             cmp = a - b;
             if(cmp != 0)
             {
-
-                if(sortOrder == 1)
+                
+                if(sortOrder==1)
                 {
-                   return  cmp=cmp * -1;
+                    return cmp*-1;
                 }
+                return cmp;
             }
         }
-       }
-        List<byte[]> listOfDirectSurrogateVal1= byteArrayWrapper1.key.getDirectSurrogateKeyList();
-        List<byte[]> listOfDirectSurrogateVal2= byteArrayWrapper2.key.getDirectSurrogateKeyList();
-        if(cmp == 0)
-        {
-            if(null != listOfDirectSurrogateVal1 && null!=listOfDirectSurrogateVal2)
-            {
-                for(int i = 0;i < listOfDirectSurrogateVal1.size();i++)
-                {
-                    cmp = UnsafeComparer.INSTANCE.compareTo(listOfDirectSurrogateVal1.get(i),
-                            listOfDirectSurrogateVal2.get(i));
-                    if(cmp != 0)
-                    {
 
-                        if(sortOrder == 1)
-                        {
-                            cmp=cmp * -1;
-                        }
-                        return cmp;
-                    }
-                }
-            }
-        }
         return cmp;
     }
 }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/comparator/MeasureComparatorDFCH.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/comparator/MeasureComparatorDFCH.java
index 6a83bf6..c2e4eda 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/comparator/MeasureComparatorDFCH.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/comparator/MeasureComparatorDFCH.java
@@ -7,8 +7,10 @@ Jurlz4VtUD7sWctPbFkwnsbzswGZmN/xcLJSb3oUb2HiuiCUJvrzaAzAD8LuEg==*/
 /*--------------------------------------------------------------------------------------------------------------------------*/
 package com.huawei.unibi.molap.engine.executer.impl.comparator;
 
+import java.math.BigDecimal;
 import java.util.Comparator;
 
+import com.huawei.unibi.molap.engine.aggregator.util.AggUtil;
 import com.huawei.unibi.molap.engine.executer.pagination.impl.DataFileChunkHolder;
 
 public class MeasureComparatorDFCH implements Comparator<DataFileChunkHolder>
@@ -43,18 +45,41 @@ public class MeasureComparatorDFCH implements Comparator<DataFileChunkHolder>
     public int compare(DataFileChunkHolder t1, DataFileChunkHolder t2)
     {
         int cmp=0;
-        
-        double msrValue1 = t1.getMeasures()[this.msrIndex].getValue();
-        double msrValue2 = t2.getMeasures()[this.msrIndex].getValue();
-        
-        if(msrValue1<msrValue2)
-        {
-            cmp=-1;
-        }
-        else if(msrValue1>msrValue2)
+
+        switch(AggUtil.getMeasureType(this.msrIndex))
         {
-            cmp=1;
+            case BIGINT:
+                long msrValue1L = t1.getMeasures()[this.msrIndex].getLongValue();
+                long msrValue2L = t2.getMeasures()[this.msrIndex].getLongValue();
+                if(msrValue1L < msrValue2L)
+                {
+                    cmp=-1;
+                }
+                else if(msrValue1L > msrValue2L)
+                {
+                    cmp=1;
+                }
+
+                break;
+            case DECIMAL:
+                double msrValue1D = t1.getMeasures()[this.msrIndex].getDoubleValue();
+                double msrValue2D = t2.getMeasures()[this.msrIndex].getDoubleValue();
+                if(msrValue1D < msrValue2D)
+                {
+                    cmp=-1;
+                }
+                else if(msrValue1D > msrValue2D)
+                {
+                    cmp=1;
+                }
+
+                break;
+            default:
+                BigDecimal msrValue1B = t1.getMeasures()[this.msrIndex].getBigDecimalValue();
+                BigDecimal msrValue2B = t2.getMeasures()[this.msrIndex].getBigDecimalValue();
+                cmp =  msrValue1B.compareTo(msrValue2B);
         }
+
         if(this.sortOrder==1 || this.sortOrder==3)
         {
             cmp*=-1;
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/comparator/MeasureComparatorTuple.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/comparator/MeasureComparatorTuple.java
index b8e6e1f..ea7d2e7 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/comparator/MeasureComparatorTuple.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/impl/comparator/MeasureComparatorTuple.java
@@ -16,8 +16,10 @@ QPIDsgIfXoTpQC1ec/n9SIx+/dGjE0K45fsiFgjrCTgKFOaApf5n+TMcvasEJw==*/
 */
 package com.huawei.unibi.molap.engine.executer.impl.comparator;
 
+import java.math.BigDecimal;
 import java.util.Comparator;
 
+import com.huawei.unibi.molap.engine.aggregator.util.AggUtil;
 import com.huawei.unibi.molap.engine.executer.Tuple;
 
 /**
@@ -65,17 +67,40 @@ public class MeasureComparatorTuple implements Comparator<Tuple>
         {
             return cmp;
         }
-        double msrValue1 = t1.getMeasures()[this.msrIndex].getValue();
-        double msrValue2 = t2.getMeasures()[this.msrIndex].getValue();
-        
-        if(msrValue1<msrValue2)
+        switch(AggUtil.getMeasureType(this.msrIndex))
         {
-            cmp=-1;
-        }
-        else if(msrValue1>msrValue2)
-        {
-            cmp=1;
+            case BIGINT:
+                long msrValue1L = t1.getMeasures()[this.msrIndex].getLongValue();
+                long msrValue2L = t2.getMeasures()[this.msrIndex].getLongValue();
+                if(msrValue1L < msrValue2L)
+                {
+                    cmp=-1;
+                }
+                else if(msrValue1L > msrValue2L)
+                {
+                    cmp=1;
+                }
+
+                break;
+            case DECIMAL:
+                double msrValue1D = t1.getMeasures()[this.msrIndex].getDoubleValue();
+                double msrValue2D = t2.getMeasures()[this.msrIndex].getDoubleValue();
+                if(msrValue1D < msrValue2D)
+                {
+                    cmp=-1;
+                }
+                else if(msrValue1D > msrValue2D)
+                {
+                    cmp=1;
+                }
+
+                break;
+            default:
+                BigDecimal msrValue1B = t1.getMeasures()[this.msrIndex].getBigDecimalValue();
+                BigDecimal msrValue2B = t2.getMeasures()[this.msrIndex].getBigDecimalValue();
+                cmp =  msrValue1B.compareTo(msrValue2B);
         }
+
         if(this.sortOrder==1 || this.sortOrder==3)
         {
             cmp*=-1;
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/pagination/impl/LocalDataAggregatorForAutoAggregateImpl.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/pagination/impl/LocalDataAggregatorForAutoAggregateImpl.java
index 2069681..37845ee 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/pagination/impl/LocalDataAggregatorForAutoAggregateImpl.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/pagination/impl/LocalDataAggregatorForAutoAggregateImpl.java
@@ -79,22 +79,20 @@ public class LocalDataAggregatorForAutoAggregateImpl extends LocalDataAggregator
             aggregateMsrsForAggTable(available, currentMsrRowData);
             return;
         }
-        double doubleValue/* = 0.0*/;
+        Object msrValue/* = 0.0*/;
         for(int i = 0;i < otherMsrIndexes.length;i++)
         {
-            doubleValue = available.getValue(measureOrdinal[otherMsrIndexes[i]]);
-            if(uniqueValues[measureOrdinal[otherMsrIndexes[i]]] != doubleValue)
+            msrValue = available.getValue(measureOrdinal[otherMsrIndexes[i]]);
+            if(!uniqueValues[measureOrdinal[otherMsrIndexes[i]]].equals(msrValue))
             {
-                currentMsrRowData[otherMsrIndexes[i]].agg(doubleValue, available.backKeyArray,
-                    available.keyOffset, available.keyLength);
+                currentMsrRowData[otherMsrIndexes[i]].agg(msrValue);
             }
         }
         byte[] byteValue= null;
         for(int i = 0;i < customMeasureIndex.length;i++)
         {
             byteValue = available.getByteArrayValue(measureOrdinal[customMeasureIndex[i]]);
-            currentMsrRowData[customMeasureIndex[i]].agg(byteValue, available.backKeyArray, available.keyOffset,
-                    available.keyLength);
+            currentMsrRowData[customMeasureIndex[i]].agg(byteValue);
         }
     }
     
@@ -134,32 +132,32 @@ public class LocalDataAggregatorForAutoAggregateImpl extends LocalDataAggregator
      */
     protected void aggregateMsrsForAggTable(KeyValue available, MeasureAggregator[] currentMsrRowData)
     {
-        double countValue = available.getValue(measureOrdinal[countMsrIndex]);
-        double avgValue/*= 0.0*/;
+        Object countValue = available.getValue(measureOrdinal[countMsrIndex]);
+        Object avgValue/*= 0.0*/;
         for(int i = 0;i < avgMsrIndexes.length;i++)
         {
             avgValue = available.getValue(measureOrdinal[avgMsrIndexes[i]]);
             if(uniqueValues[measureOrdinal[avgMsrIndexes[i]]] != avgValue)
             {
-                currentMsrRowData[avgMsrIndexes[i]].agg(avgValue,countValue);
+//                currentMsrRowData[avgMsrIndexes[i]].agg(avgValue,countValue);
+//   make changes to support agg(MolapReadDataHolder newVal,int index)
+                currentMsrRowData[avgMsrIndexes[i]].agg(available.getMsrData(measureOrdinal[avgMsrIndexes[i]]),available.getRow());
             }
         }
-        double otherValue/*= 0.0*/;
+        Object otherValue/*= 0.0*/;
         for(int i = 0;i < otherMsrIndexes.length;i++)
         {
             otherValue = available.getValue(measureOrdinal[otherMsrIndexes[i]]);
             if(uniqueValues[measureOrdinal[otherMsrIndexes[i]]] != otherValue)
             {
-                currentMsrRowData[otherMsrIndexes[i]].agg(otherValue, available.backKeyArray,
-                    available.keyOffset, available.keyLength);
+                currentMsrRowData[otherMsrIndexes[i]].agg(otherValue);
             }
         }
         byte[] byteValue = null;
         for(int i = 0;i < customMeasureIndex.length;i++)
         {
             byteValue = available.getByteArrayValue(measureOrdinal[customMeasureIndex[i]]);
-            currentMsrRowData[customMeasureIndex[i]].agg(byteValue, available.backKeyArray, available.keyOffset,
-                    available.keyLength);
+            currentMsrRowData[customMeasureIndex[i]].agg(byteValue);
         }
     }
 }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/pagination/impl/LocalDataAggregatorImpl.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/pagination/impl/LocalDataAggregatorImpl.java
index 8411834..ede23c6 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/pagination/impl/LocalDataAggregatorImpl.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/pagination/impl/LocalDataAggregatorImpl.java
@@ -88,7 +88,7 @@ public class LocalDataAggregatorImpl implements DataAggregator
     /**
      * Unique values represents null values of measure.
      */
-    protected double[] uniqueValues;
+    protected Object[] uniqueValues;
     
     
     protected ByteArrayWrapper dimensionsRowWrapper = new ByteArrayWrapper();
@@ -119,7 +119,7 @@ public class LocalDataAggregatorImpl implements DataAggregator
     /**
      * msrDft
      */
-    protected double[] msrDft;
+    protected Object[] msrDft;
     
     /**
      * LOGGER.
@@ -289,11 +289,10 @@ public class LocalDataAggregatorImpl implements DataAggregator
         }
         for(int i = 0;i < queryMsrs.length;i++)
         {
-            double value = available.getValue(measureOrdinal[i]);
-            if(uniqueValues[measureOrdinal[i]] != value)
+            Object value = available.getValue(measureOrdinal[i]);
+            if(!uniqueValues[measureOrdinal[i]].equals(value))
             {
-                currentMsrRowData[i].agg(value, available.backKeyArray,
-                    available.keyOffset, available.keyLength);
+                currentMsrRowData[i].agg(value);
             }
         }
     }
@@ -319,24 +318,25 @@ public class LocalDataAggregatorImpl implements DataAggregator
      */
     protected void aggregateMsrsForAggTable(KeyValue available, MeasureAggregator[] currentMsrRowData)
     {
-        double countValue = available.getValue(measureOrdinal[countMsrIndex]);
+        Object countValue = available.getValue(measureOrdinal[countMsrIndex]);
         
         for(int i = 0;i < avgMsrIndexes.length;i++)
         {
-            double value = available.getValue(measureOrdinal[avgMsrIndexes[i]]);
-            if(uniqueValues[measureOrdinal[avgMsrIndexes[i]]] != value)
+            Object value = available.getValue(measureOrdinal[avgMsrIndexes[i]]);
+            if(!uniqueValues[measureOrdinal[avgMsrIndexes[i]]].equals(value))
             {
-                currentMsrRowData[avgMsrIndexes[i]].agg(value,countValue);
+//                currentMsrRowData[avgMsrIndexes[i]].agg(value,countValue);
+// make changes to support agg(MolapReadDataHolder newVal,int index)
+                currentMsrRowData[avgMsrIndexes[i]].agg(available.getMsrData(measureOrdinal[avgMsrIndexes[i]]),available.getRow());
             }
         }
         
         for(int i = 0;i < otherMsrIndexes.length;i++)
         {
-            double value = available.getValue(measureOrdinal[otherMsrIndexes[i]]);
-            if(uniqueValues[measureOrdinal[otherMsrIndexes[i]]] != value)
+            Object value = available.getValue(measureOrdinal[otherMsrIndexes[i]]);
+            if(!uniqueValues[measureOrdinal[otherMsrIndexes[i]]].equals(value))
             {
-                currentMsrRowData[otherMsrIndexes[i]].agg(value, available.backKeyArray,
-                    available.keyOffset, available.keyLength);
+                currentMsrRowData[otherMsrIndexes[i]].agg(value);
             }
         }
     }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/pagination/impl/LocalDataAggregatorRSImpl.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/pagination/impl/LocalDataAggregatorRSImpl.java
index e4b5086..92cf049 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/pagination/impl/LocalDataAggregatorRSImpl.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/pagination/impl/LocalDataAggregatorRSImpl.java
@@ -107,16 +107,14 @@ public class LocalDataAggregatorRSImpl extends LocalDataAggregatorImpl
         }
         for(int i = 0;i < queryMsrs.length;i++)
         {
-            double value = msrExists[i] ? available.getValue(measureOrdinal[i]) : msrDft[i];
-            if(msrExists[i] && uniqueValues[measureOrdinal[i]] != value)
+            Object value = msrExists[i] ? available.getValue(measureOrdinal[i]) : msrDft[i];
+            if(msrExists[i] && !uniqueValues[measureOrdinal[i]].equals(value))
             {
-                currentMsrRowData[i].agg(value, available.getBackKeyArray(), available.getKeyOffset(),
-                        available.getKeyLength());
+                currentMsrRowData[i].agg(value);
             }
             else if(!msrExists[i])
             {
-                currentMsrRowData[i].agg(value, available.getBackKeyArray(), available.getKeyOffset(),
-                        available.getKeyLength());
+                currentMsrRowData[i].agg(value);
             }
         }
     }
@@ -128,35 +126,36 @@ public class LocalDataAggregatorRSImpl extends LocalDataAggregatorImpl
      */
     protected void aggregateMsrsForAggTable(KeyValue available, MeasureAggregator[] currentMsrRowData)
     {
-        double countValue = available.getValue(measureOrdinal[countMsrIndex]);
+        Object countValue = available.getValue(measureOrdinal[countMsrIndex]);
         
         for(int i = 0;i < avgMsrIndexes.length;i++)
         {
             int index = avgMsrIndexes[i];
-            double value = msrExists[i] ? available.getValue(measureOrdinal[index]) : msrDft[index];
-            if(msrExists[index] && uniqueValues[measureOrdinal[index]] != value)
+            Object value = msrExists[i] ? available.getValue(measureOrdinal[index]) : msrDft[index];
+            if(msrExists[index] && !uniqueValues[measureOrdinal[index]].equals(value))
             {
-                currentMsrRowData[index].agg(value, countValue);
+//                currentMsrRowData[index].agg(value, countValue);
+// make changes to support agg(MolapReadDataHolder newVal,int index)
+                currentMsrRowData[index].agg(available.getMsrData(measureOrdinal[index]), available.getRow());
             }
+
             else if(!msrExists[index])
             {
-                currentMsrRowData[index].agg(value, countValue);
+                currentMsrRowData[index].agg(available.getMsrData(measureOrdinal[index]), available.getRow());
             }
         }
         
         for(int i = 0;i < otherMsrIndexes.length;i++)
         {
             int index = otherMsrIndexes[i];
-            double value = msrExists[i] ? available.getValue(measureOrdinal[index]) : msrDft[index];
-            if(msrExists[index] && uniqueValues[measureOrdinal[index]] != value)
+            Object value = msrExists[i] ? available.getValue(measureOrdinal[index]) : msrDft[index];
+            if(msrExists[index] && !uniqueValues[measureOrdinal[index]].equals(value))
             {
-                currentMsrRowData[index].agg(value, available.getBackKeyArray(), available.getKeyOffset(),
-                        available.getKeyLength());
+                currentMsrRowData[index].agg(value);
             }
             else if(!msrExists[index])
             {
-                currentMsrRowData[index].agg(value, available.getBackKeyArray(), available.getKeyOffset(),
-                        available.getKeyLength());
+                currentMsrRowData[index].agg(value);
             }
         }
     }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/pagination/impl/LocalDataAggregatorWithCalcMsrImpl.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/pagination/impl/LocalDataAggregatorWithCalcMsrImpl.java
index c4524a4..f6798f4 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/pagination/impl/LocalDataAggregatorWithCalcMsrImpl.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/pagination/impl/LocalDataAggregatorWithCalcMsrImpl.java
@@ -95,7 +95,7 @@ public class LocalDataAggregatorWithCalcMsrImpl implements DataAggregator
     /**
      * Unique values represents null values of measure.
      */
-    protected double[] uniqueValues;
+    protected Object[] uniqueValues;
     
     
     protected ByteArrayWrapper dimensionsRowWrapper = new ByteArrayWrapper();
@@ -294,11 +294,10 @@ public class LocalDataAggregatorWithCalcMsrImpl implements DataAggregator
         }
         for(int i = 0;i < msrLength;i++)
         {
-            double value = available.getValue(measureOrdinal[i]);
-            if(uniqueValues[measureOrdinal[i]] != value)
+            Object value = available.getValue(measureOrdinal[i]);
+            if(!uniqueValues[measureOrdinal[i]].equals(value))
             {
-                currentMsrRowData[i].agg(value, available.backKeyArray, available.keyOffset,
-                        available.keyLength);
+                currentMsrRowData[i].agg(value);
             }
         }
     }
@@ -311,24 +310,25 @@ public class LocalDataAggregatorWithCalcMsrImpl implements DataAggregator
     
     private void aggregateMsrsForAggTable(KeyValue available, MeasureAggregator[] currentMsrRowData)
     {
-        double countValue = available.getValue(measureOrdinal[countMsrIndex]);
+        Object countValue = available.getValue(measureOrdinal[countMsrIndex]);
         
         for(int k = 0;k < avgMsrIndexes.length;k++)
         {
-            double value = available.getValue(measureOrdinal[avgMsrIndexes[k]]);
-            if(uniqueValues[measureOrdinal[avgMsrIndexes[k]]] != value)
+            Object value = available.getValue(measureOrdinal[avgMsrIndexes[k]]);
+            if(!uniqueValues[measureOrdinal[avgMsrIndexes[k]]].equals(value))
             {
-                currentMsrRowData[avgMsrIndexes[k]].agg(value,countValue);
+//                currentMsrRowData[avgMsrIndexes[k]].agg(value,countValue);
+// make changes to support agg(MolapReadDataHolder newVal,int index)
+                currentMsrRowData[avgMsrIndexes[k]].agg(available.getMsrData(measureOrdinal[avgMsrIndexes[k]]),available.getRow());
             } 
         }
         
         for(int i = 0;i < otherMsrIndexes.length;i++)
         {
-            double value = available.getValue(measureOrdinal[otherMsrIndexes[i]]);
-            if(uniqueValues[measureOrdinal[otherMsrIndexes[i]]] != value)
+            Object value = available.getValue(measureOrdinal[otherMsrIndexes[i]]);
+            if(!uniqueValues[measureOrdinal[otherMsrIndexes[i]]].equals(value))
             {
-                currentMsrRowData[otherMsrIndexes[i]].agg(value, available.backKeyArray,
-                    available.keyOffset, available.keyLength);
+                currentMsrRowData[otherMsrIndexes[i]].agg(value);
             }
         }
     }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/processor/ScannedResultProcessorImpl.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/processor/ScannedResultProcessorImpl.java
index ee8b136..5f9f054 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/processor/ScannedResultProcessorImpl.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/executer/processor/ScannedResultProcessorImpl.java
@@ -14,13 +14,11 @@ import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.datastorage.store.impl.FileFactory;
-import com.huawei.unibi.molap.engine.columnar.aggregator.impl.MapBasedResultAggregatorImpl;
 import com.huawei.unibi.molap.engine.executer.exception.QueryExecutionException;
 import com.huawei.unibi.molap.engine.executer.pagination.impl.DataFileWriter.KeyValueHolder;
 import com.huawei.unibi.molap.engine.executer.pagination.impl.QueryResult;
 import com.huawei.unibi.molap.engine.merger.MergerExecutor;
 import com.huawei.unibi.molap.engine.processor.DataProcessor;
-import com.huawei.unibi.molap.engine.processor.DataProcessorExt;
 import com.huawei.unibi.molap.engine.processor.FileBasedLimitProcessor;
 import com.huawei.unibi.molap.engine.processor.MemoryBasedLimitProcessor;
 import com.huawei.unibi.molap.engine.processor.exception.DataProcessorException;
@@ -114,9 +112,7 @@ public class ScannedResultProcessorImpl implements ScannedResultProcessor
     {
         if(!info.isDetailQuery())
         {
-//            mergedScannedResult = new TrieBasedResult(info.getColumnarSplitter().getKeySizeByBlock(
-//                    info.getQueryDimOrdinal()));
-            mergedScannedResult = new MapBasedResult();
+			mergedScannedResult = new MapBasedResult();
         }
         else
         {
@@ -228,7 +224,7 @@ public class ScannedResultProcessorImpl implements ScannedResultProcessor
         
         LOGGER.debug(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, "Finished result merging from all slices");
         
-        DataProcessorExt processor = getProcessor();
+        DataProcessor processor = getProcessor();
         if(!isFileBased)
         {
             KeyValueHolder[] sortedResult = ScannedResultProcessorUtil.getSortedResult(
@@ -241,14 +237,7 @@ public class ScannedResultProcessorImpl implements ScannedResultProcessor
                 processor.initialise(dataProcessorInfo);
                 for(int i = 0;i < sortedResult.length;i++)
                 {
-                    if(sortedResult[i].key.getCompleteComplexTypeData() == null)
-                    {
-                        processor.processRow(sortedResult[i].key.getMaskedKey(), sortedResult[i].value);
-                    }
-                    else
-                    {
-                        processor.processRow(sortedResult[i].key, sortedResult[i].value);
-                    }
+                    processor.processRow(sortedResult[i].key.getMaskedKey(), sortedResult[i].value);
                 }
             }
             catch(DataProcessorException e)
@@ -289,7 +278,7 @@ public class ScannedResultProcessorImpl implements ScannedResultProcessor
      * and return appropriate DataProcessor
      * @return DataProcessor
      */
-    private DataProcessorExt getProcessor()
+    private DataProcessor getProcessor()
     {
         if(!isFileBased)
         {
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/expression/DataType.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/expression/DataType.java
index d4711c1..84c0b27 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/expression/DataType.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/expression/DataType.java
@@ -1,7 +1,7 @@
 package com.huawei.unibi.molap.engine.expression;
 
 public enum DataType {
-    StringType(0), DateType(1), TimestampType(2), BooleanType(1), IntegerType(3), FloatType(4), LongType(5), DoubleType(6), NullType(7), ArrayType(8), StructType(9);
+    StringType(0), DateType(1), TimestampType(2), BooleanType(1), IntegerType(3), FloatType(4), LongType(5), DoubleType(6), NullType(7);
     private int presedenceOrder;
     public int getPresedenceOrder()
     {
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/EqualsMeasureFilterImpl.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/EqualsMeasureFilterImpl.java
index 457ff7b..5b245bc 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/EqualsMeasureFilterImpl.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/EqualsMeasureFilterImpl.java
@@ -19,6 +19,7 @@ eoYin4HD5rJWOePlKJxvq4sUwPXjD+zvxONTfqBw7f4j7ehjVtW+HXifw8s57Q==*/
 package com.huawei.unibi.molap.engine.filters.measurefilter;
 
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+import com.huawei.unibi.molap.engine.aggregator.util.AggUtil;
 import com.huawei.unibi.molap.engine.executer.calcexp.MolapCalcFunction;
 
 /**
@@ -57,7 +58,20 @@ public class EqualsMeasureFilterImpl implements MeasureFilter
         {
             return 0 == Double.compare(calcFunction.calculate(msrValue), filterValue) ? true : false;            
         }
-        return 0 == Double.compare(msrValue[index].getValue(), filterValue) ? true : false;
+        double value;
+
+        switch (AggUtil.getMeasureType(AggUtil.measureOrdinal[index]))
+        {
+            case BIGINT:
+                value = msrValue[index].getLongValue();
+                break;
+            case DECIMAL:
+                value = msrValue[index].getBigDecimalValue().doubleValue();
+                break;
+            default:
+                value = msrValue[index].getDoubleValue();
+        }
+        return 0 == Double.compare(value, filterValue) ? true : false;
     }
 
     /**
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/GreaterThanMeaureFilterImpl.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/GreaterThanMeaureFilterImpl.java
index f0de927..f11d80e 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/GreaterThanMeaureFilterImpl.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/GreaterThanMeaureFilterImpl.java
@@ -19,6 +19,7 @@
 package com.huawei.unibi.molap.engine.filters.measurefilter;
 
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+import com.huawei.unibi.molap.engine.aggregator.util.AggUtil;
 import com.huawei.unibi.molap.engine.executer.calcexp.MolapCalcFunction;
 
 /**
@@ -62,7 +63,16 @@ public class GreaterThanMeaureFilterImpl implements MeasureFilter
         {
             return calcFunction.calculate(msrValue)  > filterValue;
         }
-        return msrValue[index].getValue() > filterValue;
+        switch (AggUtil.getMeasureType(AggUtil.measureOrdinal[index]))
+        {
+            case BIGINT:
+                return msrValue[index].getLongValue() > filterValue;
+            case DECIMAL:
+                return msrValue[index].getBigDecimalValue().doubleValue() > filterValue;
+            default:
+                return msrValue[index].getDoubleValue() > filterValue;
+        }
+
     }
     
     /**
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/GreaterThanOrEqualMeaureFilterImpl.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/GreaterThanOrEqualMeaureFilterImpl.java
index 8ec15fd..2e17669 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/GreaterThanOrEqualMeaureFilterImpl.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/GreaterThanOrEqualMeaureFilterImpl.java
@@ -19,6 +19,7 @@ O0sKgknKWNakEcL9m/C6vR44mLep7eYFVoPxkEDsnr+lxaN3HuIaHlElutT1sA==*/
 package com.huawei.unibi.molap.engine.filters.measurefilter;
 
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+import com.huawei.unibi.molap.engine.aggregator.util.AggUtil;
 import com.huawei.unibi.molap.engine.executer.calcexp.MolapCalcFunction;
 
 /**
@@ -56,7 +57,16 @@ public class GreaterThanOrEqualMeaureFilterImpl implements MeasureFilter
         {
             return calcFunction.calculate(msrValue) >= filterValue;
         }
-        return msrValue[index].getValue() >= filterValue;
+
+        switch (AggUtil.getMeasureType(AggUtil.measureOrdinal[index]))
+        {
+            case BIGINT:
+                return msrValue[index].getLongValue() >= filterValue;
+            case DECIMAL:
+                return msrValue[index].getBigDecimalValue().doubleValue() >= filterValue;
+            default:
+                return msrValue[index].getDoubleValue() >= filterValue;
+        }
     }
     
     /**
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/LessThanMeasureFilterImpl.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/LessThanMeasureFilterImpl.java
index 1cae540..cf7e6f7 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/LessThanMeasureFilterImpl.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/LessThanMeasureFilterImpl.java
@@ -19,6 +19,7 @@ xIHD9PiNjDE92+f0jmohA/5b8xFEjVeW5TkrZglET5wAKZdsqE1BbgqrN6W9Eg==*/
 package com.huawei.unibi.molap.engine.filters.measurefilter;
 
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+import com.huawei.unibi.molap.engine.aggregator.util.AggUtil;
 import com.huawei.unibi.molap.engine.executer.calcexp.MolapCalcFunction;
 
 /**
@@ -59,7 +60,15 @@ public class LessThanMeasureFilterImpl implements MeasureFilter
         {
             return calcFunction.calculate(msrValue) < filterValue;
         }
-        return msrValue[index].getValue() < filterValue;
+        switch (AggUtil.getMeasureType(AggUtil.measureOrdinal[index]))
+        {
+            case BIGINT:
+                return msrValue[index].getLongValue() < filterValue;
+            case DECIMAL:
+                return msrValue[index].getBigDecimalValue().doubleValue() < filterValue;
+            default:
+                return msrValue[index].getDoubleValue() < filterValue;
+        }
     }
     
     /**
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/LessThanOrEqualToMeasureFilterImpl.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/LessThanOrEqualToMeasureFilterImpl.java
index d0ee821..19edd7c 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/LessThanOrEqualToMeasureFilterImpl.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/LessThanOrEqualToMeasureFilterImpl.java
@@ -19,6 +19,7 @@ w0akV2jLmNEmTwN+DoFXcXLiFX/h0MCbhmrNViWzLye6pTXl2IgtOwKNqWJILQ==*/
 package com.huawei.unibi.molap.engine.filters.measurefilter;
 
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+import com.huawei.unibi.molap.engine.aggregator.util.AggUtil;
 import com.huawei.unibi.molap.engine.executer.calcexp.MolapCalcFunction;
 
 /**
@@ -58,7 +59,15 @@ public class LessThanOrEqualToMeasureFilterImpl implements MeasureFilter
         {
             return calcFunction.calculate(msrValue) <= filterValue;
         }
-        return msrValue[index].getValue() <= filterValue;
+        switch (AggUtil.getMeasureType(AggUtil.measureOrdinal[index]))
+        {
+            case BIGINT:
+                return msrValue[index].getLongValue() <= filterValue;
+            case DECIMAL:
+                return msrValue[index].getBigDecimalValue().doubleValue() <= filterValue;
+            default:
+                return msrValue[index].getDoubleValue() <= filterValue;
+        }
     }
     
     /**
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/NotEqualsMeasureFilterImpl.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/NotEqualsMeasureFilterImpl.java
index b9e1b39..e38b7a5 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/NotEqualsMeasureFilterImpl.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/NotEqualsMeasureFilterImpl.java
@@ -19,8 +19,11 @@ KjViZGVmFG6oaTxSi56ZbWmBiRH1XMhrJXKGe8xj3wRKt7aPtmQLsyAqMnQSPQ==*/
 package com.huawei.unibi.molap.engine.filters.measurefilter;
 
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+import com.huawei.unibi.molap.engine.aggregator.util.AggUtil;
 import com.huawei.unibi.molap.engine.executer.calcexp.MolapCalcFunction;
 
+import java.math.BigDecimal;
+
 /**
  * NotEqualsMeasureFilter
  * @author R00900208
@@ -57,7 +60,15 @@ public class NotEqualsMeasureFilterImpl implements MeasureFilter
         {
             return calcFunction.calculate(msrValue) != filterValue;
         }
-        return msrValue[index].getValue() != filterValue;
+        switch (AggUtil.getMeasureType(AggUtil.measureOrdinal[index]))
+        {
+            case BIGINT:
+                return msrValue[index].getLongValue() != filterValue;
+            case DECIMAL:
+                return msrValue[index].getBigDecimalValue().doubleValue() > filterValue;
+            default:
+                return msrValue[index].getDoubleValue() > filterValue;
+        }
     }
     
     /**
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/util/FilterUtil.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/util/FilterUtil.java
index 9217641..7a296bc 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/util/FilterUtil.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/filters/measurefilter/util/FilterUtil.java
@@ -44,7 +44,6 @@ import com.huawei.unibi.molap.keygenerator.KeyGenException;
 import com.huawei.unibi.molap.keygenerator.KeyGenerator;
 import com.huawei.unibi.molap.keygenerator.factory.KeyGeneratorFactory;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
-import com.huawei.unibi.molap.olap.SqlStatement.Type;
 import com.huawei.unibi.molap.engine.datastorage.MemberStore;
 
 
@@ -93,25 +92,25 @@ public final class FilterUtil
                     createFilterEvaluatorTree(currentExpression.getRight(), info));
         case EQUALS:
         case IN:
-            return getConditionalFilterEvalutor(ExpressionType.EQUALS, false, expressionTree, info, expressionTree);
+            return getConditionalFilterEvalutor(ExpressionType.EQUALS, false, expressionTree, info);
 
         case GREATERTHAN:
         case GREATERYHAN_EQUALTO:
         case LESSTHAN:
         case LESSTHAN_EQUALTO:
-            return getConditionalFilterEvalutor(ExpressionType.EQUALS, true, expressionTree, info,expressionTree);
+            return getConditionalFilterEvalutor(ExpressionType.EQUALS, true, expressionTree, info);
             
         case NOT_EQUALS:
         case NOT_IN:
-            return getConditionalFilterEvalutor(ExpressionType.NOT_EQUALS, false, expressionTree, info, expressionTree);
+            return getConditionalFilterEvalutor(ExpressionType.NOT_EQUALS, false, expressionTree, info);
 
         default:
-            return getConditionalFilterEvalutor(ExpressionType.UNKNOWN, false, expressionTree, info, expressionTree);
+            return getConditionalFilterEvalutor(ExpressionType.UNKNOWN, false, expressionTree, info);
         }
     }
 
     private static FilterEvaluator getConditionalFilterEvalutor(ExpressionType filterExpressionType,
-            boolean isExpressionResolve, Expression expression, FilterEvaluatorInfo info, Expression expressionTree)
+            boolean isExpressionResolve, Expression expression, FilterEvaluatorInfo info)
     {
         BinaryConditionalExpression currentCondExpression = null;
         ConditionalExpression condExpression = null;
@@ -119,34 +118,14 @@ public final class FilterUtil
         {
         case EQUALS:
             currentCondExpression = (BinaryConditionalExpression)expression;
-            if(currentCondExpression.isSingleDimension() && 
-                    currentCondExpression.getColumnList().get(0).getDim().getDataType() != Type.ARRAY && 
-                    currentCondExpression.getColumnList().get(0).getDim().getDataType() != Type.STRUCT)
+            if(currentCondExpression.isSingleDimension())
             {
-                
                 int newDimensionIndex=QueryExecutorUtility.isNewDimension(info.getNewDimension(), currentCondExpression.getColumnList().get(0).getDim());
                 if(newDimensionIndex==-1)
                 {
                 CubeDataStore dataCache = info.getSlices().get(info.getCurrentSliceIndex())
                         .getDataCache(info.getFactTableName());
-                if(currentCondExpression.getColumnList().get(0).getDim().isHighCardinalityDim())
-                {
-                        if(checkIfExpressionContainsColumn(currentCondExpression.getLeft())
-                                || checkIfExpressionContainsColumn(currentCondExpression.getRight()))
-                        {
-                            return new RowLevelFilterEvalutor(expression, isExpressionResolve, true);
-                        }
-                       
-                        if(expressionTree.getFilterExpressionType() == ExpressionType.GREATERTHAN
-                                || expressionTree.getFilterExpressionType() == ExpressionType.LESSTHAN
-                                || expressionTree.getFilterExpressionType() == ExpressionType.GREATERYHAN_EQUALTO
-                                || expressionTree.getFilterExpressionType() == ExpressionType.LESSTHAN_EQUALTO)
-                        {
-                           return new RowLevelFilterEvalutor(expression, isExpressionResolve, true);
-                        }
-                    return new NonUniqueBlockEqualsEvalutor(expression, isExpressionResolve,true);
-                }
-                else if(dataCache.getAggKeyBlock()[currentCondExpression.getColumnList().get(0).getDim().getOrdinal()])
+                if(dataCache.getAggKeyBlock()[currentCondExpression.getColumnList().get(0).getDim().getOrdinal()])
                 {
                     return new UniqueBlockEqualsEvalutor(expression, isExpressionResolve,true);
                 }
@@ -165,31 +144,13 @@ public final class FilterUtil
         case NOT_EQUALS:
             
             currentCondExpression = (BinaryConditionalExpression)expression;
-            if(currentCondExpression.isSingleDimension() && 
-                    currentCondExpression.getColumnList().get(0).getDim().getDataType() != Type.ARRAY && 
-                    currentCondExpression.getColumnList().get(0).getDim().getDataType() != Type.STRUCT)
+            if(currentCondExpression.isSingleDimension())
             {
                 int newDimensionIndex=QueryExecutorUtility.isNewDimension(info.getNewDimension(), currentCondExpression.getColumnList().get(0).getDim());
                 if(newDimensionIndex==-1)
                 {
                     CubeDataStore dataCache = info.getSlices().get(info.getCurrentSliceIndex())
                             .getDataCache(info.getFactTableName());
-                    if(currentCondExpression.getColumnList().get(0).getDim().isHighCardinalityDim())
-                    {
-                        if(checkIfExpressionContainsColumn(currentCondExpression.getLeft())
-                                || checkIfExpressionContainsColumn(currentCondExpression.getRight()))
-                        {
-                            return new RowLevelFilterEvalutor(expression, isExpressionResolve, false);
-                        }
-                            if(expressionTree.getFilterExpressionType() == ExpressionType.GREATERTHAN
-                                    || expressionTree.getFilterExpressionType() == ExpressionType.LESSTHAN
-                                    || expressionTree.getFilterExpressionType() == ExpressionType.GREATERYHAN_EQUALTO
-                                    || expressionTree.getFilterExpressionType() == ExpressionType.LESSTHAN_EQUALTO)
-                            {
-                               return new RowLevelFilterEvalutor(expression, isExpressionResolve, false);
-                            }
-                        return new NonUniqueBlockNotEqualsEvaluator(expression, isExpressionResolve,false);
-                    }
                     if(dataCache.getAggKeyBlock()[currentCondExpression.getColumnList().get(0).getDim().getOrdinal()])
                     {
                         return new UniqueBlockNotEqualsEvaluator(expression, isExpressionResolve, false);
@@ -207,10 +168,7 @@ public final class FilterUtil
                 }
             }
         default:
-            condExpression = (ConditionalExpression)expression;
-            if(condExpression.isSingleDimension() && 
-                    condExpression.getColumnList().get(0).getDim().getDataType() != Type.ARRAY && 
-                    condExpression.getColumnList().get(0).getDim().getDataType() != Type.STRUCT)
+            if(expression instanceof ConditionalExpression)
             {
                 condExpression = (ConditionalExpression)expression;
                 if(condExpression.isSingleDimension())
@@ -220,19 +178,6 @@ public final class FilterUtil
                     {
                     CubeDataStore dataCache = info.getSlices().get(info.getCurrentSliceIndex())
                             .getDataCache(info.getFactTableName());
-                    if(condExpression.getColumnList().get(0).getDim().isHighCardinalityDim())
-                    {
-                        if(checkIfExpressionContainsColumn(currentCondExpression.getLeft())
-                                || checkIfExpressionContainsColumn(currentCondExpression.getRight()))
-                        {
-                            return new RowLevelFilterEvalutor(expression, isExpressionResolve, false);
-                        }
-                        else if(expressionTree.getFilterExpressionType() == ExpressionType.UNKNOWN)
-                        {
-                            return new RowLevelFilterEvalutor(expression, false,false);
-                        }
-                        return new NonUniqueBlockEqualsEvalutor(expression, true,true);
-                    }
                     if(dataCache.getAggKeyBlock()[condExpression.getColumnList().get(0).getDim().getOrdinal()])
                     {
                         return new UniqueBlockEqualsEvalutor(expression, true,true);
@@ -260,29 +205,6 @@ public final class FilterUtil
             }
         }
     }
-    
-    /**
-     * This method will check if a given expression contains a column expression recursively.
-     * 
-     * @param right
-     * @return
-     */
-    public static boolean checkIfExpressionContainsColumn(Expression expression)
-    {
-        if(expression instanceof ColumnExpression)
-        {
-            return true;
-        }
-        for(Expression child: expression.getChildren())
-        {
-            if(checkIfExpressionContainsColumn(child))
-            {
-                return true;
-            }
-        }
-        
-        return false;
-    }
 
     private static byte[] getMaskedKey(int[] ranges, byte[] key)
     {
@@ -325,27 +247,11 @@ public final class FilterUtil
         return byteIndexs;
     }
 
-    
-    private static List<byte[]> getDirectSurrogateKeyMemberForFilter(FilterEvaluatorInfo info,
-            ColumnExpression columnExpression, List<String> evaluateResultListFinal, boolean isIncludeFilter)
-    {
-        List<byte[]> filterValuesList = new ArrayList<byte[]>(20);
-        for(String result : evaluateResultListFinal)
-        {
-            filterValuesList.add(result.getBytes());
-        }
-        return filterValuesList;
-    }
     public static List<byte[]> getFilterValues(FilterEvaluatorInfo info, ColumnExpression columnExpression,
             List<String> evaluateResultList, boolean isIncludeFilter)
 
     {
         List<byte[]> filterValuesList = new ArrayList<byte[]>(20);
-//        if(columnExpression.getDim().getDataType() == Type.ARRAY || 
-//                columnExpression.getDim().getDataType() == Type.STRUCT)
-//        {
-//            return filterValuesList;
-//        }
         int[] keys = new int[info.getKeyGenerator().getDimCount()];
         Arrays.fill(keys, 0);
         int[] rangesForMaskedByte = getRangesForMaskedByte(columnExpression.getDim().getOrdinal(),
@@ -489,14 +395,7 @@ public final class FilterUtil
                 }
                 evaluateResultListFinal.add(result.getString());
             }
-            if(null!=columnExpression.getDim() && columnExpression.getDim().isHighCardinalityDim())
-            {
-                filterValuesList =getDirectSurrogateKeyMemberForFilter(info, columnExpression, evaluateResultListFinal,isIncludeFilter);
-            }
-            else
-            {
             filterValuesList = getFilterValues(info, columnExpression, evaluateResultListFinal,isIncludeFilter);
-            }
         }
         catch(FilterUnsupportedException e)
         {
@@ -505,8 +404,6 @@ public final class FilterUtil
         return filterValuesList.toArray(new byte[filterValuesList.size()][]);
     }
     
-
-
     public static byte[][] getFilterListForRS(Expression expression, ColumnExpression columnExpression, String defaultValues, int defaultSurrogate)
     {
         List<byte[]> filterValuesList = new ArrayList<byte[]>(20);
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/holders/MolapResultHolder.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/holders/MolapResultHolder.java
index e850969..5961aca 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/holders/MolapResultHolder.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/holders/MolapResultHolder.java
@@ -15,6 +15,7 @@ import java.util.List;
 
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+import com.huawei.unibi.molap.engine.aggregator.util.AggUtil;
 import com.huawei.unibi.molap.engine.scanner.impl.MolapKey;
 import com.huawei.unibi.molap.engine.scanner.impl.MolapValue;
 import com.huawei.unibi.molap.olap.SqlStatement.Type;
@@ -112,7 +113,17 @@ public class MolapResultHolder implements Serializable
         result = new Object[d.length][1];
         for(int i = 0;i < d.length;i++)
         {
-            result[i][0] = d[i].getValue();
+            switch(AggUtil.getMeasureType(AggUtil.measureOrdinal[i]))
+            {
+                case BIGINT:
+                    result[i][0] = d[i].getLongValue();
+                    break;
+                case DECIMAL:
+                    result[i][0] = d[i].getBigDecimalValue();
+                    break;
+                default:
+                    result[i][0] = d[i].getDoubleValue();
+            }
         }
     }
 
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/merger/SortedResultFileMerger.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/merger/SortedResultFileMerger.java
index 8ebbc4a..d88b074 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/merger/SortedResultFileMerger.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/merger/SortedResultFileMerger.java
@@ -87,7 +87,7 @@ public class SortedResultFileMerger implements Callable<Void>
                 ResultTempFileReader molapSortTempFileChunkHolder = new ResultTempFileReader(file.getAbsolutePath(),
                         dataProcessorInfo.getKeySize(), AggUtil.getAggregators(dataProcessorInfo.getAggType(), false,
                                 dataProcessorInfo.getKeyGenerator(), dataProcessorInfo.getCubeUniqueName(),
-                                dataProcessorInfo.getMsrMinValue(),null),
+                                dataProcessorInfo.getMsrMinValue(), dataProcessorInfo.getDataTypes()),
                                 dataProcessorInfo.getFileBufferSize());
                 // initialize
                 molapSortTempFileChunkHolder.initialize();
@@ -161,7 +161,7 @@ public class SortedResultFileMerger implements Callable<Void>
         }
 
         dataFile.setMeasureAggs(AggUtil.getAggregators(dataProcessorInfo.getAggType(), false, dataProcessorInfo.getKeyGenerator(), dataProcessorInfo
-                .getCubeUniqueName(),dataProcessorInfo.getMsrMinValue(),null));
+                .getCubeUniqueName(),dataProcessorInfo.getMsrMinValue(), dataProcessorInfo.getDataTypes()));
         try
         {
             // read the next row to process and add to the heap.
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/merger/UnSortedResultMerger.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/merger/UnSortedResultMerger.java
index cefadfb..51038d5 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/merger/UnSortedResultMerger.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/merger/UnSortedResultMerger.java
@@ -91,7 +91,7 @@ public class UnSortedResultMerger implements Callable<Void>
                 // reads the temp files and creates ResultTempFileReader object.
                 ResultTempFileReader molapSortTempFileChunkHolder = new ResultTempFileReader(file.getAbsolutePath(),
                         dataProcessorInfo.getKeySize(), AggUtil.getAggregators(dataProcessorInfo.getAggType(), false, dataProcessorInfo.getKeyGenerator(), dataProcessorInfo
-                                .getCubeUniqueName(),dataProcessorInfo.getMsrMinValue(),dataProcessorInfo.getHighCardinalityTypes()),
+                                .getCubeUniqueName(),dataProcessorInfo.getMsrMinValue(), dataProcessorInfo.getDataTypes()),
                                 dataProcessorInfo.getFileBufferSize());
                 // initialize
                 molapSortTempFileChunkHolder.initialize();
@@ -137,7 +137,7 @@ public class UnSortedResultMerger implements Callable<Void>
                     dataProcessor.processRow(poll.getKey(), poll.getMeasures());
 
                 poll.setMeasureAggs(AggUtil.getAggregators(dataProcessorInfo.getAggType(), false, dataProcessorInfo.getKeyGenerator(), dataProcessorInfo
-                        .getCubeUniqueName(),dataProcessorInfo.getMsrMinValue(),dataProcessorInfo.getHighCardinalityTypes()));
+                        .getCubeUniqueName(),dataProcessorInfo.getMsrMinValue(), dataProcessorInfo.getDataTypes()));
                 }
             }
             catch(DataProcessorException e)
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/DataProcessor.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/DataProcessor.java
index 6320fc0..ff3f44a 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/DataProcessor.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/DataProcessor.java
@@ -4,7 +4,6 @@ import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 import com.huawei.unibi.molap.engine.executer.pagination.impl.QueryResult;
 import com.huawei.unibi.molap.engine.processor.exception.DataProcessorException;
 import com.huawei.unibi.molap.engine.schema.metadata.DataProcessorInfo;
-import com.huawei.unibi.molap.engine.wrappers.ByteArrayWrapper;
 import com.huawei.unibi.molap.iterator.MolapIterator;
 
 
@@ -13,10 +12,6 @@ public interface DataProcessor
     void initialise(DataProcessorInfo model) throws DataProcessorException;
 
     void processRow(byte[] key, MeasureAggregator[] value) throws DataProcessorException;
-    
-    //void processRow(ByteArrayWrapper key, MeasureAggregator[] value) throws DataProcessorException;
-
-    void processRow(ByteArrayWrapper key, MeasureAggregator[] value) throws DataProcessorException;
 
     void finish() throws DataProcessorException;
 
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/DataProcessorExt.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/DataProcessorExt.java
deleted file mode 100644
index 5db9b79..0000000
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/DataProcessorExt.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package com.huawei.unibi.molap.engine.processor;
-
-import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
-import com.huawei.unibi.molap.engine.processor.exception.DataProcessorException;
-import com.huawei.unibi.molap.engine.wrappers.ByteArrayWrapper;
-
-public interface DataProcessorExt extends DataProcessor
-{
-
-    /**
-     * This interface will help the engine to process the data based on entire byte array object.
-     * @param key
-     * @param value
-     * @throws DataProcessorException
-     */
-    void processRow(ByteArrayWrapper key, MeasureAggregator[] value) throws DataProcessorException;
-}
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/FileBasedLimitProcessor.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/FileBasedLimitProcessor.java
index d4f3df9..70be94a 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/FileBasedLimitProcessor.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/FileBasedLimitProcessor.java
@@ -4,18 +4,17 @@ import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 import com.huawei.unibi.molap.engine.executer.pagination.impl.QueryResult;
 import com.huawei.unibi.molap.engine.processor.exception.DataProcessorException;
 import com.huawei.unibi.molap.engine.schema.metadata.DataProcessorInfo;
-import com.huawei.unibi.molap.engine.wrappers.ByteArrayWrapper;
 import com.huawei.unibi.molap.iterator.MolapIterator;
 
-public class FileBasedLimitProcessor implements DataProcessorExt
+public class FileBasedLimitProcessor implements DataProcessor
 {
-    private DataProcessorExt processor;
+    private DataProcessor processor;
     
     private int limit;
     
     private int counter;
     
-    public FileBasedLimitProcessor(DataProcessorExt processor)
+    public FileBasedLimitProcessor(DataProcessor processor)
     {
         this.processor=processor;
     }
@@ -26,7 +25,6 @@ public class FileBasedLimitProcessor implements DataProcessorExt
         this.limit=model.getLimit();
     }
 
-
     @Override
     public void processRow(byte[] key, MeasureAggregator[] value) throws DataProcessorException
     {
@@ -36,7 +34,7 @@ public class FileBasedLimitProcessor implements DataProcessorExt
             counter++;
         }
     }
-    
+
     @Override
     public void finish() throws DataProcessorException
     {
@@ -49,16 +47,5 @@ public class FileBasedLimitProcessor implements DataProcessorExt
         // TODO Auto-generated method stub
         return processor.getQueryResultIterator();
     }
-    
-    @Override
-    public void processRow(ByteArrayWrapper key, MeasureAggregator[] value) throws DataProcessorException
-    {
-        if(limit==-1 || counter<limit)
-        {
-            processor.processRow(key, value);
-            counter++;
-        }
-        
-    }
 
 }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/MemoryBasedLimitProcessor.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/MemoryBasedLimitProcessor.java
index 2afdb73..e9da2b4 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/MemoryBasedLimitProcessor.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/MemoryBasedLimitProcessor.java
@@ -1,7 +1,5 @@
 package com.huawei.unibi.molap.engine.processor;
 
-import java.util.List;
-
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 import com.huawei.unibi.molap.engine.executer.pagination.impl.QueryResult;
 import com.huawei.unibi.molap.engine.processor.exception.DataProcessorException;
@@ -10,7 +8,7 @@ import com.huawei.unibi.molap.engine.schema.metadata.DataProcessorInfo;
 import com.huawei.unibi.molap.engine.wrappers.ByteArrayWrapper;
 import com.huawei.unibi.molap.iterator.MolapIterator;
 
-public class MemoryBasedLimitProcessor implements DataProcessorExt
+public class MemoryBasedLimitProcessor implements DataProcessor
 {
     private int limit;
     
@@ -28,63 +26,27 @@ public class MemoryBasedLimitProcessor implements DataProcessorExt
         limit=model.getLimit();
     }
 
-
-
-    @Override
-    public void finish() throws DataProcessorException
-    {
-        
-    }
-
-    @Override
-    public MolapIterator<QueryResult> getQueryResultIterator()
-    {
-        return new MemoryBasedResultIterator(result);
-    }
-
     @Override
     public void processRow(byte[] key, MeasureAggregator[] value) throws DataProcessorException
     {
-
         if(limit == -1 || result.size() < limit)
         {
             ByteArrayWrapper arrayWrapper = new ByteArrayWrapper();
             arrayWrapper.setMaskedKey(key);
             result.add(arrayWrapper, value);
         }
-        
     }
-    
-    /**
-     * While processing the row the direct surrogate key values will be added directly as byte[] to
-     * ByteArrayWrapper instance, Internally list will be maintaned in each ByteArrayWrapper instance
-     * inorder to hold the direct surrogate key value for different surrogate keys.
-     */
-    public void processRow(ByteArrayWrapper key, MeasureAggregator[] value) throws DataProcessorException
+
+    @Override
+    public void finish() throws DataProcessorException
     {
-        if(limit == -1 || result.size() < limit)
-        {
-            ByteArrayWrapper arrayWrapper = new ByteArrayWrapper();
-            arrayWrapper.setMaskedKey(key.getMaskedKey());
-            List<byte []> listOfDirectKey=key.getDirectSurrogateKeyList();
-            if(null!=listOfDirectKey)
-            {
-                for(byte[] byteArray:listOfDirectKey)
-                {
-                    arrayWrapper.addToDirectSurrogateKeyList(byteArray);
-                }
-            }
-            List<byte []> listOfComplexTypes=key.getCompleteComplexTypeData();
-            if(null!=listOfComplexTypes)
-            {
-                for(byte[] byteArray:listOfComplexTypes)
-                {
-                    arrayWrapper.addComplexTypeData(byteArray);
-                }
-            }
-            result.add(arrayWrapper, value);
-        }
         
     }
 
+    @Override
+    public MolapIterator<QueryResult> getQueryResultIterator()
+    {
+        return new MemoryBasedResultIterator(result);
+    }
+
 }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/row/AggreagtedRowProcessor.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/row/AggreagtedRowProcessor.java
index d23b152..e04deea 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/row/AggreagtedRowProcessor.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/row/AggreagtedRowProcessor.java
@@ -1,13 +1,13 @@
 package com.huawei.unibi.molap.engine.processor.row;
 
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
-import com.huawei.unibi.molap.engine.processor.DataProcessorExt;
+import com.huawei.unibi.molap.engine.processor.DataProcessor;
 import com.huawei.unibi.molap.engine.processor.exception.DataProcessorException;
 import com.huawei.unibi.molap.util.ByteUtil;
 
 public class AggreagtedRowProcessor extends RowProcessor
 {
-    public AggreagtedRowProcessor(DataProcessorExt dataProcessor)
+    public AggreagtedRowProcessor(DataProcessor dataProcessor)
     {
         super(dataProcessor);
     }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/row/RowProcessor.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/row/RowProcessor.java
index 75680f2..cf898db 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/row/RowProcessor.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/row/RowProcessor.java
@@ -2,18 +2,17 @@ package com.huawei.unibi.molap.engine.processor.row;
 
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 import com.huawei.unibi.molap.engine.executer.pagination.impl.QueryResult;
-import com.huawei.unibi.molap.engine.processor.DataProcessorExt;
+import com.huawei.unibi.molap.engine.processor.DataProcessor;
 import com.huawei.unibi.molap.engine.processor.exception.DataProcessorException;
 import com.huawei.unibi.molap.engine.schema.metadata.DataProcessorInfo;
-import com.huawei.unibi.molap.engine.wrappers.ByteArrayWrapper;
 import com.huawei.unibi.molap.iterator.MolapIterator;
 
-public class RowProcessor implements DataProcessorExt
+public class RowProcessor implements DataProcessor
 {
 
-    protected DataProcessorExt dataProcessor;
+    protected DataProcessor dataProcessor;
     
-    public RowProcessor(DataProcessorExt dataProcessor)
+    public RowProcessor(DataProcessor dataProcessor)
     {
         this.dataProcessor=dataProcessor;
     }
@@ -42,11 +41,4 @@ public class RowProcessor implements DataProcessorExt
         return dataProcessor.getQueryResultIterator();
     }
 
-    @Override
-    public void processRow(ByteArrayWrapper key, MeasureAggregator[] value) throws DataProcessorException
-    {
-        dataProcessor.processRow(key, value);
-        
-    }
-
 }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/sort/SortMeasureProcessor.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/sort/SortMeasureProcessor.java
index 5c1f1c3..7435a14 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/sort/SortMeasureProcessor.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/sort/SortMeasureProcessor.java
@@ -26,7 +26,6 @@ import com.huawei.unibi.molap.engine.processor.DataProcessor;
 import com.huawei.unibi.molap.engine.processor.exception.DataProcessorException;
 import com.huawei.unibi.molap.engine.schema.metadata.DataProcessorInfo;
 import com.huawei.unibi.molap.engine.util.ScannedResultProcessorUtil;
-import com.huawei.unibi.molap.engine.wrappers.ByteArrayWrapper;
 import com.huawei.unibi.molap.engine.writer.HeapBasedDataFileWriterThread;
 import com.huawei.unibi.molap.iterator.MolapIterator;
 
@@ -109,12 +108,7 @@ public class SortMeasureProcessor implements DataProcessor
     {
         addRow(key, value);
     }
-    
-    @Override
-    public void processRow(ByteArrayWrapper key, MeasureAggregator[] value) throws DataProcessorException
-    {
-        processRow(key.getMaskedKey(), value);
-    }
+
     /*
      * (non-Javadoc)
      * 
@@ -133,16 +127,11 @@ public class SortMeasureProcessor implements DataProcessor
             {
                 for(int i = 0;i < dataProcessorInfo.getMaskedByteRangeForSorting().length - 1;i++)
                 {
-                    if(null== dataProcessorInfo.getMaskedByteRangeForSorting()[i])
-                    {
-                        continue;
-                    }
                     keyComparator = new MaksedByteComparatorForDFCH(
                             dataProcessorInfo.getMaskedByteRangeForSorting()[i],
                             dataProcessorInfo.getDimensionSortOrder()[i], dataProcessorInfo.getDimensionMasks()[i]);
                     compratorList.add(keyComparator);
                 }
-                
             }
             MeasureComparatorDFCH measureComparator = new MeasureComparatorDFCH(measureSortModel.getMeasureIndex(),
                     measureSortModel.getSortOrder());
@@ -172,19 +161,13 @@ public class SortMeasureProcessor implements DataProcessor
                 if(dataProcessorInfo.getDimensionSortOrder().length < 1)
                 {
                     MaksedByteComparatorForTuple keyComparator = null;
-
                     for(int i = 0;i < dataProcessorInfo.getMaskedByteRangeForSorting().length - 1;i++)
                     {
-                        if(null== dataProcessorInfo.getMaskedByteRangeForSorting()[i])
-                        {
-                            continue;
-                        }
                         keyComparator = new MaksedByteComparatorForTuple(
                                 dataProcessorInfo.getMaskedByteRangeForSorting()[i],
                                 dataProcessorInfo.getDimensionSortOrder()[i], dataProcessorInfo.getDimensionMasks()[i]);
                         compratorList.add(keyComparator);
                     }
-                    
                 }
                 MeasureComparatorTuple measureComparator = new MeasureComparatorTuple(
                         measureSortModel.getMeasureIndex(), measureSortModel.getSortOrder());
@@ -226,21 +209,15 @@ public class SortMeasureProcessor implements DataProcessor
         {
             for(int i = 0;i < dataProcessorInfo.getMaskedByteRangeForSorting().length - 1;i++)
             {
-                if(null==dataProcessorInfo.getMaskedByteRangeForSorting()[i])
-                {
-                    continue;
-                }
                 keyComparator = new MaksedByteComparatorForTuple(dataProcessorInfo.getMaskedByteRangeForSorting()[i],
                         dataProcessorInfo.getDimensionSortOrder()[i], dataProcessorInfo.getDimensionMasks()[i]);
                 compratorList.add(keyComparator);
             }
         }
-        this.comparatorChain = new ComparatorChain(compratorList);
-       
         MeasureComparatorTuple measureComparator = new MeasureComparatorTuple(measureSortModel.getMeasureIndex(),
                 measureSortModel.getSortOrder());
         compratorList.add(measureComparator);
-        
+        this.comparatorChain = new ComparatorChain(compratorList);
     }
 
     /**
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/writer/BlockWriterProcessor.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/writer/BlockWriterProcessor.java
index 545d2b7..ad43f3a 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/writer/BlockWriterProcessor.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/writer/BlockWriterProcessor.java
@@ -13,12 +13,11 @@ import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.datastorage.store.compression.SnappyCompression.SnappyByteCompression;
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
 import com.huawei.unibi.molap.engine.executer.pagination.impl.QueryResult;
-import com.huawei.unibi.molap.engine.processor.DataProcessorExt;
+import com.huawei.unibi.molap.engine.processor.DataProcessor;
 import com.huawei.unibi.molap.engine.processor.exception.DataProcessorException;
 import com.huawei.unibi.molap.engine.result.iterator.FileBasedResultIteartor;
 import com.huawei.unibi.molap.engine.schema.metadata.DataProcessorInfo;
 import com.huawei.unibi.molap.engine.util.MolapEngineLogEvent;
-import com.huawei.unibi.molap.engine.wrappers.ByteArrayWrapper;
 import com.huawei.unibi.molap.iterator.MolapIterator;
 import com.huawei.unibi.molap.writer.MolapDataWriter;
 import com.huawei.unibi.molap.writer.exception.MolapDataWriterException;
@@ -34,7 +33,7 @@ import com.huawei.unibi.molap.writer.exception.MolapDataWriterException;
  *         writing the blocks.
  * Class Version  : 1.0
  */
-public class BlockWriterProcessor implements DataProcessorExt
+public class BlockWriterProcessor implements DataProcessor
 {
     private static final LogService LOGGER = LogServiceFactory.getLogService(BlockWriterProcessor.class.getName());
 
@@ -171,7 +170,7 @@ public class BlockWriterProcessor implements DataProcessorExt
         entryCount++;
         rowCount++;
     }
-    
+
     /**
      *  This method is for closing the streams.
      */
@@ -241,13 +240,4 @@ public class BlockWriterProcessor implements DataProcessorExt
         return new FileBasedResultIteartor(outputLocation + '/' + queryId+"_0", model);
     }
 
-    @Override
-    public void processRow(ByteArrayWrapper key, MeasureAggregator[] value) throws DataProcessorException
-    {
-        // TODO Auto-generated method stub
-        
-    }
-
-
-
 }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/writer/RowWriterProcessor.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/writer/RowWriterProcessor.java
index 8345e53..338de24 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/writer/RowWriterProcessor.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/processor/writer/RowWriterProcessor.java
@@ -14,7 +14,6 @@ import com.huawei.unibi.molap.engine.processor.DataProcessor;
 import com.huawei.unibi.molap.engine.processor.exception.DataProcessorException;
 import com.huawei.unibi.molap.engine.schema.metadata.DataProcessorInfo;
 import com.huawei.unibi.molap.engine.util.MolapEngineLogEvent;
-import com.huawei.unibi.molap.engine.wrappers.ByteArrayWrapper;
 import com.huawei.unibi.molap.iterator.MolapIterator;
 import com.huawei.unibi.molap.util.MolapUtil;
 
@@ -111,13 +110,7 @@ public class RowWriterProcessor implements DataProcessor
         }
         entryCount++;
     }
-    
-    @Override
-    public void processRow(ByteArrayWrapper key, MeasureAggregator[] value) throws DataProcessorException
-    {
-        processRow(key.getMaskedKey(), value);
-    }
-    
+
     @Override
     public void finish() throws DataProcessorException
     {
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/reader/QueryDataFileReader.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/reader/QueryDataFileReader.java
index 199f310..2c68830 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/reader/QueryDataFileReader.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/reader/QueryDataFileReader.java
@@ -75,7 +75,7 @@ public class QueryDataFileReader
         byte[] keyArray = fileHolder.readByteArray(this.filePath, leafNodeInfo.getKeyOffset(),
                 leafNodeInfo.getKeyLength());
         MeasureAggregator[] measureAggregators = AggUtil.getAggregators(info.getAggType(), false, info.getKeyGenerator(), info
-                        .getCubeUniqueName(),info.getMsrMinValue(),info.getHighCardinalityTypes());
+                        .getCubeUniqueName(),info.getMsrMinValue(), info.getDataTypes());
 
         DataInputStream[] msrStreams = new DataInputStream[leafNodeInfo.getMeasureLength().length];
 
@@ -102,7 +102,7 @@ public class QueryDataFileReader
                 wrapper.setMaskedKey(key);
                 queryResult.add(wrapper, measureAggregators);
                 measureAggregators = AggUtil.getAggregators(info.getAggType(), false, info.getKeyGenerator(), info
-                        .getCubeUniqueName(),info.getMsrMinValue(),info.getHighCardinalityTypes());
+                        .getCubeUniqueName(),info.getMsrMinValue(), info.getDataTypes());
             }
         }
         catch(IOException e)
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/scanner/ScannersInputCombiner.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/scanner/ScannersInputCombiner.java
index daab35e..fa49877 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/scanner/ScannersInputCombiner.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/scanner/ScannersInputCombiner.java
@@ -127,7 +127,18 @@ public class ScannersInputCombiner implements DataInputStream
             {
                 for(int k = 0;k < lastAggs.length;k++)
                 {
-                    lastData[k] = lastAggs[k].getValue();
+                    switch (AggUtil.getMeasureType(AggUtil.measureOrdinal[k]))
+                    {
+                        case BIGINT:
+                            lastData[k] = lastAggs[k].getLongValue();
+                            break;
+                        case DECIMAL:
+                            lastData[k] = lastAggs[k].getBigDecimalValue().doubleValue();
+                            break;
+                        default:
+                            lastData[k] = lastAggs[k].getDoubleValue();
+                    }
+
 //                    setDecimals(k, lastData[k]);
                 }
 
@@ -144,7 +155,8 @@ public class ScannersInputCombiner implements DataInputStream
                 // Just aggregate with old data
                 for(int j = 0;j < lastAggs.length;j++)
                 {
-                    lastAggs[j].agg(vals[j], vals[lastData.length - 1]);
+//                    lastAggs[j].agg(vals[j], vals[lastData.length - 1]);
+                    lastAggs[j].agg(vals[j]);
                 }
                 return data;
             }
@@ -152,7 +164,8 @@ public class ScannersInputCombiner implements DataInputStream
             // Just aggregate with old data
             for(int j = 0;j < lastAggs.length;j++)
             {
-                lastAggs[j].agg(vals[j], vals[lastData.length - 1]);
+//                lastAggs[j].agg(vals[j], vals[lastData.length - 1]);
+                lastAggs[j].agg(vals[j]);
             }
         }
 
@@ -161,7 +174,17 @@ public class ScannersInputCombiner implements DataInputStream
         {
             for(int k = 0;k < lastAggs.length;k++)
             {
-                lastData[k] = lastAggs[k].getValue();
+                switch (AggUtil.getMeasureType(AggUtil.measureOrdinal[k]))
+                {
+                    case BIGINT:
+                        lastData[k] = lastAggs[k].getLongValue();
+                        break;
+                    case DECIMAL:
+                        lastData[k] = lastAggs[k].getBigDecimalValue().doubleValue();
+                        break;
+                    default:
+                        lastData[k] = lastAggs[k].getDoubleValue();
+                }
 //                setDecimals(k, lastData[k]);
             }
             data = new Pair(lastKey, lastData);
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/scanner/impl/MolapKeyValueTopNGroup.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/scanner/impl/MolapKeyValueTopNGroup.java
index d0dbe35..72af4b7 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/scanner/impl/MolapKeyValueTopNGroup.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/scanner/impl/MolapKeyValueTopNGroup.java
@@ -11,6 +11,7 @@ import java.util.List;
 import java.util.PriorityQueue;
 
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator;
+import com.huawei.unibi.molap.engine.aggregator.util.AggUtil;
 import com.huawei.unibi.molap.engine.executer.impl.topn.TopNModel.MolapTopNType;
 
 /**
@@ -102,8 +103,23 @@ public class MolapKeyValueTopNGroup extends MolapValue
     
     private int compareTop(MolapKeyValueGroup r1, MolapKeyValueGroup r2)
     {
-        Number left = (Number)r1.getValues()[0].getValue();
-        Number right = (Number)r2.getValues()[0].getValue();
+        Number left;
+        Number right;
+        switch (AggUtil.getMeasureType(AggUtil.measureOrdinal[0]))
+        {
+            case BIGINT:
+                left = (Number)r1.getValues()[0].getLongValue();
+                right = (Number)r2.getValues()[0].getLongValue();
+                break;
+            case DECIMAL:
+                left = (Number)r1.getValues()[0].getBigDecimalValue();
+                right = (Number)r2.getValues()[0].getBigDecimalValue();
+                break;
+            default:
+                left = (Number)r1.getValues()[0].getDoubleValue();
+                right = (Number)r2.getValues()[0].getDoubleValue();
+        }
+
         if(left.doubleValue() > right.doubleValue())
         {
             return 1;
@@ -144,8 +160,23 @@ public class MolapKeyValueTopNGroup extends MolapValue
      */
     private int compareBottom(MolapKeyValueGroup r1, MolapKeyValueGroup r2)
     {
-        Number left = (Number)r1.getValues()[0].getValue();
-        Number right = (Number)r2.getValues()[0].getValue();
+        Number left;
+        Number right;
+        switch (AggUtil.getMeasureType(AggUtil.measureOrdinal[0]))
+        {
+            case BIGINT:
+                left = (Number)r1.getValues()[0].getLongValue();
+                right = (Number)r2.getValues()[0].getLongValue();
+                break;
+            case DECIMAL:
+                left = (Number)r1.getValues()[0].getBigDecimalValue();
+                right = (Number)r2.getValues()[0].getBigDecimalValue();
+                break;
+            default:
+                left = (Number)r1.getValues()[0].getDoubleValue();
+                right = (Number)r2.getValues()[0].getDoubleValue();
+        }
+
         if(left.doubleValue() > right.doubleValue())
         {
             return -1;
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/ColumnarStorageScannerInfo.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/ColumnarStorageScannerInfo.java
index 31dcdcd..5c7f3cd 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/ColumnarStorageScannerInfo.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/ColumnarStorageScannerInfo.java
@@ -6,6 +6,7 @@ import com.huawei.unibi.molap.engine.columnar.datastoreblockprocessor.DataStoreB
 import com.huawei.unibi.molap.engine.datastorage.storeInterfaces.DataStoreBlock;
 import com.huawei.unibi.molap.engine.executer.impl.RestructureHolder;
 import com.huawei.unibi.molap.engine.executer.processor.ScannedResultProcessor;
+import com.huawei.unibi.molap.olap.SqlStatement;
 
 public class ColumnarStorageScannerInfo
 {
@@ -197,4 +198,5 @@ public class ColumnarStorageScannerInfo
     {
         return partitionId;
     }
+
 }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/DataProcessorInfo.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/DataProcessorInfo.java
index cab16df..0edd32a 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/DataProcessorInfo.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/DataProcessorInfo.java
@@ -10,6 +10,7 @@ import com.huawei.unibi.molap.engine.datastorage.InMemoryCube;
 import com.huawei.unibi.molap.engine.reader.ResultTempFileReader;
 import com.huawei.unibi.molap.keygenerator.KeyGenerator;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
+import com.huawei.unibi.molap.olap.SqlStatement;
 
 /**
  * 
@@ -50,7 +51,7 @@ public class DataProcessorInfo
     /**
      * msrMinValue
      */
-    private double[] msrMinValue;
+    private Object[] msrMinValue;
 
     /**
      * maskedByteRangeForsorting
@@ -100,8 +101,11 @@ public class DataProcessorInfo
     private int blockSize;
 
     private byte[] sortedDimIndex;
-
-    private boolean[] highCardinalityTypes;
+    
+    /**
+     * array of sql datatypes of mesaures and dimensions
+     */
+    protected SqlStatement.Type[] dataTypes;
 
     /**
      * @return the keySize
@@ -417,12 +421,12 @@ public class DataProcessorInfo
         this.aggType = aggType;
     }
 
-    public double[] getMsrMinValue()
+    public Object[] getMsrMinValue()
     {
         return msrMinValue;
     }
 
-    public void setMsrMinValue(double[] msrMinValue)
+    public void setMsrMinValue(Object[] msrMinValue)
     {
         this.msrMinValue = msrMinValue;
     }
@@ -437,15 +441,14 @@ public class DataProcessorInfo
         return sortedDimIndex;
     }
 
-    public void setHighCardinalityTypes(boolean[] highCardinalityTypes)
+    public SqlStatement.Type[] getDataTypes()
     {
-        this.highCardinalityTypes=highCardinalityTypes;
-        
+        return dataTypes;
     }
-    
-    public boolean[] getHighCardinalityTypes()
+
+    public void setDataTypes(SqlStatement.Type[] dataTypes)
     {
-        return highCardinalityTypes;
+        this.dataTypes = dataTypes;
     }
 
 }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/FilterEvaluatorInfo.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/FilterEvaluatorInfo.java
index 1c74d72..bc66034 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/FilterEvaluatorInfo.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/FilterEvaluatorInfo.java
@@ -1,13 +1,10 @@
 package com.huawei.unibi.molap.engine.schema.metadata;
 
 import java.util.List;
-import java.util.Map;
 
-import com.huawei.unibi.molap.engine.complex.querytypes.GenericQueryType;
 import com.huawei.unibi.molap.engine.datastorage.InMemoryCube;
 import com.huawei.unibi.molap.engine.executer.impl.QueryFilterInfo;
 import com.huawei.unibi.molap.keygenerator.KeyGenerator;
-import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
 
 public class FilterEvaluatorInfo
 {
@@ -23,8 +20,6 @@ public class FilterEvaluatorInfo
     
     private String[] newDimension;
     
-    private Dimension[] dimensions;
-    
     private String[] newMeasures;
     
     private double[] newDefaultValues;
@@ -32,28 +27,6 @@ public class FilterEvaluatorInfo
     private int[] newDimensionSurrogates;
     
     private String[] newDimensionDefaultValue;
-    
-    private Map<Integer, GenericQueryType> complexTypesWithBlockStartIndex; 
-
-    public Dimension[] getDimensions()
-    {
-        return dimensions;
-    }
-
-    public void setDimensions(Dimension[] dimensions)
-    {
-        this.dimensions = dimensions;
-    }
-    
-    public Map<Integer, GenericQueryType> getComplexTypesWithBlockStartIndex()
-    {
-        return complexTypesWithBlockStartIndex;
-    }
-
-    public void setComplexTypesWithBlockStartIndex(Map<Integer, GenericQueryType> complexTypesWithBlockStartIndex)
-    {
-        this.complexTypesWithBlockStartIndex = complexTypesWithBlockStartIndex;
-    }
 
     public List<InMemoryCube> getSlices()
     {
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/SliceExecutionInfo.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/SliceExecutionInfo.java
index d5c8d66..f736928 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/SliceExecutionInfo.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/SliceExecutionInfo.java
@@ -22,11 +22,8 @@ import java.util.List;
 //import java.util.Set;
 
 
-import java.util.Map;
-
 import com.huawei.unibi.molap.engine.aggregator.CustomMolapAggregateExpression;
 import com.huawei.unibi.molap.engine.aggregator.dimension.DimensionAggregatorInfo;
-import com.huawei.unibi.molap.engine.complex.querytypes.GenericQueryType;
 import com.huawei.unibi.molap.engine.datastorage.InMemoryCube;
 import com.huawei.unibi.molap.engine.datastorage.storeInterfaces.DataStoreBlock;
 import com.huawei.unibi.molap.engine.directinterface.impl.MeasureSortModel;
@@ -37,6 +34,7 @@ import com.huawei.unibi.molap.engine.filters.measurefilter.GroupMeasureFilterMod
 import com.huawei.unibi.molap.keygenerator.KeyGenerator;
 import com.huawei.unibi.molap.keygenerator.columnar.ColumnarSplitter;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
+import com.huawei.unibi.molap.olap.SqlStatement;
 
 /**
  * 
@@ -76,7 +74,6 @@ public class SliceExecutionInfo
      */
     private Dimension[] queryDimensions;
 
-    
     /**
      * 
      */
@@ -95,7 +92,7 @@ public class SliceExecutionInfo
     /**
      * Unique values represents null values of measure.
      */
-    private double[] uniqueValues; 
+    private Object[] uniqueValues;
     
     /**
      * schemaName
@@ -280,7 +277,7 @@ public class SliceExecutionInfo
     /**
      * minValue
      */
-    private double[] msrMinValue;
+    private Object[] msrMinValue;
     
     /**
      * measurIndex
@@ -320,7 +317,7 @@ public class SliceExecutionInfo
     /**
      * msrDefaultValue
      */
-    private double[] msrDefaultValue;
+    private Object[] msrDefaultValue;
 
     private byte[] sortedDimensionsIndex;
     
@@ -331,33 +328,12 @@ public class SliceExecutionInfo
     private int numberOfNodeToScan;
     
     private boolean isFileBasedQuery;
-
-    private boolean[] highCardinalityTypes;
     
-    private Dimension[] dimensions;
-    
-    public Dimension[] getDimensions()
-    {
-        return dimensions;
-    }
-
-    public void setDimensions(Dimension[] dimensions)
-    {
-        this.dimensions = dimensions;
-    }
-
-    private Map<Integer, GenericQueryType> complexQueryDimensions;
+    /**
+     * array of sql datatypes of mesaures and dimensions
+     */
+    protected SqlStatement.Type[] dataTypes;
     
-    public Map<Integer, GenericQueryType> getComplexQueryDimensions()
-    {
-        return complexQueryDimensions;
-    }
-
-    public void setComplexQueryDimensions(Map<Integer, GenericQueryType> complexQueryDimensions)
-    {
-        this.complexQueryDimensions = complexQueryDimensions;
-    }
-
     /**
      * 
      * @param measureOrdinal
@@ -451,7 +427,7 @@ public class SliceExecutionInfo
     /**
      * @return the uniqueValues
      */
-    public double[] getUniqueValues()
+    public Object[] getUniqueValues()
     {
         return uniqueValues;
     }
@@ -459,7 +435,7 @@ public class SliceExecutionInfo
     /**
      * @param uniqueValues the uniqueValues to set
      */
-    public void setUniqueValues(final double[] uniqueValues)
+    public void setUniqueValues(final Object[] uniqueValues)
     {
         this.uniqueValues = uniqueValues;
     }
@@ -998,12 +974,12 @@ public class SliceExecutionInfo
         this.expressions = expressions;
     }
     
-    public double[] getMsrMinValue()
+    public Object[] getMsrMinValue()
     {
         return msrMinValue;
     }
 
-    public void setMsrMinValue(double[] msrMinValue)
+    public void setMsrMinValue(Object[] msrMinValue)
     {
         this.msrMinValue = msrMinValue;
     }
@@ -1069,12 +1045,12 @@ public class SliceExecutionInfo
         this.expressionStartIndex = expressionStartIndex;
     }
 
-    public double[] getMsrDefaultValue()
+    public Object[] getMsrDefaultValue()
     {
         return msrDefaultValue;
     }
 
-    public void setMsrDefaultValue(double[] msrDefaultValue)
+    public void setMsrDefaultValue(Object[] msrDefaultValue)
     {
         this.msrDefaultValue = msrDefaultValue;
     }
@@ -1149,21 +1125,13 @@ public class SliceExecutionInfo
         this.isFileBasedQuery = isFileBasedQuery;
     }
 
-    /**
-     * setHighCardinalityType.
-     * @param highCardinalityTypes
-     */
-    public void setHighCardinalityType(boolean[] highCardinalityTypes)
+    public SqlStatement.Type[] getDataTypes()
     {
-        this.highCardinalityTypes=highCardinalityTypes;
-        
+        return dataTypes;
     }
-    /**
-     * getHighCardinalityTypes.
-     * @return
-     */
-    public boolean[] getHighCardinalityTypes()
+
+    public void setDataTypes(SqlStatement.Type[] dataTypes)
     {
-        return highCardinalityTypes;
+        this.dataTypes = dataTypes;
     }
 }
\ No newline at end of file
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/SliceUniqueValueInfo.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/SliceUniqueValueInfo.java
index fa93085..790b4c1 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/SliceUniqueValueInfo.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/schema/metadata/SliceUniqueValueInfo.java
@@ -25,7 +25,7 @@ package com.huawei.unibi.molap.engine.schema.metadata;
  */
 public class SliceUniqueValueInfo
 {
-    private double[] uniqueValue;
+    private Object[] uniqueValue;
     
     private String[] cols;
     
@@ -43,7 +43,7 @@ public class SliceUniqueValueInfo
      * getUniqueValue
      * @return double[]
      */
-    public double[] getUniqueValue()
+    public Object[] getUniqueValue()
     {
         return uniqueValue;
     }
@@ -52,7 +52,7 @@ public class SliceUniqueValueInfo
      * setUniqueValue
      * @param uniqueValue1 void
      */
-    public void setUniqueValue(double[] uniqueValue1)
+    public void setUniqueValue(Object[] uniqueValue1)
     {
         this.uniqueValue = uniqueValue1;
     }
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/util/DataTypeConverter.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/util/DataTypeConverter.java
index 5a4c04d..a57d105 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/util/DataTypeConverter.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/util/DataTypeConverter.java
@@ -49,6 +49,7 @@ public final class DataTypeConverter
                 }
                 return Double.parseDouble(data);
             case LONG:
+            case BIGINT:
                 if(data.isEmpty())
                 {
                     return null;
@@ -79,6 +80,15 @@ public final class DataTypeConverter
                     LOGGER.error(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, "Cannot convert" + TIMESTAMP.toString() + " to Time/Long type value"+e.getMessage());
                     return null;
                 }
+            case DECIMAL:
+                if(data.isEmpty())
+                {
+                    return null;
+                }
+                java.math.BigDecimal javaDecVal = new java.math.BigDecimal(data);
+                scala.math.BigDecimal scalaDecVal = new scala.math.BigDecimal(javaDecVal);
+                org.apache.spark.sql.types.Decimal decConverter = new org.apache.spark.sql.types.Decimal();
+                return decConverter.set(scalaDecVal);
             default:
                 return data;
         }
@@ -97,5 +107,45 @@ public final class DataTypeConverter
         }
 
     }
-    
-}
+
+    public static Object getMeasureDataBasedOnDataType(Object data, SqlStatement.Type dataType)
+    {
+
+        if(null==data)
+        {
+            return null;
+        }
+        try
+        {
+            switch(dataType)
+            {
+//                case INT:
+//
+//                    return (Integer)data;
+                case DOUBLE:
+
+                    return (Double)data;
+//                case LONG:
+                case BIGINT:
+
+                    return (Long)data;
+
+                case DECIMAL:
+
+                    java.math.BigDecimal javaDecVal = new java.math.BigDecimal(data.toString());
+                    scala.math.BigDecimal scalaDecVal = new scala.math.BigDecimal(javaDecVal);
+                    org.apache.spark.sql.types.Decimal decConverter = new org.apache.spark.sql.types.Decimal();
+                    return decConverter.set(scalaDecVal);
+                default:
+                    return data;
+            }
+        }
+        catch(NumberFormatException ex)
+        {
+            LOGGER.error(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, "Problem while converting data type"+data);
+            return null;
+        }
+
+    }
+
+}
\ No newline at end of file
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/util/QueryExecutorUtility.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/util/QueryExecutorUtility.java
index 3c484c8..362e6d2 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/util/QueryExecutorUtility.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/util/QueryExecutorUtility.java
@@ -1,8 +1,8 @@
 package com.huawei.unibi.molap.engine.util;
 
+import java.math.BigDecimal;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
@@ -13,10 +13,7 @@ import java.util.TreeSet;
 
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.engine.aggregator.dimension.DimensionAggregatorInfo;
-import com.huawei.unibi.molap.engine.complex.querytypes.ArrayQueryType;
-import com.huawei.unibi.molap.engine.complex.querytypes.GenericQueryType;
-import com.huawei.unibi.molap.engine.complex.querytypes.PrimitiveQueryType;
-import com.huawei.unibi.molap.engine.complex.querytypes.StructQueryType;
+import com.huawei.unibi.molap.engine.aggregator.util.AggUtil;
 import com.huawei.unibi.molap.engine.datastorage.CubeDataStore;
 import com.huawei.unibi.molap.engine.datastorage.InMemoryCube;
 import com.huawei.unibi.molap.engine.datastorage.Member;
@@ -25,20 +22,10 @@ import com.huawei.unibi.molap.engine.executer.exception.QueryExecutionException;
 import com.huawei.unibi.molap.engine.schema.metadata.SliceUniqueValueInfo;
 import com.huawei.unibi.molap.keygenerator.KeyGenException;
 import com.huawei.unibi.molap.keygenerator.KeyGenerator;
-import com.huawei.unibi.molap.keygenerator.columnar.impl.MultiDimKeyVarLengthEquiSplitGenerator;
 import com.huawei.unibi.molap.metadata.MolapMetadata;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Measure;
 import com.huawei.unibi.molap.metadata.SliceMetaData;
-import com.huawei.unibi.molap.olap.MolapDef;
-import com.huawei.unibi.molap.olap.MolapDef.Cube;
-import com.huawei.unibi.molap.olap.MolapDef.CubeDimension;
-import com.huawei.unibi.molap.olap.MolapDef.Hierarchy;
-import com.huawei.unibi.molap.olap.MolapDef.Level;
-import com.huawei.unibi.molap.olap.MolapDef.Schema;
-import com.huawei.unibi.molap.olap.SqlStatement.Type;
-import com.huawei.unibi.molap.olap.SqlStatement;
-import com.huawei.unibi.molap.util.MolapUtil;
 
 public final class QueryExecutorUtility
 {
@@ -47,13 +34,13 @@ public final class QueryExecutorUtility
     {
         
     }
-    public static double[] updateUniqueForSlices(String factTable,boolean isAgg,
+    public static Object[] updateUniqueForSlices(String factTable,boolean isAgg,
             List<InMemoryCube> slices)
     {
         List<SliceUniqueValueInfo> sliceUniqueValueInfos = new ArrayList<SliceUniqueValueInfo>(
                 null != slices ? slices.size() : 0);
         
-        double[] uniqueValue = null;
+        Object[] uniqueValue = null;
         processUniqueAndMinValueInfo(factTable, sliceUniqueValueInfos, true, isAgg, slices);
         if(sliceUniqueValueInfos.size() > 0)
         {
@@ -62,13 +49,13 @@ public final class QueryExecutorUtility
         return uniqueValue;
     }
     
-    public static double[] getMinValueOfSlices(String factTable, boolean isAgg,
+    public static Object[] getMinValueOfSlices(String factTable, boolean isAgg,
             List<InMemoryCube> slices)
     {
         List<SliceUniqueValueInfo> sliceMinValueInfos = new ArrayList<SliceUniqueValueInfo>(
                 null != slices ? slices.size() : 0);
         processUniqueAndMinValueInfo(factTable, sliceMinValueInfos, false, isAgg, slices);
-        double[] minValues = new double[0];
+        Object[] minValues = new Object[0];
         if(sliceMinValueInfos.size() > 0)
         {
             minValues = mergerSliceUniqueValueInfo(sliceMinValueInfos);
@@ -89,7 +76,7 @@ public final class QueryExecutorUtility
             if(null != dataCache)
             {
                 sliceMataData = slices.get(i).getRsStore().getSliceMetaCache(factTable);
-                double[] currentUniqueValue = null;
+                Object[] currentUniqueValue = null;
                 if(uniqueValue)
                 {
                     currentUniqueValue = slices.get(i).getDataCache(factTable).getUniqueValue();
@@ -119,7 +106,7 @@ public final class QueryExecutorUtility
      * @param sliceUniqueValueInfos
      * 
      */
-    private static double[] mergerSliceUniqueValueInfo(List<SliceUniqueValueInfo> sliceUniqueValueInfos)
+    private static Object[] mergerSliceUniqueValueInfo(List<SliceUniqueValueInfo> sliceUniqueValueInfos)
     {
         int maxInfoIndex = 0;
         int lastMaxValue = 0;
@@ -132,9 +119,9 @@ public final class QueryExecutorUtility
             }
         }
         SliceUniqueValueInfo sliceUniqueValueInfo = sliceUniqueValueInfos.get(maxInfoIndex);
-        double[] maxSliceUniqueValue = sliceUniqueValueInfo.getUniqueValue();
+        Object[] maxSliceUniqueValue = sliceUniqueValueInfo.getUniqueValue();
         String[] cols = null;
-        double[] currentUniqueValue = null;
+        Object[] currentUniqueValue = null;
         for(int i = 0;i < sliceUniqueValueInfos.size();i++)
         {
             if(i == maxInfoIndex)
@@ -145,8 +132,20 @@ public final class QueryExecutorUtility
             currentUniqueValue = sliceUniqueValueInfos.get(i).getUniqueValue();
             for(int j = 0;j < cols.length;j++)
             {
-                maxSliceUniqueValue[j] = maxSliceUniqueValue[j] > currentUniqueValue[j] ? currentUniqueValue[j]
-                        : maxSliceUniqueValue[j];
+                switch(AggUtil.getMeasureType(j))
+                {
+                    case BIGINT:
+                        maxSliceUniqueValue[j] = (long)maxSliceUniqueValue[j] > (long)currentUniqueValue[j] ? currentUniqueValue[j]
+                                : maxSliceUniqueValue[j];
+                        break;
+                    case  DECIMAL:
+                        maxSliceUniqueValue[j] = ((BigDecimal)maxSliceUniqueValue[j]).compareTo((BigDecimal)currentUniqueValue[j]) > 0 ? currentUniqueValue[j]
+                                : maxSliceUniqueValue[j];
+                        break;
+                    default:
+                        maxSliceUniqueValue[j] = (double)maxSliceUniqueValue[j] > (double)currentUniqueValue[j] ? currentUniqueValue[j]
+                                : maxSliceUniqueValue[j];
+                }
             }
         }
         return maxSliceUniqueValue;
@@ -295,10 +294,6 @@ public final class QueryExecutorUtility
         for(int i = 0;i < queryDimensions.length;i++)
         {
             Set<Integer> integers = new TreeSet<Integer>();
-            if(queryDimensions[i].isHighCardinalityDim())
-            {
-                continue;
-            }
             int[] range = generator.getKeyByteOffsets(queryDimensions[i].getOrdinal());
             for(int j = range[0];j <= range[1];j++)
             {
@@ -313,16 +308,10 @@ public final class QueryExecutorUtility
             }
             index++;
         }
-
+        
         for(int i = 0;i < dimensionCompareIndex.length;i++)
         {
-            if(null == dimensionCompareIndex[i])
-            {
-                continue;
-            }
             int[] range = dimensionCompareIndex[i];
-            if(null!=range)
-            {
             for(int j = 0;j < range.length;j++)
             {
                 for(int k = 0;k < maskedRanges.length;k++)
@@ -336,8 +325,6 @@ public final class QueryExecutorUtility
             }
         }
         
-       }
-        
         return dimensionCompareIndex;
     }
     
@@ -350,29 +337,21 @@ public final class QueryExecutorUtility
         byte[] maskedMdKey = null;
         try
         {
-            if(null != dimensionCompareIndex)
-            {
         for(int i = 0;i < dimensionCompareIndex.length;i++)
         {
-            if(null == dimensionCompareIndex[i])
-            {
-                continue;
-            }
             key = new long[generator.getDimCount()];
-                    maskedKey[i] = new byte[dimensionCompareIndex[i].length];
+            maskedKey[i]=new byte[dimensionCompareIndex[i].length];
             key[queryDimensions[i].getOrdinal()] = Long.MAX_VALUE;
             mdKey = generator.generateKey(key);
             maskedMdKey = new byte[maskedRanges.length];
             for(int k = 0;k < maskedMdKey.length;k++)
-                    { // CHECKSTYLE:OFF Approval No:Approval-V1R2C10_001
+            {      //CHECKSTYLE:OFF    Approval No:Approval-V1R2C10_001
                 maskedMdKey[k] = mdKey[maskedRanges[k]];
             }
             for(int j = 0;j < dimensionCompareIndex[i].length;j++)
             {
-                        maskedKey[i][j] = maskedMdKey[dimensionCompareIndex[i][j]];
-                    }// CHECKSTYLE:ON
-                    
-        }
+                maskedKey[i][j]=maskedMdKey[dimensionCompareIndex[i][j]];
+            }//CHECKSTYLE:ON
         }
         }
         catch(KeyGenException e)
@@ -385,182 +364,27 @@ public final class QueryExecutorUtility
     //@TODO need to handle for restructuring scenario 
     public static int[] getSelectedDimnesionIndex(Dimension[] queryDims)
     {
-//        int[] selectedDimsIndex= new int[queryDims.length];
-//        for(int i = 0;i < queryDims.length;i++)
-//        {
-//            selectedDimsIndex[i]=queryDims[i].getOrdinal();
-//        }
-//        Arrays.sort(selectedDimsIndex);
-//        return selectedDimsIndex;
-        // updated for block index size with complex types
-        Set<Integer> allQueryDimension = new HashSet<Integer>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
+        int[] selectedDimsIndex= new int[queryDims.length];
         for(int i = 0;i < queryDims.length;i++)
         {
-            if(queryDims[i].getAllApplicableDataBlockIndexs().length > 1)
-            {
-                for(int eachBlockIndex : queryDims[i].getAllApplicableDataBlockIndexs())
-                {
-                    allQueryDimension.add(eachBlockIndex);
-                }
-            }
-            else
-            {
-                allQueryDimension.add(queryDims[i].getOrdinal());
-            }
-        }
-        return convertIntegerArrayToInt(allQueryDimension.toArray(new Integer[allQueryDimension.size()]));
-    }
-    
-    public static Map<Integer, GenericQueryType> getQueryComplexTypes(
-            Dimension[] queryDimensions, Map<String, GenericQueryType> complexDimensionsMap)
-    {
-        Map<Integer, GenericQueryType> queryComplexMap = new HashMap<Integer, GenericQueryType>();
-        for(Dimension d : queryDimensions)
-        {
-            GenericQueryType complexType = complexDimensionsMap.get(d.getHierName());
-            if(complexType != null)
-            {
-                queryComplexMap.put(d.getDataBlockIndex(), complexDimensionsMap.get(d.getHierName()));
-            }
-        }
-        return queryComplexMap;
-    }
-    
-    public static Map<Integer, GenericQueryType> getAllComplexTypesBlockStartIndex(
-           Map<String, GenericQueryType> complexDimensionsMap)
-    {
-        Map<Integer, GenericQueryType> queryComplexMap = new HashMap<Integer, GenericQueryType>();
-        for(Map.Entry<String, GenericQueryType> d : complexDimensionsMap.entrySet())
-        {
-                queryComplexMap.put(d.getValue().getBlockIndex(), d.getValue());
-        }
-        return queryComplexMap;
-    }
-    
-    /**
-     * @param cube
-     * @return
-     */
-    public static Map<String,GenericQueryType> getComplexDimensionsMap(Dimension[] currentDimTables)
-    {  
-        Map<String,GenericQueryType> complexTypeMap = new HashMap<String,GenericQueryType>();
-        
-        Map<String, ArrayList<Dimension>> complexDimensions = new HashMap<String, ArrayList<Dimension>>();
-        for(int i = 0;i < currentDimTables.length;i++)
-        {
-            ArrayList<Dimension> dimensions = complexDimensions.get(currentDimTables[i].getHierName());
-            if(dimensions != null)
-            {
-                dimensions.add(currentDimTables[i]);
-            }
-            else
-            {
-                dimensions = new ArrayList<Dimension>();
-                dimensions.add(currentDimTables[i]);
-            }
-            complexDimensions.put(currentDimTables[i].getHierName(), dimensions);
-        }
-        for (Map.Entry<String, ArrayList<Dimension>> entry : complexDimensions.entrySet())
-        {
-            if(entry.getValue().size() > 1)
-            {
-                Dimension dimZero = entry.getValue().get(0);
-                GenericQueryType g = dimZero.getDataType().equals(SqlStatement.Type.ARRAY)?
-                        new ArrayQueryType(dimZero.getColName(), "", dimZero.getDataBlockIndex()):new StructQueryType(dimZero.getColName(), "", dimZero.getDataBlockIndex());
-                complexTypeMap.put(dimZero.getColName(), g);
-                for(int i=1;i<entry.getValue().size();i++)
-                {
-                    Dimension dim = entry.getValue().get(i);
-                    switch(dim.getDataType())
-                    {
-                        case ARRAY : 
-                            g.addChildren(new ArrayQueryType(dim.getColName(), dim.getParentName(), dim.getDataBlockIndex()));
-                            break;
-                        case STRUCT : 
-                            g.addChildren(new StructQueryType(dim.getColName(), dim.getParentName(), dim.getDataBlockIndex()));
-                            break;
-                        default :
-                            g.addChildren(new PrimitiveQueryType(dim.getColName(), dim.getParentName(), dim.getDataBlockIndex(), dim.getDataType()));
-                    }
-                }
-            }
-        }
-        
-        return complexTypeMap;
-    }
-    
-    public static void getComplexDimensionsKeySize(Map<String, GenericQueryType> complexDimensionsMap, int[] dimensionCardinality)
-    {
-        int keyBlockSize[] = new MultiDimKeyVarLengthEquiSplitGenerator(
-                MolapUtil.getIncrementedCardinalityFullyFilled(dimensionCardinality), (byte)1)
-                .getBlockKeySize();
-        for (Map.Entry<String, GenericQueryType> entry : complexDimensionsMap.entrySet())
-        {
-            entry.getValue().setKeySize(keyBlockSize);
-        }
-    }
-    
-    public static Map<String, Integer> getComplexQueryIndexes(Dimension[] queryDims, Dimension[] currentDimTables)
-    {
-        Map<String, Integer> colToDataMap = new HashMap<String, Integer>();
-        boolean[] dimPresent = new boolean[currentDimTables.length];
-        for(Dimension queryDim : queryDims)
-        {
-            for(int i=0;i<currentDimTables.length;i++)
-            {
-                if(currentDimTables[i].getColName().equals(queryDim.getColName()) && 
-                        (currentDimTables[i].getDataType() == Type.ARRAY || 
-                        currentDimTables[i].getDataType() == Type.STRUCT))
-                {
-                    dimPresent[i] = true;
-                    break;
-                }
-            }
-        }
-        int index=0;
-        for(int i=0;i<dimPresent.length;i++)
-        {
-            if(dimPresent[i] == true)
-            {
-                colToDataMap.put(currentDimTables[i].getColName(), index++);
-            }
+            selectedDimsIndex[i]=queryDims[i].getOrdinal();
         }
-        return colToDataMap;
+        Arrays.sort(selectedDimsIndex);
+        return selectedDimsIndex;
     }
     
     public static int[] getAllSelectedDiemnsion(Dimension[] queryDims, List<DimensionAggregatorInfo> dimAggInfo, List<Dimension> fromCustomExps)
     {
-        //Updated to get multiple column blocks for complex types
         Set<Integer> allQueryDimension = new HashSet<Integer>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
         for(int i = 0;i < queryDims.length;i++)
         {
-            if(queryDims[i].getAllApplicableDataBlockIndexs().length > 1)
-            {
-                for(int eachBlockIndex : queryDims[i].getAllApplicableDataBlockIndexs())
-                {
-                    allQueryDimension.add(eachBlockIndex);
-                }
-            }
-            else
-            {
-                allQueryDimension.add(queryDims[i].getOrdinal());
-            }
+            allQueryDimension.add(queryDims[i].getOrdinal());
         }
         for(int i=0;i<dimAggInfo.size();i++)
         {
             if(dimAggInfo.get(i).isDimensionPresentInCurrentSlice())
             {
-                if(dimAggInfo.get(i).getDim().getAllApplicableDataBlockIndexs().length > 1)
-                {
-                    for(int eachBlockIndex : dimAggInfo.get(i).getDim().getAllApplicableDataBlockIndexs())
-                    {
-                        allQueryDimension.add(eachBlockIndex);
-                    }
-                }
-                else
-                {
-                    allQueryDimension.add(dimAggInfo.get(i).getDim().getOrdinal());
-                }
+                allQueryDimension.add(dimAggInfo.get(i).getDim().getOrdinal());
             }
         }
         
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/util/ScannedResultProcessorUtil.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/util/ScannedResultProcessorUtil.java
index 26fa1ca..070069a 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/util/ScannedResultProcessorUtil.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/util/ScannedResultProcessorUtil.java
@@ -62,15 +62,8 @@ public final class ScannedResultProcessorUtil
         int length = maskedByteRangeForSorting.length;
         for(int i = 0;i < length;i++)
         {
-            if(null==maskedByteRangeForSorting[i])
-            {
-                keyComparator=new MaksedByteComparatorBAW(dimensionSortOrder[i]);
-                compratorList.add(keyComparator);
-                continue;
-            }
             keyComparator = new MaksedByteComparatorBAW(maskedByteRangeForSorting[i], dimensionSortOrder[i],
                     dimensionMasks[i]);
-
             compratorList.add(keyComparator);
         }
         return new ComparatorChain(compratorList);
@@ -121,24 +114,15 @@ public final class ScannedResultProcessorUtil
                     long[] keyArray = keyGenerator.getKeyArray(maskedKey, dataProcessorInfo.getMaskedByteRange());
                     for(int i = 0;i < queryDimension.length;i++)
                     { // CHECKSTYLE:OFF Approval No:Approval-V1R2C10_006
-                     
-                        if(queryDimension[i].isHighCardinalityDim())
-                        {
-                            continue;
-                        }
                         if(sortedDimensionIndex[i] == 1)
                         {
                             keyArray[queryDimension[i].getOrdinal()] = getSortIndexById(dimensionUniqueNames[i],
                                     (int)keyArray[queryDimension[i].getOrdinal()], dataProcessorInfo.getSlices());
                         }
                     }// CHECKSTYLE:ON
-                    List<byte[]> listOfDirectSurrogates=key.getDirectSurrogateKeyList();
                     key = new ByteArrayWrapper();
-                    key.addToDirectSurrogateKeyList(listOfDirectSurrogates);
                     key.setMaskedKey(getMaskedKey(keyGenerator.generateKey(keyArray), dataProcessorInfo));
                 }
-                
-                
                 holderArray[k++] = new KeyValueHolder(key, scannedResult.getValue());
             }
         }
@@ -163,10 +147,7 @@ public final class ScannedResultProcessorUtil
         }
         else
         {
-            if(null != comparator)
-            {
-                Arrays.sort(holderArray, comparator);
-            }
+            Arrays.sort(holderArray, comparator);
         }
         return holderArray;
     }
@@ -256,9 +237,9 @@ public final class ScannedResultProcessorUtil
         dataProcessorInfo.setDimensionMasks(info.getDimensionMaskKeys());
         dataProcessorInfo.setQueryId(info.getQueryId());
         dataProcessorInfo.setAggType(info.getAggType());
-        dataProcessorInfo.setHighCardinalityTypes(info.getHighCardinalityTypes());
         dataProcessorInfo.setMsrMinValue(info.getMsrMinValue());
         dataProcessorInfo.setSortedDimensionIndex(info.getSortedDimensionsIndex());
+        dataProcessorInfo.setDataTypes(info.getDataTypes());
         return dataProcessorInfo;
     }
 
@@ -278,10 +259,6 @@ public final class ScannedResultProcessorUtil
         MaksedByteComparatorForReader keyComparator = null;
         for(int i = 0;i < maskedByteRangeForSorting.length;i++)
         {
-            if(null==maskedByteRangeForSorting[i])
-            {
-                continue;
-            }
             keyComparator = new MaksedByteComparatorForReader(maskedByteRangeForSorting[i], dimensionSortOrder[i],
                     dimensionMasks[i]);
             compratorList.add(keyComparator);
diff --git a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/wrappers/ByteArrayWrapper.java b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/wrappers/ByteArrayWrapper.java
index ea320bc..63664f2 100644
--- a/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/wrappers/ByteArrayWrapper.java
+++ b/Molap/Molap-Engine/src/com/huawei/unibi/molap/engine/wrappers/ByteArrayWrapper.java
@@ -11,12 +11,9 @@ l1Jrt6XPgVywOm6Dl9p2gEmKGHgwkat6K76P8eN4GIthTQXpzx24paUWoNIs3Q==*/
 package com.huawei.unibi.molap.engine.wrappers;
 
 import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.List;
 
 import net.jpountz.xxhash.XXHash32;
 
-import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.util.ByteUtil.UnsafeComparer;
 
 
@@ -51,39 +48,13 @@ public class ByteArrayWrapper implements Comparable<ByteArrayWrapper>,Serializab
      */
     protected byte[] maskedKey;
 
-
-
-
-    private byte[] directSurrogateVal;
-    
-    List<byte[]> listOfDirectSurrogateVal;
-
-    protected List<byte[]> complexTypesData;
-    
     public ByteArrayWrapper()
     {
-        this.complexTypesData = new ArrayList<byte[]>();
     }
     
     public ByteArrayWrapper(XXHash32 xxHash32)
     {
        this.xxHash32 = xxHash32;
-       this.complexTypesData = new ArrayList<byte[]>();
-    }
-    
-    public byte[] getComplexTypeData(int index)
-    {
-        return complexTypesData.get(index);
-    }
-    
-    public List<byte[]> getCompleteComplexTypeData()
-    {
-        return complexTypesData;
-    }
-    
-    public void addComplexTypeData(byte[] data)
-    {
-        complexTypesData.add(data);
     }
 
     /**
@@ -191,17 +162,6 @@ public class ByteArrayWrapper implements Comparable<ByteArrayWrapper>,Serializab
         {
             result = 31 * result + maskedKey[j];
         }
-        if(null!=listOfDirectSurrogateVal)
-        {
-            int index=0;
-            for(byte[] directSurrogateValue:listOfDirectSurrogateVal)
-            {
-                for(int i=0;i<directSurrogateValue.length;i++)
-                {
-                result = 31 * result + directSurrogateValue[i];
-                }
-            }
-        }
         return result;
     }
 
@@ -216,40 +176,13 @@ public class ByteArrayWrapper implements Comparable<ByteArrayWrapper>,Serializab
      */
     public boolean equals(Object other)
     {
-
-        if(null == other || !(other instanceof ByteArrayWrapper))
-        {
+ 
+        if(null==other ||!(other instanceof ByteArrayWrapper)){
             return false;
         }
-        boolean result = false;
-        // High cardinality dimension rows has been added in list of
-        // ByteArrayWrapper, so
-        // the same has to be compared to know whether the byte array wrappers
-        // are equals or not.
-        List<byte[]> otherList = ((ByteArrayWrapper)other).getDirectSurrogateKeyList();
-        if(null != listOfDirectSurrogateVal)
-        {
-            if(listOfDirectSurrogateVal.size() != otherList.size())
-            {
-                return false;
-            }
-            else
-            {
-                for(int i = 0;i < listOfDirectSurrogateVal.size();i++)
-                {
-                    result = UnsafeComparer.INSTANCE.equals(listOfDirectSurrogateVal.get(i), otherList.get(i));
-                    if(!result)
-                    {
-                        return false;
-                    }
-                }
-            }
-
-        }
-        return UnsafeComparer.INSTANCE.equals(maskedKey, ((ByteArrayWrapper)other).maskedKey);
-    }
-
-
+ 
+         return UnsafeComparer.INSTANCE.equals(maskedKey, ((ByteArrayWrapper)other).maskedKey);
+      }
 
     /**
      * Compare method for ByteArrayWrapper class this will used to compare Two
@@ -263,23 +196,8 @@ public class ByteArrayWrapper implements Comparable<ByteArrayWrapper>,Serializab
     @Override
     public int compareTo(ByteArrayWrapper other)
     {
-        int compareTo = UnsafeComparer.INSTANCE.compareTo(maskedKey, other.maskedKey);
-        if(compareTo == 0)
-        {
-            if(null != listOfDirectSurrogateVal)
-            {
-                for(int i = 0;i < listOfDirectSurrogateVal.size();i++)
-                {
-                    compareTo = UnsafeComparer.INSTANCE.compareTo(listOfDirectSurrogateVal.get(i),
-                            other.listOfDirectSurrogateVal.get(i));
-                    if(compareTo != 0)
-                    {
-                        return compareTo;
-                    }
-                }
-            }
-        }
-        return compareTo;
+        return UnsafeComparer.INSTANCE.compareTo(maskedKey, other.maskedKey);
+        //return ByteUtil.compare(maskedKey, other.maskedKey);
     }
 
     public byte[] getMaskedKey()
@@ -291,54 +209,4 @@ public class ByteArrayWrapper implements Comparable<ByteArrayWrapper>,Serializab
     {
         this.maskedKey = maskedKey;
     }
-    
-
-    /**
-     * addToDirectSurrogateKeyList
-     * @param directSurrKeyData
-     */
-    public void addToDirectSurrogateKeyList(byte[] directSurrKeyData)
-    {
-        if(null == listOfDirectSurrogateVal)
-        {
-            listOfDirectSurrogateVal = new ArrayList<byte[]>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
-            listOfDirectSurrogateVal.add(directSurrKeyData);
-        }
-        else
-        {
-            listOfDirectSurrogateVal.add(directSurrKeyData);
-        }
-
-    }
-    
-    /**
-     * addToDirectSurrogateKeyList
-     * @param directSurrKeyData
-     */
-    public void addToDirectSurrogateKeyList(List<byte[]> directSurrKeyData)
-    {
-        //Add if any direct surrogates are really present.
-        if(null != directSurrKeyData && !directSurrKeyData.isEmpty())
-        {
-            if(null == listOfDirectSurrogateVal)
-            {
-                listOfDirectSurrogateVal = new ArrayList<byte[]>(MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
-                listOfDirectSurrogateVal.addAll(directSurrKeyData);
-            }
-            else
-            {
-                listOfDirectSurrogateVal.addAll(directSurrKeyData);
-            }
-        }
-
-    }
-    
-    /**
-     * 
-     * @return
-     */
-    public List<byte[]> getDirectSurrogateKeyList()
-    {
-        return listOfDirectSurrogateVal;
-    }
 }
diff --git a/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/load/DeleteLoadFolders.java b/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/load/DeleteLoadFolders.java
index 3e269ef..f46c6f4 100644
--- a/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/load/DeleteLoadFolders.java
+++ b/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/load/DeleteLoadFolders.java
@@ -82,30 +82,16 @@ public final class DeleteLoadFolders
                             path = LoadMetadataUtil.createLoadFolderPath(
                                     loadModel, storeLocation, partitionId,
                                     restructureFolderNum);
-                            String loadFolderPath = "";
-                            // deleting merged load folder
-                            if(oneLoad.getMergedLoadName() != null)
-                            {
-                                loadFolderPath = path
-                                        + MolapCommonConstants.FILE_SEPARATOR
-                                        + MolapCommonConstants.LOAD_FOLDER
-                                        + oneLoad.getMergedLoadName();
-                                deletionStatus = physicalFactAndMeasureMetadataDeletion(loadFolderPath);
-                            }
-                            else
-                            {
-                                loadFolderPath = path
-                                        + MolapCommonConstants.FILE_SEPARATOR
-                                        + MolapCommonConstants.LOAD_FOLDER
-                                        + oneLoad.getLoadName();
-                                deletionStatus = physicalFactAndMeasureMetadataDeletion(loadFolderPath);
-                            }
+                            String loadFolderPath = path
+                                    + MolapCommonConstants.FILE_SEPARATOR
+                                    + MolapCommonConstants.LOAD_FOLDER
+                                    + oneLoad.getLoadName();
+                            deletionStatus = physicalFactAndMeasureMetadataDeletion(loadFolderPath);
                             if(deletionStatus)
                             {
                                 cleanDeletedFactFile(loadFolderPath);
                                 factFileRenaming(loadFolderPath);
-                                // if deletion status is True then there is no
-                                // need to traverse all the RS folders.
+                                // if deletion status is True then there is no need to traverse all the RS folders.
                                 break;
                             }
                         }
@@ -132,7 +118,7 @@ public final class DeleteLoadFolders
      * @param aggFiles
      * @param loadName
      */
-    public static void deleteAggLoadFolders(MolapFile[] aggFiles, String loadName) 
+    private static void deleteAggLoadFolders(MolapFile[] aggFiles, String loadName) 
     {
     	for(MolapFile file : aggFiles)
     	{
@@ -167,18 +153,17 @@ public final class DeleteLoadFolders
         {
             MolapFile[] files = loadFolder.listFiles();
             // deleting individual files
-            if(files != null)
+            if(files!=null){
+            for(MolapFile eachFile : files)
             {
-                for(MolapFile eachFile : files)
+                if(!eachFile.delete())
                 {
-                    if(!eachFile.delete())
-                    {
-                        LOGGER.warn(MolapCoreLogEvent.UNIBI_MOLAPCORE_MSG,
-                                "Unable to delete the file as per delete command "
-                                        + loadFolder.getAbsolutePath());
-                    }
+                    LOGGER.warn(MolapCoreLogEvent.UNIBI_MOLAPCORE_MSG,
+                            "Unable to delete the file as per delete command "
+                                    + loadFolder.getAbsolutePath());
                 }
             }
+            }
 
         }
 
@@ -364,10 +349,6 @@ public final class DeleteLoadFolders
 
     }
     
-    /**
-     * deletes the fact file which is marked as _deleted
-     * @param loadFolderPath
-     */
     private static void cleanDeletedFactFile(String loadFolderPath)
     {
         FileFactory.FileType fileType = FileFactory.getFileType(loadFolderPath);
diff --git a/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/load/DeleteLoadFromMetadata.java b/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/load/DeleteLoadFromMetadata.java
index f538889..372b2a2 100644
--- a/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/load/DeleteLoadFromMetadata.java
+++ b/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/load/DeleteLoadFromMetadata.java
@@ -23,9 +23,6 @@ import com.huawei.datasight.molap.spark.util.MolapSparkInterFaceLogEvent;
 import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
-import com.huawei.unibi.molap.datastorage.store.fileperations.AtomicFileOperations;
-import com.huawei.unibi.molap.datastorage.store.fileperations.AtomicFileOperationsImpl;
-import com.huawei.unibi.molap.datastorage.store.fileperations.FileWriteOperation;
 import com.huawei.unibi.molap.datastorage.store.impl.FileFactory;
 import com.huawei.unibi.molap.locks.MetadataLock;
 import com.huawei.unibi.molap.locks.MolapLock;
@@ -52,6 +49,7 @@ public final class DeleteLoadFromMetadata
     {
         MolapLock molapLock = new MetadataLock(cubeFolderPath);
         BufferedWriter brWriter = null;
+        DataInputStream dataInputStream = null;
         List<String> invalidLoadIds = new ArrayList<String>(0);
         try
         {
@@ -92,17 +90,11 @@ public final class DeleteLoadFromMetadata
                                 "Load doesnt exist or it is already deleted , LoadSeqId-"+invalidLoadIds);
                     }
 
-                    AtomicFileOperations fileWrite = new AtomicFileOperationsImpl(dataLoadLocation, FileFactory.getFileType(dataLoadLocation));
-                    
                     // write the updated data into the metadata file.
-                    
-                    try
-                    {
-                    dataOutputStream = fileWrite.openForWrite(FileWriteOperation.OVERWRITE);
-                    
-                   /* dataOutputStream = FileFactory.getDataOutputStream(
+
+                    dataOutputStream = FileFactory.getDataOutputStream(
                             dataLoadLocation,
-                            FileFactory.getFileType(dataLoadLocation));*/
+                            FileFactory.getFileType(dataLoadLocation));
                     brWriter = new BufferedWriter(
                             new OutputStreamWriter(
                                     dataOutputStream,
@@ -111,18 +103,6 @@ public final class DeleteLoadFromMetadata
                     String metadataInstance = gsonObjectToWrite
                             .toJson(listOfLoadFolderDetailsArray);
                     brWriter.write(metadataInstance);
-                    }
-                    finally
-                    {
-                        if(null != brWriter)
-                        {
-                            brWriter.flush();
-                        }
-                        MolapUtil.closeStreams(brWriter);
-                    }
-                    
-                    fileWrite.close();
-                    
                 }
                 else
                 {
@@ -146,6 +126,24 @@ public final class DeleteLoadFromMetadata
         finally
         {
             fileUnlock(molapLock);
+
+            try
+            {
+                if(null != brWriter)
+                {
+                    brWriter.flush();
+                }
+            }
+            catch(IOException e)
+            {
+                LOGGER.info(MolapCoreLogEvent.UNIBI_MOLAPCORE_MSG,"errorn while  flushing");
+            }            
+            finally
+            {
+            	 MolapUtil.closeStreams(brWriter,dataInputStream);              
+            	
+            }
+        
         }
         
         return invalidLoadIds;
diff --git a/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/load/MolapLoadModel.java b/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/load/MolapLoadModel.java
index e5e7133..6bbd2cc 100644
--- a/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/load/MolapLoadModel.java
+++ b/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/load/MolapLoadModel.java
@@ -60,9 +60,6 @@ public class MolapLoadModel implements Serializable
 	private List<String> factFilesToProcess;
 	private String csvHeader;
 	private String csvDelimiter;
-	private String complexDelimiterLevel1;
-	private String complexDelimiterLevel2;
-	
 	private boolean isDirectLoad;
 	
 	public String getCsvDelimiter() {
@@ -72,22 +69,6 @@ public class MolapLoadModel implements Serializable
 	public void setCsvDelimiter(String csvDelimiter) {
 		this.csvDelimiter = csvDelimiter;
 	}
-	
-	public String getComplexDelimiterLevel1() {
-		return complexDelimiterLevel1;
-	}
-
-	public void setComplexDelimiterLevel1(String complexDelimiterLevel1) {
-		this.complexDelimiterLevel1 = complexDelimiterLevel1;
-	}
-
-	public String getComplexDelimiterLevel2() {
-		return complexDelimiterLevel2;
-	}
-
-	public void setComplexDelimiterLevel2(String complexDelimiterLevel2) {
-		this.complexDelimiterLevel2 = complexDelimiterLevel2;
-	}
 
 	public boolean isDirectLoad() {
 		return isDirectLoad;
@@ -293,8 +274,6 @@ public class MolapLoadModel implements Serializable
 		copy.aggLoadRequest = aggLoadRequest;
 		copy.loadMetadataDetails = loadMetadataDetails;
 		copy.isRetentionRequest = isRetentionRequest;
-		copy.complexDelimiterLevel1 = complexDelimiterLevel1;
-		copy.complexDelimiterLevel2 = complexDelimiterLevel2;
 		if(uniqueId != null && schema!=null)
         {
             String originalSchemaName = schema.name;
@@ -338,8 +317,6 @@ public class MolapLoadModel implements Serializable
 		copyObj.factFilesToProcess = filesForPartition;
 		copyObj.isDirectLoad = true;
 		copyObj.csvDelimiter = delimiter;
-		copyObj.complexDelimiterLevel1 = complexDelimiterLevel1;
-		copyObj.complexDelimiterLevel2 = complexDelimiterLevel2;
 		return copyObj;
 	}
 
diff --git a/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/load/MolapLoaderUtil.java b/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/load/MolapLoaderUtil.java
index 3bce11c..dfb97c5 100644
--- a/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/load/MolapLoaderUtil.java
+++ b/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/load/MolapLoaderUtil.java
@@ -44,9 +44,6 @@ import com.huawei.unibi.molap.constants.MolapCommonConstants;
 import com.huawei.unibi.molap.csvload.DataGraphExecuter;
 import com.huawei.unibi.molap.dataprocessor.DataProcessTaskStatus;
 import com.huawei.unibi.molap.dataprocessor.IDataProcessStatus;
-import com.huawei.unibi.molap.datastorage.store.fileperations.AtomicFileOperations;
-import com.huawei.unibi.molap.datastorage.store.fileperations.AtomicFileOperationsImpl;
-import com.huawei.unibi.molap.datastorage.store.fileperations.FileWriteOperation;
 import com.huawei.unibi.molap.datastorage.store.filesystem.MolapFile;
 import com.huawei.unibi.molap.datastorage.store.filesystem.MolapFileFilter;
 import com.huawei.unibi.molap.datastorage.store.impl.FileFactory;
@@ -174,8 +171,6 @@ public final class MolapLoaderUtil
     	info.setCubeName(cubeName);
     	info.setSchemaPath(loadModel.getSchemaPath());
     	info.setAutoAggregateRequest(loadModel.isAggLoadRequest());
-    	info.setComplexDelimiterLevel1(loadModel.getComplexDelimiterLevel1());
-    	info.setComplexDelimiterLevel2(loadModel.getComplexDelimiterLevel2());
     	
     	generateGraph(schmaModel, info, loadModel.getTableName(),loadModel.getPartitionId(), loadModel.getSchema(), loadModel.getFactStoreLocation(), currentRestructNumber);
     	
@@ -420,7 +415,7 @@ public final class MolapLoaderUtil
                     @Override
                     public boolean accept(MolapFile path)
                     {
-                        return !loadFolders.contains(path.getAbsolutePath().replace("\\", "/")) && !path.getName().contains(MolapCommonConstants.MERGERD_EXTENSION);
+                        return !loadFolders.contains(path.getAbsolutePath().replace("\\", "/"));
                     }
                 });
                 for(int k = 0;k < listFiles.length;k++)
@@ -521,20 +516,11 @@ public final class MolapLoaderUtil
                     || MolapCommonConstants.MARKED_FOR_UPDATE.equals(oneLoad
                             .getLoadStatus()))
             {
-                if(null != oneLoad.getMergedLoadName())
-                {
                 String loadName = MolapCommonConstants.LOAD_FOLDER
-                            + oneLoad.getMergedLoadName();
-                    activeSlices.add(loadName);
-                }
-                else
-                {
-                    String loadName = MolapCommonConstants.LOAD_FOLDER
                         + oneLoad.getLoadName();
                 activeSlices.add(loadName);
             }
         }
-        }
         return activeSlices;
     }
     
@@ -554,16 +540,9 @@ public final class MolapLoaderUtil
             if(MolapCommonConstants.MARKED_FOR_UPDATE.equals(oneLoad
                     .getLoadStatus()))
             {
-                if(null != oneLoad.getMergedLoadName())
-                {
-                    updatedSlices.add(oneLoad.getMergedLoadName());
-                }
-                else
-                {
                 updatedSlices.add(oneLoad.getLoadName());
             }
         }
-        }
         return updatedSlices;
     }
     
@@ -1196,7 +1175,11 @@ public final class MolapLoaderUtil
 			}
 			}
 			listOfLoadFolderDetails.add(loadMetadataDetails);
-			
+			writeLoadMetadata(
+					loadModel.getSchema(),
+					loadModel.getSchemaName(),
+					loadModel.getCubeName(),
+					listOfLoadFolderDetails);
 		} 
 
 		finally
@@ -1204,11 +1187,6 @@ public final class MolapLoaderUtil
 
 		   MolapUtil.closeStreams(dataInputStream);
 		}
-		writeLoadMetadata(
-		        loadModel.getSchema(),
-		        loadModel.getSchemaName(),
-		        loadModel.getCubeName(),
-		        listOfLoadFolderDetails);
 
 	}
 
@@ -1226,16 +1204,10 @@ public final class MolapLoaderUtil
 		DataOutputStream dataOutputStream;
 		Gson gsonObjectToWrite = new Gson();
 		BufferedWriter brWriter = null;
-		
-		AtomicFileOperations writeOperation = new AtomicFileOperationsImpl(dataLoadLocation, FileFactory.getFileType(dataLoadLocation) );
-		
 		try {
-		    
-		    dataOutputStream = writeOperation.openForWrite(FileWriteOperation.OVERWRITE);
-		    
-			/*dataOutputStream = FileFactory
+			dataOutputStream = FileFactory
 					.getDataOutputStream(dataLoadLocation,
-							FileFactory.getFileType(dataLoadLocation));*/
+							FileFactory.getFileType(dataLoadLocation));
 			brWriter = new BufferedWriter(new OutputStreamWriter(
 					dataOutputStream,
 					MolapCommonConstants.MOLAP_DEFAULT_STREAM_ENCODEFORMAT));
@@ -1249,13 +1221,12 @@ public final class MolapLoaderUtil
 					brWriter.flush();
 				}
 			} catch (Exception e) {
+//				e.printStackTrace();
 				LOGGER.error(MolapSparkInterFaceLogEvent.UNIBI_MOLAP_SPARK_INTERFACE_MSG,"error in  flushing ", e, e.getMessage());
 				  			
 			}
 			MolapUtil.closeStreams(brWriter);
-			
 		}
-		writeOperation.close();
 
 	}
 
@@ -1520,140 +1491,5 @@ public final class MolapLoaderUtil
         }
         return columnList;
     }
-	 public static void copyMergedLoadToHDFS(MolapLoadModel loadModel, int currentRestructNumber, String mergedLoadName)
-    {
-      //Copy the current load folder to HDFS
-        boolean copyStore = Boolean.valueOf(MolapProperties.getInstance().getProperty("dataload.hdfs.copy", "true"));
-        
-        String schemaName =  loadModel.getSchemaName();
-        String cubeName =  loadModel.getCubeName();
-        String factTable = loadModel.getTableName();
-        String aggTableName = loadModel.getAggTableName();
-        
-        if(copyStore)
-        {
-            String hdfsLocation = MolapProperties.getInstance().getProperty(MolapCommonConstants.STORE_LOCATION_HDFS);
-            
-            String localStore = MolapProperties.getInstance().getProperty(
-                    MolapCommonConstants.STORE_LOCATION, MolapCommonConstants.STORE_LOCATION_DEFAULT_VAL);
-            if(!loadModel.isAggLoadRequest())
-            {
-            copyMergeToHDFS(schemaName, cubeName, factTable, hdfsLocation,localStore, currentRestructNumber, mergedLoadName);
-            }
-            if(null != aggTableName) {
-//              for (int i = 0; i < aggTables.length; i++) {
-                copyMergeToHDFS(schemaName, cubeName, aggTableName, hdfsLocation, localStore, currentRestructNumber,mergedLoadName);
-//              }
-            }
-            try
-            {
-                 MolapUtil.deleteFoldersAndFiles(new File[] { 
-                          new File(localStore + File.separator + schemaName + File.separator + cubeName) });
-                // MolapUtil.getSlices(localStore + File.separator + schemaName + File.separator + cubeName, factTable, loadModel.)
-            } 
-            catch (MolapUtilException e) 
-            {
-//              e.printStackTrace();
-                LOGGER.error(MolapSparkInterFaceLogEvent.UNIBI_MOLAP_SPARK_INTERFACE_MSG, "Error while MolapUtil.deleteFoldersAndFiles ", e, e.getMessage());
-            }
-        }
-    }
-    
-    public static void copyMergeToHDFS(String schemaName, String cubeName,
-            String factTable, String hdfsLocation, String localStore, int currentRestructNumber, String mergedLoadName) {
-        try
-        {
-            //If the hdfs store and the local store configured differently, then copy
-            if(hdfsLocation!=null && !hdfsLocation.equals(localStore))
-            {
-                /**
-                 * Identify the Load_X folder from the local store folder
-                 */
-                String currentloadedStore = localStore;
-                currentloadedStore = currentloadedStore + File.separator + schemaName + File.separator
-                        + cubeName;
-
 
-                int rsCounter = currentRestructNumber/*MolapUtil.checkAndReturnNextRestructFolderNumber(currentloadedStore,"RS_")*/;
-
-           
-
-                if(rsCounter == -1)
-                {
-//                  System.out.println("Unable to find the local store details (RS_-1) " + currentloadedStore);
-                    LOGGER.info(MolapSparkInterFaceLogEvent.UNIBI_MOLAP_SPARK_INTERFACE_MSG,"Unable to find the local store details (RS_-1) " + currentloadedStore);
-                    return;
-                }
-                String localLoadedTable = currentloadedStore + File.separator
-                        + MolapCommonConstants.RESTRUCTRE_FOLDER + rsCounter + File.separator + factTable;
-
-                localLoadedTable = localLoadedTable.replace("\\", "/");
-                
-                int loadCounter = MolapUtil.checkAndReturnCurrentLoadFolderNumber(localLoadedTable);
-
-                if(loadCounter == -1)
-                {
-//                  System.out.println("Unable to find the local store details (Load_-1) " + currentloadedStore);
-                    LOGGER.info(MolapSparkInterFaceLogEvent.UNIBI_MOLAP_SPARK_INTERFACE_MSG,"Unable to find the local store details (Load_-1) " + currentloadedStore);
-                       
-                    return;
-                }
-
-                String localLoadName = MolapCommonConstants.LOAD_FOLDER
-                        + mergedLoadName;
-                String localLoadFolder = localLoadedTable + File.separator + MolapCommonConstants.LOAD_FOLDER
-                        + mergedLoadName;
-                
-                LOGGER.info(MolapSparkInterFaceLogEvent.UNIBI_MOLAP_SPARK_INTERFACE_MSG,"Local data loaded folder ... = " + localLoadFolder);                  
-//              System.out.println("Local data loaded folder ... = " + localLoadFolder);
-               
-                /**
-                 * Identify the Load_X folder in the HDFS store 
-                 */
-                
-                String hdfsStoreLocation= hdfsLocation;
-                hdfsStoreLocation = hdfsStoreLocation + File.separator + schemaName + File.separator
-                        + cubeName;
-
-                rsCounter = currentRestructNumber/*MolapUtil.checkAndReturnNextRestructFolderNumber(hdfsStoreLocation,"RS_")*/;
-                if(rsCounter == -1)
-                {
-                    rsCounter = 0;
-                }
-
-                String hdfsLoadedTable = hdfsStoreLocation + File.separator
-                        + MolapCommonConstants.RESTRUCTRE_FOLDER + rsCounter + File.separator + factTable;
-                
-                hdfsLoadedTable = hdfsLoadedTable.replace("\\", "/");
-
-                String hdfsStoreLoadFolder = hdfsLoadedTable + File.separator + localLoadName;
-
-                LOGGER.info(MolapSparkInterFaceLogEvent.UNIBI_MOLAP_SPARK_INTERFACE_MSG,"HDFS data load folder ... = " + hdfsStoreLoadFolder);
-                
-                /**
-                 * Copy the data created through latest ETL run, to the HDFS store 
-                 */
-                
-                LOGGER.info(MolapSparkInterFaceLogEvent.UNIBI_MOLAP_SPARK_INTERFACE_MSG,"Copying " + localLoadFolder + " --> " + hdfsStoreLoadFolder);
-                
-                hdfsStoreLoadFolder = hdfsStoreLoadFolder.replace("\\", "/");
-                Path path = new Path(hdfsStoreLocation);
-                
-               
-                FileSystem fs = path.getFileSystem(FileFactory.getConfiguration());
-                fs.copyFromLocalFile(true, true, new Path(localLoadFolder), new Path(hdfsStoreLoadFolder));
-                
-                LOGGER.info(MolapSparkInterFaceLogEvent.UNIBI_MOLAP_SPARK_INTERFACE_MSG,"Copying sliceMetaData from " + localLoadedTable + " --> " + hdfsLoadedTable);
-                
-            }
-            else
-            {
-                LOGGER.info(MolapCoreLogEvent.UNIBI_MOLAPCORE_MSG, "Separate molap.storelocation.hdfs is not configured for hdfs store path");
-            }
-        }
-        catch(Exception e)
-        {
-            LOGGER.info(MolapCoreLogEvent.UNIBI_MOLAPCORE_MSG,e.getMessage());
-        }
-    }
 }
diff --git a/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/merger/MolapDataMergerUtil.java b/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/merger/MolapDataMergerUtil.java
index be71f32..1e1ebdc 100644
--- a/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/merger/MolapDataMergerUtil.java
+++ b/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/merger/MolapDataMergerUtil.java
@@ -1,741 +1,95 @@
 package com.huawei.datasight.molap.merger;
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-
-import com.huawei.datasight.molap.core.load.LoadMetadataDetails;
-import com.huawei.datasight.molap.load.DeleteLoadFolders;
 import com.huawei.datasight.molap.load.MolapLoadModel;
-import com.huawei.datasight.molap.load.MolapLoaderUtil;
-import com.huawei.datasight.molap.spark.util.LoadMetadataUtil;
-import com.huawei.iweb.platform.logging.LogService;
-import com.huawei.iweb.platform.logging.LogServiceFactory;
+//import com.huawei.iweb.platform.logging.LogService;
+//import com.huawei.iweb.platform.logging.LogServiceFactory;
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
-import com.huawei.unibi.molap.datastorage.store.filesystem.MolapFile;
-import com.huawei.unibi.molap.datastorage.store.filesystem.MolapFileFilter;
-import com.huawei.unibi.molap.datastorage.store.impl.FileFactory;
-import com.huawei.unibi.molap.datastorage.store.impl.FileFactory.FileType;
 import com.huawei.unibi.molap.merger.MolapColumnarSliceMerger;
 import com.huawei.unibi.molap.merger.MolapSliceMergerInfo;
-import com.huawei.unibi.molap.util.MolapCoreLogEvent;
 import com.huawei.unibi.molap.util.MolapProperties;
-import com.huawei.unibi.molap.util.MolapUtil;
 
-/**
- * utility class for load merging.
- * @author R00903928
- *
- */
 public final class MolapDataMergerUtil 
 {
-    private static final LogService LOGGER = LogServiceFactory
-            .getLogService(MolapDataMergerUtil.class.getName());
-    
+//	private static final LogService LOGGER = LogServiceFactory.getLogService(MolapDataMergerUtil.class.getName());
 	private MolapDataMergerUtil()
 	{
 		
 	}
-	/**
-	 * 
-	 * @param molapLoadModel
-	 * @param storeLocation
-	 * @param hdfsStoreLocation
-	 * @param currentRestructNumber
-	 * @param metadataFilePath
-	 * @param loadsToMerge
-	 * @param mergedLoadName
-	 * @return
-	 * @throws Exception
-	 */
-	public static boolean executeMerging(MolapLoadModel molapLoadModel,String storeLocation, String hdfsStoreLocation, int currentRestructNumber , String metadataFilePath, List<String> loadsToMerge, String mergedLoadName) throws Exception
+	public static void executeMerging(MolapLoadModel molapLoadModel,String storeLocation, String hdfsStoreLocation, int currentRestructNumber) throws Exception
 	{
+		
 		MolapProperties.getInstance().addProperty(
 				MolapCommonConstants.STORE_LOCATION, storeLocation);
 		MolapProperties.getInstance().addProperty(
 				MolapCommonConstants.STORE_LOCATION_HDFS, hdfsStoreLocation);
 		MolapSliceMergerInfo molapSliceMergerInfo = new MolapSliceMergerInfo();
 		
-		
 		molapSliceMergerInfo.setCubeName(molapLoadModel.getCubeName());
 		molapSliceMergerInfo.setPartitionID(molapLoadModel.getPartitionId());
 		molapSliceMergerInfo.setSchema(molapLoadModel.getSchema());
 		molapSliceMergerInfo.setSchemaName(molapLoadModel.getSchemaName());
 		molapSliceMergerInfo.setSchemaPath(molapLoadModel.getSchemaPath());
 		molapSliceMergerInfo.setTableName(molapLoadModel.getTableName());
-		molapSliceMergerInfo.setMetadataPath(metadataFilePath);
-		molapSliceMergerInfo.setLoadsToBeMerged(loadsToMerge);
-		molapSliceMergerInfo.setMergedLoadName(mergedLoadName);
 		
 		MolapColumnarSliceMerger merger = new MolapColumnarSliceMerger(molapSliceMergerInfo);
-		return merger.fullMerge(currentRestructNumber);
+		merger.fullMerge(currentRestructNumber);
 		
 	}
 	
-	/**
-	 * 
-	 * @param storeLocation
-	 * @param fileType
-	 * @param metadataPath
-	 * @param molapLoadModel
-	 * @param currentRestructNumber
-	 * @param partitionCount
-	 * @return
-	 */
-	 public static List<String> getLoadsToMergeFromHDFS(String storeLocation, FileType fileType, String metadataPath, MolapLoadModel molapLoadModel,int currentRestructNumber,int partitionCount)
-    {
-        List<String> loadNames = new ArrayList<String>(
-                MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
-
-        try
-        {
-            if(!FileFactory.isFileExist(storeLocation, fileType))
-            {
-                return null;
-            }
-        }
-        catch(IOException e)
-        {
-             LOGGER.error(
-             MolapCoreLogEvent.UNIBI_MOLAPCORE_MSG ,
-             "Error occurred :: " + e.getMessage());
-        }
-
-        int toLoadMergeMaxSize;
-        try
-        {
-            toLoadMergeMaxSize = Integer
-                    .parseInt(MolapProperties
-                            .getInstance()
-                            .getProperty(
-                                    MolapCommonConstants.TO_LOAD_MERGE_MAX_SIZE,
-                                    MolapCommonConstants.TO_LOAD_MERGE_MAX_SIZE_DEFAULT));
-        }
-        catch(NumberFormatException e)
-        {
-            toLoadMergeMaxSize = Integer
-                    .parseInt(MolapCommonConstants.TO_LOAD_MERGE_MAX_SIZE_DEFAULT);
-        }
-
-        LoadMetadataDetails[] loadDetails = MolapUtil
-                .readLoadMetadata(metadataPath);
-
-        for(LoadMetadataDetails loadDetail : loadDetails)
-        {
-            if(loadNames.size() < 2)
-            {
-                // check if load is not deleted.
-                if(checkIfLoadIsNotDeleted(loadDetail))
-                {
-                    // check if load is merged
-                    if(checkIfLoadIsMergedAlready(loadDetail))
-                    {
-                        if(checkSizeOfloadToMerge(loadDetail,
-                                toLoadMergeMaxSize, molapLoadModel,
-                                partitionCount, storeLocation,
-                                currentRestructNumber,
-                                loadDetail.getMergedLoadName()))
-                        {
-                            if(!loadNames.contains(loadDetail.getMergedLoadName()))
-                            {
-                                loadNames.add(loadDetail.getMergedLoadName());
-                            }
-                        }
-                    }
-                    else
-                    // take this load as To Load.
-                    {
-                        if(checkSizeOfloadToMerge(loadDetail,
-                                toLoadMergeMaxSize, molapLoadModel,
-                                partitionCount, storeLocation,
-                                currentRestructNumber, loadDetail.getLoadName()))
-                        {
-                            loadNames.add(loadDetail.getLoadName());
-                        }
-                    }
-                }
-            }
-            else
-            {
-                break;
-            }
-        }
-        
-        return loadNames;
-
-    }
-	 
-	/**
-	 * 
-	 * @param loadDetail
-	 * @param toLoadMergeMaxSize
-	 * @param molapLoadModel
-	 * @param partitionCount
-	 * @param storeLocation 
-	 * @param currentRestructNumber 
-	 * @return
-	 */
-	 private static boolean checkSizeOfloadToMerge(
-            final LoadMetadataDetails loadDetail, int toLoadMergeMaxSize,MolapLoadModel molapLoadModel, int partitionCount, String storeLocation, int currentRestructNumber, final String loadNameToMatch)
-    {
-
-	     long factSizeAcrossPartition = 0;
-	     
-        for(int partition = 0;partition < partitionCount;partition++)
-        {
-            String loadPath = LoadMetadataUtil.createLoadFolderPath(
-                    molapLoadModel, storeLocation, partition,
-                    currentRestructNumber);
-
-            MolapFile parentLoadFolder = FileFactory.getMolapFile(loadPath,
-                    FileFactory.getFileType(loadPath));
-            MolapFile[] loadFiles = parentLoadFolder
-                    .listFiles(new MolapFileFilter()
-                    {
-                        @Override
-                        public boolean accept(MolapFile file)
-                        {
-                            if(file.getName()
-                                    .substring(file.getName().indexOf('_') + 1,
-                                            file.getName().length())
-                                    .equalsIgnoreCase(loadNameToMatch))
-                            {
-                                return true;
-                            }
-                            return false;
-                        }
-                    });
-            
-            // no found load folder in current RS
-            if(loadFiles.length == 0)
-            {
-                return false;
-            }
-            
-            // check if fact file is present or not. this is in case of Restructure folder.
-            if(!isFactFilePresent(loadFiles[0]))
-            {
-                return false;
-            }
-            
-            
-             factSizeAcrossPartition += getSizeOfFactFileInLoad(loadFiles[0]);
-            
-            // MolapFile loadFolder = new MolapFile()
-        }
-        // check avg fact size if less than configured max size of to load.
-        if(factSizeAcrossPartition < toLoadMergeMaxSize*1024*1024*1024)
-        {
-            return true;
-        }
-
-        // LoadMetadataUtil.createLoadFolderPath(model, hdfsStoreLocation,
-        // partitionId, currentRestructNumber);
-        return false;
-    }
-	 
-    /**
-	  * 
-	  * @param molapFile
-	  * @return
-	  */
-    private static long getSizeOfFactFileInLoad(MolapFile molapFile)
-    {
-        long factSize = 0;
-        
-        // check if update fact is present.
-        
-        MolapFile [] factFileUpdated = molapFile.listFiles(new MolapFileFilter()
-        {
-            
-            @Override
-            public boolean accept(MolapFile file)
-            {
-                if(file.getName().endsWith(MolapCommonConstants.FACT_UPDATE_EXTENSION))
-                {
-                    return true;
-                }
-                return false;
-            }
-        });
-        
-        if(factFileUpdated.length != 0)
-        {
-            for(MolapFile fact : factFileUpdated)
-            {
-                factSize += fact.getSize();
-            }
-            return factSize;
-        }
-        
-        // normal fact case.
-        MolapFile [] factFile = molapFile.listFiles(new MolapFileFilter()
-        {
-            
-            @Override
-            public boolean accept(MolapFile file)
-            {
-                if(file.getName().endsWith(MolapCommonConstants.FACT_FILE_EXT))
-                {
-                    return true;
-                }
-                return false;
-            }
-        });
-        
-        for(MolapFile fact  : factFile)
-        {
-            factSize +=  fact.getSize();
-        }
-        
-        return factSize;
-    }
-    /**
-	  * 
-	  * @param loadDetail
-	  * @return
-	  */
-	private static boolean checkIfLoadIsMergedAlready(
-            LoadMetadataDetails loadDetail)
-    {
-	    if(null != loadDetail.getMergedLoadName())
-	    {
-	        return true;
-	    }
-        return false;
-    }
-    /**
-	 *  
-	 * @param loadDetail
-	 */
-    private static boolean checkIfLoadIsNotDeleted(LoadMetadataDetails loadDetail)
-    {
-        if(!loadDetail.getLoadStatus().equalsIgnoreCase(MolapCommonConstants.MARKED_FOR_DELETE))
-        {
-            return true;
-        }
-        else
-        {
-            return false;
-        }
-    }
-    
-    /**
-     * 
-     * @param metadataFilePath
-     * @param molapLoadModel 
-     * @param storeLocation 
-     * @param partition 
-     * @param currentRestructNumber 
-     * @return
-     */
-    public static boolean checkIfLoadMergingRequired(String metadataFilePath, MolapLoadModel molapLoadModel, String storeLocation, int partition, int currentRestructNumber)
-    {
-        
-        
-        String loadPath = LoadMetadataUtil.createLoadFolderPath(
-                molapLoadModel, storeLocation, 0,
-                currentRestructNumber);
-
-        MolapFile parentLoadFolder = FileFactory.getMolapFile(loadPath,
-                FileFactory.getFileType(loadPath));
-        
-        // get all the load files in the current RS 
-        MolapFile[] loadFiles = parentLoadFolder
-                .listFiles(new MolapFileFilter()
-                {
-                    @Override
-                    public boolean accept(MolapFile file)
-                    {
-                        if(file.getName()
-                                .startsWith(MolapCommonConstants.LOAD_FOLDER ))
-                        {
-                            return true;
-                        }
-                        return false;
-                    }
-                });
-        
-        
-        String isLoadMergeEnabled = MolapProperties.getInstance().getProperty(
-                MolapCommonConstants.ENABLE_LOAD_MERGE,
-                MolapCommonConstants.DEFAULT_ENABLE_LOAD_MERGE);
-        
-        if(isLoadMergeEnabled.equalsIgnoreCase("false"))
-        {
-            return false;
-        }
-        
-        int mergeThreshold;
-        try
-        {
-             mergeThreshold = Integer.parseInt(MolapProperties.getInstance().getProperty(
-                MolapCommonConstants.MERGE_THRESHOLD_VALUE,
-                MolapCommonConstants.MERGE_THRESHOLD_DEFAULT_VAL));
-        }
-        catch(NumberFormatException e)
-        {
-            mergeThreshold = Integer.parseInt(MolapCommonConstants.MERGE_THRESHOLD_DEFAULT_VAL);
-        }
-        
-        LoadMetadataDetails [] details = MolapUtil.readLoadMetadata(metadataFilePath);
-        
-        int validLoadsNumber = getNumberOfValidLoads(details,loadFiles);
-        
-        if(validLoadsNumber > mergeThreshold+1)
-        {
-            return true;
-        }
-        else
-        {
-            return false;
-        }
-    }
-    
-    /**
-     * 
-     * @param details
-     * @param loadFiles 
-     * @return
-     */
-    private static int getNumberOfValidLoads(LoadMetadataDetails[] details, MolapFile[] loadFiles)
-    {
-        int validLoads = 0;
-        
-        for(LoadMetadataDetails load : details)
-        {
-            if(load.getLoadStatus().equalsIgnoreCase(MolapCommonConstants.STORE_LOADSTATUS_SUCCESS)
-                    || load.getLoadStatus().equalsIgnoreCase(MolapCommonConstants.STORE_LOADSTATUS_PARTIAL_SUCCESS)
-                    || load.getLoadStatus().equalsIgnoreCase(MolapCommonConstants.MARKED_FOR_UPDATE))
-            {
-                
-                if(isLoadMetadataPresentInRsFolders(loadFiles,load.getLoadName()))
-                {
-                    validLoads++;
-                }
-            }
-        }
-        
-        return validLoads;
-    
-    }
-    
-    /**
-     * 
-     * @param loadFiles
-     * @param loadName
-     * @return
-     */
-    private static boolean isLoadMetadataPresentInRsFolders(
-            MolapFile[] loadFiles, String loadName)
-    {
-        for(MolapFile load : loadFiles)
-        {
-            String nameOfLoad = load.getName().substring(load.getName().indexOf(MolapCommonConstants.UNDERSCORE)+1, load.getName().length());
-            if(nameOfLoad.equalsIgnoreCase(loadName))
-            {
-                // check if it is a RS load or not.
-                MolapFile [] factFiles = load.listFiles(new MolapFileFilter()
-                {
-                    @Override
-                    public boolean accept(MolapFile file)
-                    {
-                        if (file.getName().endsWith(MolapCommonConstants.FACT_FILE_EXT ) || file.getName().endsWith(MolapCommonConstants.FACT_UPDATE_EXTENSION ))
-                        {
-                            return true;
-                        }
-                        return false;
-                    }
-                });
-                
-                if(factFiles.length > 0)
-                {
-                    return true;
-                }
-                else
-                {
-                    return false;
-                }
-            }
-            
-        }
-        return false;
-    }
-    /**
-     * 
-     * @param loadName
-     * @return
-     */
-    public static String getMergedLoadName(List<String> loadName)
-    {
-         String mergeLoadName = loadName.get(0); 
-        String timeStamp = new Date().getTime()+"";
-        
-        if(mergeLoadName.contains(MolapCommonConstants.MERGERD_EXTENSION))
-        {
-            String loadNum = mergeLoadName.substring(0, mergeLoadName.indexOf(MolapCommonConstants.MERGERD_EXTENSION));
-            return loadNum+MolapCommonConstants.MERGERD_EXTENSION+MolapCommonConstants.UNDERSCORE+timeStamp;
-        }
-        else
-        {
-            return mergeLoadName+MolapCommonConstants.MERGERD_EXTENSION+MolapCommonConstants.UNDERSCORE+timeStamp;
-        }
-        
-    }
-    
-    /**
-     * 
-     * @param loadsToMerge
-     * @param metaDataFilepath
-     * @param MergedLoadName
-     */
-    public static void updateLoadMetadataWithMergeStatus(List<String> loadsToMerge, String metaDataFilepath, String MergedLoadName,MolapLoadModel molapLoadModel)
-    {
-        LoadMetadataDetails[] loadDetails =  MolapUtil.readLoadMetadata(metaDataFilepath);
-        
-        boolean first = true;
-        
-        for(LoadMetadataDetails loadDetail : loadDetails)
-        {
-            
-            if(null != loadDetail.getMergedLoadName())
-            {
-                if(loadsToMerge.contains(loadDetail.getMergedLoadName()) && first)
-                {
-                    loadDetail.setMergedLoadName(MergedLoadName);
-                    first = false;
-                }
-                else
-                {/*
-                    loadDetail.setLoadStatus(MolapCommonConstants.MARKED_FOR_DELETE);
-                    loadDetail.setDeletionTimestamp(MolapLoaderUtil
-                            .readCurrentTime());
-                */
-                    continue;
-                }
-            }
-            
-            else if(loadsToMerge.contains(loadDetail.getLoadName()) )
-            {
-                if(first)
-                {
-                loadDetail.setMergedLoadName(MergedLoadName);
-                first = false;
-                }
-                else
-                {
-                    loadDetail.setLoadStatus(MolapCommonConstants.MARKED_FOR_DELETE);
-                    loadDetail.setDeletionTimestamp(MolapLoaderUtil
-                            .readCurrentTime());
-                }
-                
-            }
-           
-        }
-        
-        try
-        {
-            MolapLoaderUtil.writeLoadMetadata(molapLoadModel.getSchema(), molapLoadModel.getSchemaName(), molapLoadModel.getCubeName(), Arrays.asList(loadDetails));
-        }
-        catch(IOException e)
-        {
-            
-        }
-        
-    }
-    
-    /**
-     * 
-     * @param path
-     * @param loadModel
-     */
-    public static void cleanUnwantedMergeLoadFolder(
-            MolapLoadModel loadModel, int partitionCount, String storeLocation,
-            boolean isForceDelete, int currentRestructNumber)
-    {
-
-        String loadMetadataFilePath = MolapLoaderUtil
-                .extractLoadMetadataFileLocation(loadModel);
-
-        LoadMetadataDetails[] details = MolapUtil
-                .readLoadMetadata(loadMetadataFilePath);
-        
-        // for first time before any load , this will be null
-        if( null == details || details.length == 0  )
-        {
-            return;
-        }
-
-        for(int partitionId = 0;partitionId < partitionCount;partitionId++)
-        {
-
-            String path = LoadMetadataUtil.createLoadFolderPath(loadModel,
-                    storeLocation, partitionId, currentRestructNumber);
-
-            MolapFile loadFolder = FileFactory.getMolapFile(path,
-                    FileFactory.getFileType(path));
-
-            MolapFile[] loads = loadFolder.listFiles(new MolapFileFilter()
-            {
-                @Override
-                public boolean accept(MolapFile file)
-                {
-                    if(file.getName().startsWith(
-                            MolapCommonConstants.LOAD_FOLDER)
-                            && file.getName().contains(
-                                    MolapCommonConstants.MERGER_FOLDER_EXT))
-                    {
-                        return true;
-                    }
-                    else
-                    {
-                        return false;
-                    }
-                }
-            });
-
-            for(int i = 0;i < loads.length;i++)
-            {
-                if(checkIfOldMergeLoadCanBeDeleted(loads[i], details))
-                {
-                    // delete merged load folder
-                    MolapFile[] files = loads[i].listFiles();
-                    // deleting individual files
-                    if(files != null)
-                    {
-                        for(MolapFile eachFile : files)
-                        {
-                            if(!eachFile.delete())
-                            {
-                                LOGGER.warn(
-                                        MolapCoreLogEvent.UNIBI_MOLAPCORE_MSG,
-                                        "Unable to delete the file."
-                                                + loadFolder.getAbsolutePath());
-                            }
-                        }
-
-                        loads[i].delete();
-
-                    }
-                    
-                    // delete corresponding aggregate table.
-                    
-                    MolapFile[] aggFiles = LoadMetadataUtil.getAggregateTableList(loadModel, storeLocation, partitionId, currentRestructNumber);
-                    DeleteLoadFolders.deleteAggLoadFolders(aggFiles,loads[i].getName());
-                    
-                }
-            }
-        }
-    }
-    
-    /**
-     * 
-     * @param eachMergeLoadFolder
-     * @param details
-     * @return
-     */
-    private static boolean checkIfOldMergeLoadCanBeDeleted(
-            MolapFile eachMergeLoadFolder, LoadMetadataDetails[] details)
-    {
-        boolean found = false;
-        for(LoadMetadataDetails loadDetail : details)
-        {
-            if(null != loadDetail.getMergedLoadName() && (MolapCommonConstants.LOAD_FOLDER+loadDetail.getMergedLoadName()).equalsIgnoreCase(eachMergeLoadFolder.getName()))
-            {
-                found = true;
-                break;
-            }
-        }
-        
-        if(!found)
-        {
-            // check the query execution time out and check the time stamp on load and delete.
-            
-            String loadName = eachMergeLoadFolder.getName();
-            long loadTime = Long.parseLong( loadName.substring( loadName.lastIndexOf(MolapCommonConstants.UNDERSCORE)+1,  loadName.length()));
-            long currentTime = new Date().getTime();
-            
-            long millis = getMaxQueryTimeOut();
-            
-            if ((currentTime-loadTime) > millis)
-            {
-                // delete that merge load folder
-                return true;
-            }
-        }
-        
-        return false;
-    }
-    /**
-     * 
-     * @return
-     */
-    private static long getMaxQueryTimeOut()
-    {
-        int maxTime; 
-        try
-        {
-            maxTime = Integer.parseInt(MolapProperties.getInstance().
-                    getProperty(MolapCommonConstants.MAX_QUERY_EXECUTION_TIME));
-        }
-        catch(NumberFormatException e)
-        {
-           maxTime = MolapCommonConstants.DEFAULT_MAX_QUERY_EXECUTION_TIME;
-        }
-        
-        return maxTime*60000;
-      
-    }
-    
-    /**
-     * 
-     * @param molapFile
-     * @return
-     */
-    private static boolean isFactFilePresent(MolapFile molapFile)
-   {
-        
-        MolapFile [] factFileUpdated = molapFile.listFiles(new MolapFileFilter()
-        {
-            
-            @Override
-            public boolean accept(MolapFile file)
-            {
-                if(file.getName().endsWith(MolapCommonConstants.FACT_UPDATE_EXTENSION))
-                {
-                    return true;
-                }
-                return false;
-            }
-        });
-        
-        if(factFileUpdated.length != 0 )
-        {
-            return true;
-        }
-        
-        MolapFile [] factFile = molapFile.listFiles(new MolapFileFilter()
-        {
-            
-            @Override
-            public boolean accept(MolapFile file)
-            {
-                if(file.getName().endsWith(MolapCommonConstants.FACT_FILE_EXT))
-                {
-                    return true;
-                }
-                return false;
-            }
-        });
-        
-        if(factFile.length != 0 )
-        {
-            return true;
-        }
-        
-       return false;
-   }
-    
+//	 public static void copyCurrentLoadToHDFS(MolapLoadModel loadModel)
+//	    {
+//	      //Copy the current load folder to HDFS
+//	        boolean copyStore = Boolean.valueOf(MolapProperties.getInstance().getProperty("dataload.hdfs.copy", "true"));
+//	        
+//	        String schemaName =  loadModel.getSchemaName();
+//	        String cubeName =  loadModel.getCubeName();
+//	        String factTable = loadModel.getTableName();
+//	        if(copyStore)
+//	        {
+//	            String hdfsLocation = MolapProperties.getInstance().getProperty(MolapCommonConstants.STORE_LOCATION_HDFS);
+//	            
+//	            String localStore = MolapProperties.getInstance().getProperty(
+//	            		MolapCommonConstants.STORE_LOCATION, MolapCommonConstants.STORE_LOCATION_DEFAULT_VAL);
+//	            MolapLoaderUtil.copyToHDFS(schemaName, cubeName, factTable, hdfsLocation,
+//						localStore);
+//	        }
+//	    }
+
+//		public static void deleteOlderSlices(MolapLoadModel loadModel)
+//		{
+//				String schemaName =  loadModel.getSchemaName();
+//		        String cubeName =  loadModel.getCubeName();
+//		        String factTable = loadModel.getTableName();
+//		        
+//		        String hdfsLocation = MolapProperties.getInstance().getProperty(MolapCommonConstants.STORE_LOCATION_HDFS);
+//		        
+//		        String hdfsStoreLocation= hdfsLocation;
+//		        hdfsStoreLocation = hdfsStoreLocation + File.separator + schemaName + File.separator
+//		                + cubeName;
+//
+//		        int rsCounter = MolapUtil.checkAndReturnNextRestructFolderNumber(hdfsStoreLocation,"RS_");
+//		        if(rsCounter == -1)
+//		        {
+//		            rsCounter = 0;
+//		        }
+//		        String hdfsLoadedTable = hdfsStoreLocation + File.separator
+//		                + MolapCommonConstants.RESTRUCTRE_FOLDER + rsCounter;
+//		        
+//		        List<MolapSliceAndFiles> slicesFromHDFS = MolapUtil.getSlicesFromHDFS(
+//		        		hdfsLoadedTable, factTable, FileFactory.getFileType(hdfsLoadedTable));
+//		        try
+//		        {
+//			        for (int i = 0; i < slicesFromHDFS.size()-1; i++) 
+//			        {
+//			        	MolapFile molapFile = FileFactory.getMolapFile(slicesFromHDFS.get(i).getPath(), FileFactory.getFileType(slicesFromHDFS.get(i).getPath()));
+//			        	MolapUtil.deleteFoldersAndFiles(molapFile);
+//					}
+//		        }
+//		        catch(Exception e)
+//		        {
+////		        	e.printStackTrace();
+//		        	LOGGER.error(MolapSparkInterFaceLogEvent.UNIBI_MOLAP_SPARK_INTERFACE_MSG, e, e.getMessage());
+//		        }
+//		        
+//		}
 }
diff --git a/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/spark/util/MolapQueryUtil.java b/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/spark/util/MolapQueryUtil.java
index f1832b9..146d8be 100644
--- a/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/spark/util/MolapQueryUtil.java
+++ b/Molap/Molap-Spark-Interface/src/main/java/com/huawei/datasight/molap/spark/util/MolapQueryUtil.java
@@ -21,6 +21,10 @@ import java.util.Set;
 import org.apache.spark.sql.SparkUnknownExpression;
 import org.apache.spark.sql.cubemodel.Partitioner;
 
+
+
+
+
 import com.google.gson.Gson;
 import com.huawei.datasight.molap.core.load.LoadMetadataDetails;
 import com.huawei.datasight.molap.partition.api.Partition;
@@ -38,8 +42,6 @@ import com.huawei.datasight.molap.spark.splits.TableSplit;
 import com.huawei.iweb.platform.logging.LogService;
 import com.huawei.iweb.platform.logging.LogServiceFactory;
 import com.huawei.unibi.molap.constants.MolapCommonConstants;
-import com.huawei.unibi.molap.datastorage.store.fileperations.AtomicFileOperations;
-import com.huawei.unibi.molap.datastorage.store.fileperations.AtomicFileOperationsImpl;
 import com.huawei.unibi.molap.datastorage.store.filesystem.MolapFile;
 import com.huawei.unibi.molap.datastorage.store.filesystem.MolapFileFilter;
 import com.huawei.unibi.molap.datastorage.store.impl.FileFactory;
@@ -65,8 +67,6 @@ import com.huawei.unibi.molap.metadata.MolapMetadata;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Cube;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Dimension;
 import com.huawei.unibi.molap.metadata.MolapMetadata.Measure;
-import com.huawei.unibi.molap.olap.MolapDef;
-import com.huawei.unibi.molap.olap.MolapDef.CubeDimension;
 //import mondrian.olap.Connection;
 //import mondrian.olap.DriverManager;
 //import mondrian.olap.MondrianDef.CubeDimension;
@@ -168,15 +168,12 @@ public final class MolapQueryUtil
 		String dataPath = executerModel.getCube().getMetaDataFilepath() + File.separator + MolapCommonConstants.LOADMETADATA_FILENAME + MolapCommonConstants.MOLAP_METADATA_EXTENSION;
 		DataInputStream dataInputStream = null;
 		Gson gsonObjectToRead = new Gson();
-		AtomicFileOperations fileOperation = new AtomicFileOperationsImpl(dataPath, FileFactory.getFileType(dataPath));
 		try {
 			if (FileFactory.isFileExist(dataPath,
 					FileFactory.getFileType(dataPath))) {
 
-			    dataInputStream = fileOperation.openForRead();
-			    
-			/*	dataInputStream = FileFactory.getDataInputStream(dataPath,
-						FileFactory.getFileType(dataPath));*/
+				dataInputStream = FileFactory.getDataInputStream(dataPath,
+						FileFactory.getFileType(dataPath));
 
 				BufferedReader buffReader = new BufferedReader(
 						new InputStreamReader(dataInputStream, "UTF-8"));
@@ -195,25 +192,6 @@ public final class MolapQueryUtil
 												.getLoadStatus()) || MolapCommonConstants.STORE_LOADSTATUS_PARTIAL_SUCCESS
 												.equalsIgnoreCase(loadMetadataDetails
 														.getLoadStatus())) {
-						    // check for merged loads.
-						    if(null != loadMetadataDetails.getMergedLoadName()){
-	                            
-	                            if(!listOfValidSlices.contains(loadMetadataDetails.getMergedLoadName() ))
-	                            {
-	                                listOfValidSlices.add(loadMetadataDetails
-	                                    .getMergedLoadName());
-	                            }
-	                            // if merged load is updated then put it in updated list
-	                            if(MolapCommonConstants.MARKED_FOR_UPDATE
-                                        .equalsIgnoreCase(loadMetadataDetails
-                                                .getLoadStatus()))
-	                            {
-	                                listOfValidUpdatedSlices.add(loadMetadataDetails
-	                                        .getMergedLoadName());
-	                            }
-	                            continue;
-	                        }
-						    
 							if(MolapCommonConstants.MARKED_FOR_UPDATE
 										.equalsIgnoreCase(loadMetadataDetails
 												.getLoadStatus())){
@@ -263,12 +241,8 @@ public final class MolapQueryUtil
 		String factTableName = cube.getFactTableName();
 		executorModel.setCube(cube);
         executorModel.sethIterator(new MolapResultHolder(new ArrayList<Type>(MolapCommonConstants.CONSTANT_SIZE_TEN)));
-        
-        fillExecutorModel(logicalPlan, cube,schema, executorModel, factTableName);
+        fillExecutorModel(logicalPlan, cube, executorModel, factTableName);
         List<Dimension> dims = new ArrayList<Dimension>(MolapCommonConstants.CONSTANT_SIZE_TEN);
-        //since a new executorModel instance has been created the same has to be updated with
-        //high cardinality property.
-        
         dims.addAll(Arrays.asList(executorModel.getDims()));
 //        fillDimensionAggregator(logicalPlan, executorModel, cube.getDimensions(factTableName));
 //        dims.addAll(executorModel.getConstraints().keySet());
@@ -296,7 +270,7 @@ public final class MolapQueryUtil
 //                        suitableTableName, cube.getDimensions(factTableName)))
         if(!suitableTableName.equals(factTableName))
         {
-            fillExecutorModel(logicalPlan, cube,schema, executorModel,
+            fillExecutorModel(logicalPlan, cube, executorModel,
                     suitableTableName);
             executorModel.setAggTable(true);
             fillDimensionAggregator(logicalPlan, schema, cube, executorModel);
@@ -321,13 +295,12 @@ public final class MolapQueryUtil
 	}
 
 	private static void fillExecutorModel(MolapQueryPlan logicalPlan,
-			Cube cube, Schema schema, MolapQueryExecutorModel executorModel,
+			Cube cube, MolapQueryExecutorModel executorModel,
 			String factTableName) 
 	{
 		executorModel.setFactTable(factTableName);
         List<Dimension> dimensions = cube.getDimensions(factTableName);
 		executorModel.setDims(getDimensions(logicalPlan.getDimensions(), dimensions));
-		updateDimensionWithHighCardinalityVal(schema,executorModel);
 		fillSortInfoInModel(executorModel,logicalPlan.getSortedDimemsions(),dimensions);
         List<Measure> measures = cube.getMeasures(factTableName);
 		executorModel.setMsrs(getMeasures(logicalPlan.getMeasures(), measures,executorModel.isDetailQuery(),executorModel));
@@ -1304,7 +1277,7 @@ public final class MolapQueryUtil
         String basePath = MolapUtil.getCarbonStorePath(schema.name, schema.cubes[0].name)/*MolapProperties.getInstance().getProperty(MolapCommonConstants.STORE_LOCATION,
                 MolapCommonConstants.STORE_LOCATION_DEFAULT_VAL)*/;
     	InMemoryCubeStore.getInstance().loadCube(schema, cube, partitionID,sliceLoadPaths,sliceUpdatedLoadPaths,factTableName,basePath, currentRestructNumber, cubeCreationTime);
-    }   
+    }
     
     public static void createDataSource(int currentRestructNumber, Schema schema, Cube cube, String partitionID,
             List<String> sliceLoadPaths, List<String> sliceUpdatedLoadPaths,
@@ -1382,31 +1355,6 @@ public final class MolapQueryUtil
     
     /**
      * 
-     * @param schema
-     * @param queryModel
-     */
-	public  static void updateDimensionWithHighCardinalityVal(
-			MolapDef.Schema schema, MolapQueryExecutorModel queryModel) {
-
-		CubeDimension[] cubeDimensions = schema.cubes[0].dimensions;
-		Dimension[] metadataDimensions = queryModel.getDims();
-
-		for (Dimension metadataDimension : metadataDimensions) {
-			for (CubeDimension cubeDimension : cubeDimensions) {
-				if (metadataDimension.getName().equals(cubeDimension.name)
-						&& cubeDimension.highCardinality) {
-					metadataDimension
-							.setHighCardinalityDims(cubeDimension.highCardinality);
-					break;
-				}
-
-			}
-		}
-
-	}
-    
-    /**
-     * 
      * @param queryModel
      * @param listLoadFolders
      * @param cubeUniqueName
@@ -1418,7 +1366,7 @@ public final class MolapQueryUtil
             MolapQueryExecutorModel queryModel, List<String> listLoadFolders,
             String cubeUniqueName) throws RuntimeException
     {
-        Set<String> columns = getColumnList(queryModel, cubeUniqueName);
+        Set<String> columns = getColumnList(queryModel);
         return loadRequiredLevels(listLoadFolders, cubeUniqueName, columns);
     }
 
@@ -1447,7 +1395,7 @@ public final class MolapQueryUtil
      * @return
      * 
      */
-    public static Set<String> getColumnList(MolapQueryExecutorModel queryModel, String cubeUniqueName)
+    public static Set<String> getColumnList(MolapQueryExecutorModel queryModel)
     {
         Set<String> queryColumns = new HashSet<String>(
                 MolapCommonConstants.DEFAULT_COLLECTION_SIZE);
@@ -1455,13 +1403,6 @@ public final class MolapQueryUtil
         Cube cube = queryModel.getCube();
         List<Dimension> dimensions = cube
                 .getDimensions(cube.getFactTableName());
-        LOGGER.info(MolapCoreLogEvent.UNIBI_MOLAPCORE_MSG, "@@@@Dimension size :: " + dimensions.size());
-        if(dimensions.isEmpty())
-        {
-        	cube = MolapMetadata.getInstance().getCube(cubeUniqueName);
-        	dimensions = cube
-                    .getDimensions(cube.getFactTableName());
-        }
         List<Measure> measures = cube.getMeasures(cube.getFactTableName());
         traverseAndPopulateColumnList(filterExpression, dimensions, measures,
                 queryColumns);
diff --git a/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/KeyVal.scala b/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/KeyVal.scala
index 05f84cd..1845516 100644
--- a/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/KeyVal.scala
+++ b/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/KeyVal.scala
@@ -1,11 +1,11 @@
 
 /**
- * It is just Key value class. I don't get any other alternate to make the RDD class to work with my minimum knowledge in scala.
- * May be I will remove later once I gain good knowledge :)
+  * It is just Key value class. I don't get any other alternate to make the RDD class to work with my minimum knowledge in scala.
+  * May be I will remove later once I gain good knowledge :)
   *
- * @author R00900208
- *
- */
+  * @author R00900208
+  *
+  */
 
 package com.huawei.datasight.spark
 
@@ -43,20 +43,8 @@ class PartitionResultImpl extends PartitionResult[Int, Boolean] {
   override def getKey(key: Int, value: Boolean) = (key, value)
 }
 
-trait MergeResult[K,V] extends Serializable
-{
-  def getKey(key : Int,value : Boolean ) : (K,V) 
-    
-}
-
-class MergeResultImpl extends MergeResult[Int,Boolean]
-{
-  override def getKey(key : Int,value : Boolean) = (key,value)
-}
-
-trait DeletedLoadResult[K,V] extends Serializable
-{
-  def getKey(key : String,value : String) : (K,V) 
+trait DeletedLoadResult[K, V] extends Serializable {
+  def getKey(key: String, value: String): (K, V)
 }
 
 class DeletedLoadResultImpl extends DeletedLoadResult[String, String] {
diff --git a/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/SparkQueryExecutor.scala b/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/SparkQueryExecutor.scala
index 44f5155..17a1fd6 100644
--- a/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/SparkQueryExecutor.scala
+++ b/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/SparkQueryExecutor.scala
@@ -106,7 +106,8 @@ object SparkQueryExecutor {
 
   def typeCast(value: Any): Object = {
     value match {
-      case m: MeasureAggregator => m.getValue().asInstanceOf[Object]
+      //  TODO here we hardcode just for test query
+      case m: MeasureAggregator => m.getDoubleValue().asInstanceOf[Object]
       case _ => value.asInstanceOf[Object]
     }
   }
@@ -551,13 +552,17 @@ class SparkQueryExecutor(sparkUrl: String, sparkBasePath: String, schemaContent:
 class MyRegistrator extends KryoRegistrator {
   override def registerClasses(kryo: Kryo) {
     kryo.register(classOf[MeasureAggregator])
-    kryo.register(classOf[AvgAggregator])
+    kryo.register(classOf[AvgDoubleAggregator])
+    kryo.register(classOf[AvgLongAggregator])
+    kryo.register(classOf[AvgBigDecimalAggregator])
     kryo.register(classOf[CountAggregator])
     kryo.register(classOf[DistinctCountAggregator])
     kryo.register(classOf[DistinctStringCountAggregator])
     kryo.register(classOf[MaxAggregator])
     kryo.register(classOf[MinAggregator])
-    kryo.register(classOf[SumAggregator])
+    kryo.register(classOf[SumDoubleAggregator])
+    kryo.register(classOf[SumLongAggregator])
+    kryo.register(classOf[SumBigDecimalAggregator])
     kryo.register(classOf[GroupMeasureFilterModel])
     kryo.register(classOf[Double2ObjectOpenHashMap[Object]])
     kryo.register(classOf[Hash])
diff --git a/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/agg/MolapAggregates.scala b/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/agg/MolapAggregates.scala
index f6eb9c9..adede83 100644
--- a/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/agg/MolapAggregates.scala
+++ b/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/agg/MolapAggregates.scala
@@ -60,8 +60,8 @@ case class CountMolap(child: Expression) extends UnaryExpression with PartialAgg
   }
 
   override def newInstance() = new CountFunctionMolap(child, this, false)
-
-  implicit def toAggregates(aggregate: MeasureAggregator): Double = aggregate.getValue()
+//TODO here we hardcode just for test query
+  implicit def toAggregates(aggregate: MeasureAggregator): Double = aggregate.getDoubleValue()
 }
 
 case class CountMolapFinal(child: Expression, origDataType: DataType) extends AggregateExpression1 {
@@ -170,8 +170,8 @@ case class SumMolap(child: Expression, castedDataType: DataType = null) extends
   }
 
   override def newInstance() = new SumFunctionMolap(child, this, false)
-
-  implicit def toAggregates(aggregate: MeasureAggregator): Double = aggregate.getValue()
+  //TODO here we hardcode just for test query
+  implicit def toAggregates(aggregate: MeasureAggregator): Double = aggregate.getDoubleValue()
 }
 
 case class SumMolapFinal(child: Expression, origDataType: DataType) extends AggregateExpression1 {
@@ -329,9 +329,29 @@ case class AverageFunctionMolap(expr: Expression, base: AggregateExpression1, fi
     val agg = resolution match {
       case s: MeasureAggregator => s
       case s => {
-        val dc = new AvgAggregator; if (s != null) {
-          dc.agg(s.toString.toDouble, null, 0, 0); dc.setNewValue(s.toString.toDouble)
-        }; dc
+        var dc: MeasureAggregator = null
+        if(s != null)
+        {
+          if (s.isInstanceOf[Double])
+          {
+            dc = new AvgDoubleAggregator
+            dc.agg(s.toString.toDouble)
+            dc.setNewValue(s.toString.toDouble)
+          }
+          else if (s.isInstanceOf[Int])
+          {
+            dc = new AvgLongAggregator
+            dc.agg(s.toString.toLong)
+            dc.setNewValue(s.toString.toLong)
+          }
+          else if (s.isInstanceOf[java.math.BigDecimal])
+          {
+            dc = new AvgBigDecimalAggregator
+            dc.agg(new java.math.BigDecimal(s.toString))
+            dc.setNewValue(new java.math.BigDecimal(s.toString))
+          }
+        }
+        dc
       }
     }
     if (avg == null) avg = agg else avg.merge(agg)
@@ -342,7 +362,8 @@ case class AverageFunctionMolap(expr: Expression, base: AggregateExpression1, fi
       if (avg.isFirstTime())
         null
       else
-        Cast(Literal(avg.getValue), base.dataType).eval(null)
+      //  TODO here we hardcode just for test query
+        Cast(Literal(avg.getDoubleValue), base.dataType).eval(null)
     else avg
 }
 
@@ -364,15 +385,15 @@ case class CountFunctionMolap(expr: Expression, base: AggregateExpression1, fina
       case others =>
         val agg1: MeasureAggregator = new CountAggregator
         if (others != null) {
-          agg1.agg(0, null, 0, 0)
+          agg1.agg(0)
           //agg1.setNewValue(others.toString.toDouble)
         }
         agg1
     }
     if (count == null) count = agg else count.merge(agg)
   }
-
-  override def eval(input: InternalRow): Any = if (finalAgg && count != null) if (count.isFirstTime()) 0L else Cast(Literal(count.getValue), base.dataType).eval(null) else count
+  //  TODO here we hardcode just for test query
+  override def eval(input: InternalRow): Any = if (finalAgg && count != null) if (count.isFirstTime()) 0L else Cast(Literal(count.getDoubleValue), base.dataType).eval(null) else count
 
   //override def eval(input: Row): Any = if(finalAgg) if(count.isFirstTime()) 0 else count.getValue.toLong else count
 }
@@ -396,9 +417,29 @@ case class SumFunctionMolap(expr: Expression, base: AggregateExpression1, finalA
     val agg = resolution match {
       case s: MeasureAggregator => s
       case s => {
-        val dc = new SumAggregator; if (s != null) {
-          dc.agg(s.toString.toDouble, null, 0, 0); dc.setNewValue(s.toString.toDouble)
-        }; dc
+        var dc: MeasureAggregator = null
+        if(s != null)
+        {
+          if (s.isInstanceOf[Double])
+          {
+            dc = new SumDoubleAggregator
+            dc.agg(s.toString.toDouble)
+            dc.setNewValue(s.toString.toDouble)
+          }
+          else if (s.isInstanceOf[Int])
+          {
+            dc = new SumLongAggregator
+            dc.agg(s.toString.toLong)
+            dc.setNewValue(s.toString.toLong)
+          }
+          else if (s.isInstanceOf[java.math.BigDecimal])
+          {
+            dc = new SumBigDecimalAggregator
+            dc.agg(new java.math.BigDecimal(s.toString))
+            dc.setNewValue(new java.math.BigDecimal(s.toString))
+          }
+        }
+        dc
       }
     }
     if (sum == null) sum = agg else sum.merge(agg)
@@ -408,7 +449,8 @@ case class SumFunctionMolap(expr: Expression, base: AggregateExpression1, finalA
     if (finalAgg && sum != null)
       if (sum.isFirstTime())
         null
-      else Cast(Literal(sum.getValue), base.dataType).eval(input)
+      //  TODO here we hardcode just for test query
+      else Cast(Literal(sum.getDoubleValue), base.dataType).eval(input)
 
     else sum
 }
@@ -432,8 +474,8 @@ case class MaxFunctionMolap(expr: Expression, base: AggregateExpression1, finalA
       case s: MeasureAggregator => s
       case s => {
         val dc = new MaxAggregator; if (s != null) {
-          dc.agg(s.toString.toDouble, null, 0, 0); dc.setNewValue(s.toString.toDouble)
-        }; dc
+          dc.agg(s.toString.toDouble);dc.setNewValue(s.toString.toDouble)
+        };dc
       }
     }
     if (max == null) max = agg else max.merge(agg)
@@ -462,8 +504,8 @@ case class MinFunctionMolap(expr: Expression, base: AggregateExpression1, finalA
       case s: MeasureAggregator => s
       case s => {
         val dc = new MinAggregator; if (s != null) {
-          dc.agg(s.toString.toDouble, null, 0, 0); dc.setNewValue(s.toString.toDouble)
-        }; dc
+          dc.agg(s.toString.toDouble);dc.setNewValue(s.toString.toDouble)
+        };dc
       }
     }
     if (min == null) min = agg else min.merge(agg)
@@ -498,7 +540,23 @@ case class SumDisctinctFunctionMolap(expr: Expression, base: AggregateExpression
       case s: MeasureAggregator => s
       case null => null
       case s => {
-        val dc = new SumDistinctAggregator; dc.setNewValue(s.toString.toDouble); dc
+        var dc: MeasureAggregator = null
+        if (s.isInstanceOf[Double])
+        {
+          dc = new SumDistinctDoubleAggregator
+          dc.setNewValue(s.toString.toDouble)
+        }
+        else if (s.isInstanceOf[Int])
+        {
+          dc = new SumDistinctLongAggregator
+          dc.setNewValue(s.toString.toLong)
+        }
+        else if (s.isInstanceOf[java.math.BigDecimal])
+        {
+          dc = new SumDistinctBigDecimalAggregator
+          dc.setNewValue(new java.math.BigDecimal(s.toString))
+        }
+        dc
       }
     }
     if (agg == null) distinct
@@ -575,7 +633,8 @@ case class CountDistinctFunctionMolapFinal(expr: Expression, base: AggregateExpr
     else if (count.isFirstTime())
       Cast(Literal(0), base.dataType).eval(null)
     else
-      Cast(Literal(count.getValue), base.dataType).eval(null)
+    //  TODO here we hardcode just for test query
+      Cast(Literal(count.getDoubleValue), base.dataType).eval(null)
 }
 
 case class FirstFunctionMolap(expr: Expression, base: AggregateExpression1) extends AggregateFunction1 {
@@ -619,7 +678,8 @@ case class FlattenExpr(expr: Expression) extends Expression with CodegenFallback
 
   override def eval(input: InternalRow): Any = {
     expr.eval(input) match {
-      case d: MeasureAggregator => d.getValue()
+      //  TODO here we hardcode just for test query
+      case d: MeasureAggregator => d.getDoubleValue()
       case others => others
     }
   }
@@ -645,7 +705,8 @@ case class FlatAggregatorsExpr(expr: Expression) extends Expression with Codegen
   override def eval(input: InternalRow): Any = {
     expr.eval(input) match {
       case d: MeasureAggregator => {
-        d.setNewValue(d.getValue())
+        //  TODO here we hardcode just for test query
+        d.setNewValue(d.getDoubleValue())
         d
       }
       case others => others
@@ -673,3 +734,57 @@ case class PositionLiteral(expr: Expression, intermediateDataType: DataType) ext
   }
 }
 
+case class CommonMolapParAggExpr(originalAggExpr: AggregateExpression1, positionLiteral: Expression) extends AggregateExpression1 {
+  def this() = this(null, null)
+
+  override def children = positionLiteral :: Nil
+
+  override def references = positionLiteral.references
+
+  override def nullable = false
+
+  override def dataType = MeasureAggregatorUDT
+
+  override def toString = s"CommonMolapAggExpr($originalAggExpr)"
+
+  override lazy val resolved: Boolean = childrenResolved
+
+  override def newInstance() = new CommonMolapPartialAggFunc(originalAggExpr, positionLiteral)
+
+  implicit def toAggregates(aggregate: MeasureAggregator): Double = {
+    //  TODO here we hardcode just for test query
+    aggregate.getDoubleValue()
+  }
+}
+
+case class CommonMolapPartialAggFunc(base: AggregateExpression1, positionLiteral: Expression) extends AggregateFunction1 {
+  def this() = this(null, null) // Required for serialization.
+
+  private var currentAgg: CustomMeasureAggregator = null
+
+  override def update(input: InternalRow): Unit = {
+    {
+      val br = positionLiteral.collectFirst({ case a@BoundReference(_, _, _) => a })
+
+      val resolution =
+        if (br.isDefined) {
+          input.get(br.get.ordinal, MeasureAggregatorUDT)
+        } else {
+          positionLiteral.eval(input)
+        }
+
+      val agg = resolution match {
+        case m: CustomMeasureAggregator => if (currentAgg == null) currentAgg = m else currentAgg.merge(m)
+        case null => //ignore
+        case others => throw new Exception("Invalid aggregate Type received from Molap: " + others.getClass + " " + others)
+      }
+    }
+  }
+
+  override def eval(input: InternalRow): Any = {
+    val output =
+      if (currentAgg == null) base.newInstance.eval(input)
+      else currentAgg.getValueObject
+    output
+  }
+}
diff --git a/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/processors/MolapScalaUtil.scala b/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/processors/MolapScalaUtil.scala
index fc22c49..8e34967 100644
--- a/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/processors/MolapScalaUtil.scala
+++ b/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/processors/MolapScalaUtil.scala
@@ -3,7 +3,6 @@ package com.huawei.datasight.spark.processors
 import org.apache.spark.sql.types._
 import com.huawei.unibi.molap.engine.expression.{DataType => MolapDataType}
 import com.huawei.unibi.molap.constants.MolapCommonConstants
-import org.apache.spark.sql.cubemodel.Level
 
 object MolapScalaUtil {
   def convertSparkToMolapDataType(dataType: org.apache.spark.sql.types.DataType): MolapDataType =
@@ -17,8 +16,6 @@ object MolapScalaUtil {
       case DateType => MolapDataType.DateType
       case BooleanType => MolapDataType.BooleanType
       case TimestampType => MolapDataType.TimestampType
-      case ArrayType(_,_) => MolapDataType.ArrayType
-      case StructType(_) => MolapDataType.StructType
       case NullType => MolapDataType.NullType
     }
 
@@ -36,26 +33,9 @@ object MolapScalaUtil {
       case MolapCommonConstants.DATE_TYPE => MolapCommonConstants.STRING
       case MolapCommonConstants.BOOLEAN_TYPE => MolapCommonConstants.STRING
       case MolapCommonConstants.TIMESTAMP_TYPE => MolapCommonConstants.TIMESTAMP
-      case anyType => anyType
+      case _ => MolapCommonConstants.NUMERIC
     }
-  
-  def convertSparkColumnToMolapLevel(field : (String,String)): Seq[Level] = 
-    field._2 match {
-      case MolapCommonConstants.STRING_TYPE => Seq(Level(field._1, field._1, Int.MaxValue, MolapCommonConstants.STRING))
-      case MolapCommonConstants.INTEGER_TYPE => Seq(Level(field._1, field._1, Int.MaxValue, MolapCommonConstants.INTEGER))
-      case MolapCommonConstants.BYTE_TYPE => Seq(Level(field._1, field._1, Int.MaxValue, MolapCommonConstants.INTEGER))
-      case MolapCommonConstants.SHORT_TYPE => Seq(Level(field._1, field._1, Int.MaxValue, MolapCommonConstants.INTEGER))
-      case MolapCommonConstants.LONG_TYPE => Seq(Level(field._1, field._1, Int.MaxValue, MolapCommonConstants.NUMERIC))
-      case MolapCommonConstants.DOUBLE_TYPE => Seq(Level(field._1, field._1, Int.MaxValue, MolapCommonConstants.NUMERIC))
-      case MolapCommonConstants.FLOAT_TYPE => Seq(Level(field._1, field._1, Int.MaxValue, MolapCommonConstants.NUMERIC))
-      case MolapCommonConstants.DECIMAL_TYPE => Seq(Level(field._1, field._1, Int.MaxValue, MolapCommonConstants.NUMERIC))
-      case MolapCommonConstants.DATE_TYPE => Seq(Level(field._1, field._1, Int.MaxValue, MolapCommonConstants.STRING))
-      case MolapCommonConstants.BOOLEAN_TYPE => Seq(Level(field._1, field._1, Int.MaxValue, MolapCommonConstants.STRING))
-      case MolapCommonConstants.TIMESTAMP_TYPE => Seq(Level(field._1, field._1, Int.MaxValue, MolapCommonConstants.TIMESTAMP))
-//      case MolapCommonConstants.ARRAY_TYPE => Seq(Level(field._1, field._1, Int.MaxValue, MolapCommonConstants.ARRAY))
-//      case MolapCommonConstants.STRUCT_TYPE => Seq(Level(field._1, field._1, Int.MaxValue, MolapCommonConstants.STRUCT))
-//      case _ => MolapCommonConstants.NUMERIC
-  	}
+
   //  def toSparkType(obj : Any): Any = obj match {
   //      case s: String => UTF8String(s)
   //      case i: Integer=> IntegerType(i)
diff --git a/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/rdd/MolapDataRDD.scala b/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/rdd/MolapDataRDD.scala
index 78d0b33..28a7cd2 100644
--- a/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/rdd/MolapDataRDD.scala
+++ b/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/rdd/MolapDataRDD.scala
@@ -152,13 +152,11 @@ class MolapDataRDD[K, V](
           MolapProperties.getInstance().addProperty("high.cardinality.value", "100000");
           MolapProperties.getInstance().addProperty("is.compressed.keyblock", "false");
           MolapProperties.getInstance().addProperty("molap.leaf.node.size", "120000");
-          
           //          }
 
           molapQueryModel.setCube(cube)
           molapQueryModel.setOutLocation(dataPath)
         }
-     MolapQueryUtil.updateDimensionWithHighCardinalityVal(schema,molapQueryModel)
         
      if(MolapQueryUtil.isQuickFilter(molapQueryModel)){
          rowIterator = MolapQueryUtil.getQueryExecuter(molapQueryModel.getCube(), molapQueryModel.getFactTable()).executeDimension(molapQueryModel);
diff --git a/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/rdd/MolapDataRDDFactory.scala b/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/rdd/MolapDataRDDFactory.scala
index 2ddd321..9aa926a 100644
--- a/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/rdd/MolapDataRDDFactory.scala
+++ b/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/rdd/MolapDataRDDFactory.scala
@@ -1,6 +1,6 @@
 /**
- *
- */
+  *
+  */
 package com.huawei.datasight.spark.rdd
 
 import scala.collection.JavaConversions.asScalaBuffer
@@ -21,7 +21,6 @@ import com.huawei.datasight.molap.spark.util.LoadMetadataUtil
 import com.huawei.datasight.spark.DeletedLoadResultImpl
 import com.huawei.datasight.spark.KeyVal
 import com.huawei.datasight.spark.KeyValImpl
-import com.huawei.datasight.spark.MergeResultImpl
 import com.huawei.datasight.spark.RestructureResultImpl
 import com.huawei.datasight.spark.ResultImpl
 import com.huawei.datasight.spark.processors.OlapUtil
@@ -43,23 +42,21 @@ import scala.collection.mutable.{ArrayBuffer, ListBuffer}
 import com.huawei.datasight.molap.core.load.LoadMetadataDetails
 import com.huawei.datasight.spark.PartitionResultImpl
 import com.huawei.unibi.molap.util.MolapDataProcessorUtil
-import com.huawei.datasight.molap.merger.MolapDataMergerUtil
-import com.huawei.unibi.molap.datastorage.store.impl.FileFactory
 
 /**
- * This is the factory class which can create different RDD depends on user needs.
+  * This is the factory class which can create different RDD depends on user needs.
   *
- * @author R00900208
- */
+  * @author R00900208
+  */
 object MolapDataRDDFactory extends Logging {
 
- val LOGGER = LogServiceFactory.getLogService(MolapDataRDDFactory.getClass().getName());
+  val LOGGER = LogServiceFactory.getLogService(MolapDataRDDFactory.getClass().getName());
 
 
   /**
-   * It creates the RDD which can access the Hbase file system directly and reads the region files and executes the query on it.
-   * It creates split for each region and reads the files. This RDD is best suitable if the result data is very big.
-   */
+    * It creates the RDD which can access the Hbase file system directly and reads the region files and executes the query on it.
+    * It creates split for each region and reads the files. This RDD is best suitable if the result data is very big.
+    */
   //  def newMolapDataDirectRDD(sc : SparkContext,molapQueryModel: MolapQueryPlan,
   //    conf: Configuration)  = {
   //
@@ -92,20 +89,20 @@ object MolapDataRDDFactory extends Logging {
   }
 
   def loadMolapData(sc: SQLContext,
-    molapLoadModel: MolapLoadModel,
-    storeLocation: String,
-    hdfsStoreLocation: String,
-    kettleHomePath: String,
-    partitioner: Partitioner,
-    columinar: Boolean,
-    isAgg: Boolean,
+                    molapLoadModel: MolapLoadModel,
+                    storeLocation: String,
+                    hdfsStoreLocation: String,
+                    kettleHomePath: String,
+                    partitioner: Partitioner,
+                    columinar: Boolean,
+                    isAgg: Boolean,
                     partitionStatus: String = MolapCommonConstants.STORE_LOADSTATUS_SUCCESS) {
     val cube = MolapMetadata.getInstance().getCubeWithCubeName(molapLoadModel.getCubeName(), molapLoadModel.getSchemaName());
     var currentRestructNumber = -1
     //    val molapLock = new MetadataLock(cube.getMetaDataFilepath())
-   try {
+    try {
 
-     LOGGER.audit("The data load request has been received.");
+      LOGGER.audit("The data load request has been received.");
 
       //      if (molapLock.lock(MolapCommonConstants.NUMBER_OF_TRIES_FOR_LOAD_METADATA_LOCK, MolapCommonConstants.MAX_TIMEOUT_FOR_LOAD_METADATA_LOCK)) {
       //        logInfo("Successfully able to get the cube metadata file lock")
@@ -115,18 +112,18 @@ object MolapDataRDDFactory extends Logging {
       //        sys.error("Not able to acquire lock for data load.")
       //      }
 
-    currentRestructNumber = MolapUtil.checkAndReturnCurrentRestructFolderNumber(cube.getMetaDataFilepath(), "RS_", false)
+      currentRestructNumber = MolapUtil.checkAndReturnCurrentRestructFolderNumber(cube.getMetaDataFilepath(), "RS_", false)
       if (-1 == currentRestructNumber) {
-      currentRestructNumber = 0
-    }
+        currentRestructNumber = 0
+      }
 
-    //Check if any load need to be deleted before loading new data
+      //Check if any load need to be deleted before loading new data
       deleteLoadsAndUpdateMetadata(molapLoadModel, cube, partitioner, hdfsStoreLocation, false, currentRestructNumber)
       if (null == molapLoadModel.getLoadMetadataDetails) {
-      readLoadMetadataDetails(molapLoadModel, hdfsStoreLocation)
-    }
+        readLoadMetadataDetails(molapLoadModel, hdfsStoreLocation)
+      }
 
-    var currentLoadCount = -1
+      var currentLoadCount = -1
       if (molapLoadModel.getLoadMetadataDetails().size() > 0) {
         for (eachLoadMetaData <- molapLoadModel.getLoadMetadataDetails()) {
           val loadCount = Integer.parseInt(eachLoadMetaData.getLoadName())
@@ -140,9 +137,9 @@ object MolapDataRDDFactory extends Logging {
         currentLoadCount += 1;
       }
 
-    // reading the start time of data load.
-    val loadStartTime = MolapLoaderUtil.readCurrentTime();
-    val cubeCreationTime = CarbonEnv.getInstance(sc).carbonCatalog.getCubeCreationTime(molapLoadModel.getSchemaName, molapLoadModel.getCubeName)
+      // reading the start time of data load.
+      val loadStartTime = MolapLoaderUtil.readCurrentTime();
+      val cubeCreationTime = CarbonEnv.getInstance(sc).carbonCatalog.getCubeCreationTime(molapLoadModel.getSchemaName, molapLoadModel.getCubeName)
       val schemaLastUpdatedTime = CarbonEnv.getInstance(sc).carbonCatalog.getSchemaLastUpdatedTime(molapLoadModel.getSchemaName, molapLoadModel.getCubeName)
       val status = new MolapDataLoadRDD(sc.sparkContext, new ResultImpl(), molapLoadModel, storeLocation, hdfsStoreLocation, kettleHomePath, partitioner, columinar, currentRestructNumber, currentLoadCount, cubeCreationTime, schemaLastUpdatedTime).collect()
       val newStatusMap = scala.collection.mutable.Map.empty[String, String]
@@ -157,21 +154,21 @@ object MolapDataRDDFactory extends Logging {
         }
       }
 
-    var loadStatus = MolapCommonConstants.STORE_LOADSTATUS_SUCCESS
+      var loadStatus = MolapCommonConstants.STORE_LOADSTATUS_SUCCESS
       newStatusMap.foreach {
-      case (key, value) =>
+        case (key, value) =>
           if (value == MolapCommonConstants.STORE_LOADSTATUS_FAILURE) {
             loadStatus = MolapCommonConstants.STORE_LOADSTATUS_FAILURE
-        }
+          }
           else if (value == MolapCommonConstants.STORE_LOADSTATUS_PARTIAL_SUCCESS && !loadStatus.equals(MolapCommonConstants.STORE_LOADSTATUS_FAILURE)) {
-          loadStatus = MolapCommonConstants.STORE_LOADSTATUS_PARTIAL_SUCCESS
-        }
+            loadStatus = MolapCommonConstants.STORE_LOADSTATUS_PARTIAL_SUCCESS
+          }
       }
 
       if (loadStatus != MolapCommonConstants.STORE_LOADSTATUS_FAILURE &&
         partitionStatus == MolapCommonConstants.STORE_LOADSTATUS_PARTIAL_SUCCESS) {
-      loadStatus = partitionStatus
-    }
+        loadStatus = partitionStatus
+      }
 
       //      status.foreach {eachLoadStatus =>
       //        val state = eachLoadStatus._2.getLoadStatus
@@ -220,56 +217,25 @@ object MolapDataRDDFactory extends Logging {
         throw new Exception(message)
       }
       else {
-       val (result, metadataDetails) = status(0)
+        val (result, metadataDetails) = status(0)
         if (!isAgg) {
           MolapLoaderUtil.recordLoadMetadata(result, metadataDetails, molapLoadModel, loadStatus, loadStartTime)
         }
         else if (!molapLoadModel.isRetentionRequest()) {
           try {
-              CarbonEnv.getInstance(sc).carbonCatalog.updateCube(molapLoadModel.getSchema, false)(sc)
+            CarbonEnv.getInstance(sc).carbonCatalog.updateCube(molapLoadModel.getSchema, false)(sc)
           }
           catch {
-          case e: Exception =>
-            MolapLoaderUtil.deleteTable(partitioner.partitionCount, molapLoadModel.getSchemaName, molapLoadModel.getCubeName, molapLoadModel.getAggTableName, hdfsStoreLocation, currentRestructNumber)
-           val message = "Aggregation creation failure"
-            throw new Exception(message)
+            case e: Exception =>
+              MolapLoaderUtil.deleteTable(partitioner.partitionCount, molapLoadModel.getSchemaName, molapLoadModel.getCubeName, molapLoadModel.getAggTableName, hdfsStoreLocation, currentRestructNumber)
+              val message = "Aggregation creation failure"
+              throw new Exception(message)
           }
 
 
           logInfo("********schema updated**********")
         }
-       LOGGER.audit("The data loading is successfull.");
-      if(MolapDataMergerUtil.checkIfLoadMergingRequired(cube.getMetaDataFilepath(),molapLoadModel, hdfsStoreLocation,  partitioner.partitionCount, currentRestructNumber))
-      {
-
-          val loadsToMerge = MolapDataMergerUtil.getLoadsToMergeFromHDFS(
-            hdfsStoreLocation, FileFactory.getFileType(hdfsStoreLocation), cube.getMetaDataFilepath(), molapLoadModel, currentRestructNumber, partitioner.partitionCount);
-          
-          if(loadsToMerge.length == 2)
-          {
-          
-              var MergedLoadName = MolapDataMergerUtil.getMergedLoadName(loadsToMerge)
-          
-              var finalMergeStatus = true
-
-              val mergeStatus = new MolapMergerRDD(sc.sparkContext, new MergeResultImpl(), molapLoadModel, storeLocation, hdfsStoreLocation, partitioner, currentRestructNumber, cube.getMetaDataFilepath(), loadsToMerge, MergedLoadName,kettleHomePath,cubeCreationTime).collect
-          
-          
-              mergeStatus.foreach {eachMergeStatus =>
-              val state = eachMergeStatus._2
-              if (state == false)
-                  {
-                      finalMergeStatus=false
-      }
-              }
-          
-              if(finalMergeStatus == true)
-              {
-                  MolapDataMergerUtil.updateLoadMetadataWithMergeStatus(loadsToMerge,cube.getMetaDataFilepath(),MergedLoadName,molapLoadModel)
-              }
-          
-          }
-      }
+        LOGGER.audit("The data loading is successfull.");
       }
 
     }
@@ -301,25 +267,25 @@ object MolapDataRDDFactory extends Logging {
                          cubeName: String,
                          sourcePath: String,
                          targetFolder: String,
-      requiredColumns: Array[String],
-      headers: String,
-      delimiter: String,
-      quoteChar: String,
-      escapeChar: String,
-      multiLine: Boolean,
-      partitioner: Partitioner): String = {
+                         requiredColumns: Array[String],
+                         headers: String,
+                         delimiter: String,
+                         quoteChar: String,
+                         escapeChar: String,
+                         multiLine: Boolean,
+                         partitioner: Partitioner): String = {
     //     val kv:KeyVal[MolapKey,MolapValue] = new KeyValImpl();
 
     val status = new MolapDataPartitionRDD(sc, new PartitionResultImpl(), schemaName, cubeName, sourcePath, targetFolder, requiredColumns, headers, delimiter, quoteChar, escapeChar, multiLine, partitioner).collect
     MolapDataProcessorUtil.renameBadRecordsFromInProgressToNormal("partition/" + schemaName + '/' + cubeName);
-     var loadStatus = MolapCommonConstants.STORE_LOADSTATUS_SUCCESS
+    var loadStatus = MolapCommonConstants.STORE_LOADSTATUS_SUCCESS
     status.foreach {
       case (key, value) =>
         if (value == true) {
           loadStatus = MolapCommonConstants.STORE_LOADSTATUS_PARTIAL_SUCCESS
         }
-      }
-     loadStatus
+    }
+    loadStatus
   }
 
   def mergeMolapData(sc: SQLContext,
@@ -328,29 +294,29 @@ object MolapDataRDDFactory extends Logging {
                      hdfsStoreLocation: String,
                      partitioner: Partitioner) {
     val kv: KeyVal[MolapKey, MolapValue] = new KeyValImpl();
-      val cube = MolapMetadata.getInstance().getCubeWithCubeName(molapLoadModel.getCubeName(), molapLoadModel.getSchemaName());
+    val cube = MolapMetadata.getInstance().getCubeWithCubeName(molapLoadModel.getCubeName(), molapLoadModel.getSchemaName());
     val metaDataPath: String = cube.getMetaDataFilepath()
-      var currentRestructNumber = MolapUtil.checkAndReturnCurrentRestructFolderNumber(metaDataPath, "RS_", false)
+    var currentRestructNumber = MolapUtil.checkAndReturnCurrentRestructFolderNumber(metaDataPath, "RS_", false)
     if (-1 == currentRestructNumber) {
       currentRestructNumber = 0
     }
- //    new MolapMergerRDD(sc.sparkContext,kv,molapLoadModel,storeLocation,hdfsStoreLocation, partitioner, currentRestructNumber).collect
-     
+    new MolapMergerRDD(sc.sparkContext, kv, molapLoadModel, storeLocation, hdfsStoreLocation, partitioner, currentRestructNumber).collect
+
   }
 
-    def deleteLoadByDate(
-      sqlContext: SQLContext,
-    schema: Schema,
-    schemaName: String,
-    cubeName: String,
+  def deleteLoadByDate(
+                        sqlContext: SQLContext,
+                        schema: Schema,
+                        schemaName: String,
+                        cubeName: String,
                         tableName: String,
-    hdfsStoreLocation: String,
-      dateField: String,
+                        hdfsStoreLocation: String,
+                        dateField: String,
                         dateFieldActualName: String,
-      dateValue: String,
-      partitioner: Partitioner) {
+                        dateValue: String,
+                        partitioner: Partitioner) {
 
-      val sc = sqlContext;
+    val sc = sqlContext;
     //Delete the records based on data
     var cube = MolapMetadata.getInstance().getCube(schemaName + "_" + cubeName);
     if (null == cube) {
@@ -368,52 +334,46 @@ object MolapDataRDDFactory extends Logging {
       new DeletedLoadResultImpl(),
       schemaName,
       cube.getOnlyCubeName(),
-        dateField,
-        dateFieldActualName,
+      dateField,
+      dateFieldActualName,
       dateValue,
-        partitioner,
-        cube.getFactTableName,
-        tableName,
-        hdfsStoreLocation,
-        loadMetadataDetailsArray,
-        currentRestructNumber).collect.groupBy(_._1).toMap
+      partitioner,
+      cube.getFactTableName,
+      tableName,
+      hdfsStoreLocation,
+      loadMetadataDetailsArray,
+      currentRestructNumber).collect.groupBy(_._1).toMap
 
     //  var updatedLoadMetadataDetailsList = Seq[LoadMetadataDetails]() 
-      var updatedLoadMetadataDetailsList = new ListBuffer[LoadMetadataDetails]()
+    var updatedLoadMetadataDetailsList = new ListBuffer[LoadMetadataDetails]()
     //get list of updated or deleted load status and update load meta data file     
     if (!resultMap.isEmpty) {
 
       if (resultMap.size == 1) {
 
         if (resultMap.contains("")) {
-           logError("Delete by Date request is failed")
-           sys.error("Delete by Date request is failed, potential causes " + "Empty store or Invalid column type, For more details please refer logs.")
+          logError("Delete by Date request is failed")
+          sys.error("Delete by Date request is failed, potential causes " + "Empty store or Invalid column type, For more details please refer logs.")
 
-       }
+        }
       }
 
       val updatedloadMetadataDetails = loadMetadataDetailsArray.map { elem => {
-          var statusList = resultMap.get(elem.getLoadName())
-          // check for the merged load folder.
-          if(statusList == None && null != elem.getMergedLoadName()) 
-          {
-            statusList = resultMap.get(elem.getMergedLoadName())
-          }
-          
-          if (statusList != None) {
-            elem.setDeletionTimestamp(MolapLoaderUtil.readCurrentTime())
-            //if atleast on MolapCommonConstants.MARKED_FOR_UPDATE status exist, use MARKED_FOR_UPDATE
-            if (statusList.get.forall(status => status._2 == MolapCommonConstants.MARKED_FOR_DELETE)) {
-              elem.setLoadStatus(MolapCommonConstants.MARKED_FOR_DELETE)
-            } else {
-              elem.setLoadStatus(MolapCommonConstants.MARKED_FOR_UPDATE)
-            updatedLoadMetadataDetailsList += elem
-            }
-            elem
+        val statusList = resultMap.get(elem.getLoadName())
+        if (statusList != None) {
+          elem.setDeletionTimestamp(MolapLoaderUtil.readCurrentTime())
+          //if atleast on MolapCommonConstants.MARKED_FOR_UPDATE status exist, use MARKED_FOR_UPDATE
+          if (statusList.get.forall(status => status._2 == MolapCommonConstants.MARKED_FOR_DELETE)) {
+            elem.setLoadStatus(MolapCommonConstants.MARKED_FOR_DELETE)
           } else {
-            elem
+            elem.setLoadStatus(MolapCommonConstants.MARKED_FOR_UPDATE)
+            updatedLoadMetadataDetailsList += elem
           }
+          elem
+        } else {
+          elem
         }
+      }
 
       }
 
@@ -445,9 +405,9 @@ object MolapDataRDDFactory extends Logging {
       }
     }
     else {
-       logError("Delete by Date request is failed")
-       LOGGER.audit("The delete load by date is failed.");
-       sys.error("Delete by Date request is failed, potential causes " + "Empty store or Invalid column type, For more details please refer logs.")
+      logError("Delete by Date request is failed")
+      LOGGER.audit("The delete load by date is failed.");
+      sys.error("Delete by Date request is failed, potential causes " + "Empty store or Invalid column type, For more details please refer logs.")
     }
 
 
@@ -455,23 +415,23 @@ object MolapDataRDDFactory extends Logging {
 
   def alterCube(
                  hiveContext: HiveContext,
-    sc: SparkContext,
-    origUnModifiedSchema: MolapDef.Schema,
-    schema: MolapDef.Schema,
-    schemaName: String,
-    cubeName: String,
-    hdfsStoreLocation: String,
-    addedDimensions: Seq[MolapDef.CubeDimension],
-    addedMeasures: Seq[MolapDef.Measure],
-    validDropDimList: ArrayBuffer[String],
-    validDropMsrList: ArrayBuffer[String],
-    curTime: Long,
-    defaultVals: Map[String, String],
+                 sc: SparkContext,
+                 origUnModifiedSchema: MolapDef.Schema,
+                 schema: MolapDef.Schema,
+                 schemaName: String,
+                 cubeName: String,
+                 hdfsStoreLocation: String,
+                 addedDimensions: Seq[MolapDef.CubeDimension],
+                 addedMeasures: Seq[MolapDef.Measure],
+                 validDropDimList: ArrayBuffer[String],
+                 validDropMsrList: ArrayBuffer[String],
+                 curTime: Long,
+                 defaultVals: Map[String, String],
                  partitioner: Partitioner): Boolean = {
 
-      val cube = MolapMetadata.getInstance().getCubeWithCubeName(cubeName, schemaName);
+    val cube = MolapMetadata.getInstance().getCubeWithCubeName(cubeName, schemaName);
 
-      val metaDataPath: String = cube.getMetaDataFilepath()
+    val metaDataPath: String = cube.getMetaDataFilepath()
     //      val molapLock = new MetadataLock(metaDataPath)
     //      try {
     ////        if (molapLock.lock(MolapCommonConstants.NUMBER_OF_TRIES_FOR_LOAD_METADATA_LOCK, MolapCommonConstants.MAX_TIMEOUT_FOR_LOAD_METADATA_LOCK)) {
@@ -481,55 +441,55 @@ object MolapDataRDDFactory extends Logging {
     //          sys.error("Not able to acquire lock for altering cube.")
     //        }
 
-        //if there is no data loading done, no need to create RS folders
-        val loadMetadataDetailsArray = MolapUtil.readLoadMetadata(metaDataPath).toList
-        if (0 == loadMetadataDetailsArray.size) {
-          CarbonEnv.getInstance(hiveContext).carbonCatalog.updateCube(schema, false)(hiveContext)
-          return true
-        }
+    //if there is no data loading done, no need to create RS folders
+    val loadMetadataDetailsArray = MolapUtil.readLoadMetadata(metaDataPath).toList
+    if (0 == loadMetadataDetailsArray.size) {
+      CarbonEnv.getInstance(hiveContext).carbonCatalog.updateCube(schema, false)(hiveContext)
+      return true
+    }
 
-        var currentRestructNumber = MolapUtil.checkAndReturnCurrentRestructFolderNumber(metaDataPath, "RS_", false)
-        if (-1 == currentRestructNumber) {
-          currentRestructNumber = 0
-        }
+    var currentRestructNumber = MolapUtil.checkAndReturnCurrentRestructFolderNumber(metaDataPath, "RS_", false)
+    if (-1 == currentRestructNumber) {
+      currentRestructNumber = 0
+    }
 
-        val loadStartTime = MolapLoaderUtil.readCurrentTime();
-
-        val resultMap = new MolapAlterCubeRDD(sc,
-          origUnModifiedSchema,
-          schema,
-          schemaName,
-          cubeName,
-          hdfsStoreLocation,
-          addedDimensions,
-          addedMeasures,
-          validDropDimList,
-          validDropMsrList,
-          curTime,
-          defaultVals,
-          currentRestructNumber,
+    val loadStartTime = MolapLoaderUtil.readCurrentTime();
+
+    val resultMap = new MolapAlterCubeRDD(sc,
+      origUnModifiedSchema,
+      schema,
+      schemaName,
+      cubeName,
+      hdfsStoreLocation,
+      addedDimensions,
+      addedMeasures,
+      validDropDimList,
+      validDropMsrList,
+      curTime,
+      defaultVals,
+      currentRestructNumber,
       metaDataPath,
-          partitioner,
-          new RestructureResultImpl()).collect
-
-        var restructureStatus: Boolean = resultMap.forall(_._2)
-
-        if (restructureStatus) {
-          if (addedDimensions.length > 0 || addedMeasures.length > 0) {
-            val molapLoadModel: MolapLoadModel = new MolapLoadModel()
-            molapLoadModel.setCubeName(cubeName)
-            molapLoadModel.setSchemaName(schemaName)
-            molapLoadModel.setSchema(schema);
-            val metadataDetails: LoadMetadataDetails = new LoadMetadataDetails()
-            MolapLoaderUtil.recordLoadMetadata(resultMap(0)._1, metadataDetails, molapLoadModel, MolapCommonConstants.STORE_LOADSTATUS_SUCCESS, loadStartTime)
-            restructureStatus = MolapUtil.createRSMetaFile(metaDataPath, "RS_" + (currentRestructNumber + 1))
-          }
-          if (restructureStatus) {
-            CarbonEnv.getInstance(hiveContext).carbonCatalog.updateCube(schema, false)(hiveContext)
-          }
-        }
+      partitioner,
+      new RestructureResultImpl()).collect
+
+    var restructureStatus: Boolean = resultMap.forall(_._2)
+
+    if (restructureStatus) {
+      if (addedDimensions.length > 0 || addedMeasures.length > 0) {
+        val molapLoadModel: MolapLoadModel = new MolapLoadModel()
+        molapLoadModel.setCubeName(cubeName)
+        molapLoadModel.setSchemaName(schemaName)
+        molapLoadModel.setSchema(schema);
+        val metadataDetails: LoadMetadataDetails = new LoadMetadataDetails()
+        MolapLoaderUtil.recordLoadMetadata(resultMap(0)._1, metadataDetails, molapLoadModel, MolapCommonConstants.STORE_LOADSTATUS_SUCCESS, loadStartTime)
+        restructureStatus = MolapUtil.createRSMetaFile(metaDataPath, "RS_" + (currentRestructNumber + 1))
+      }
+      if (restructureStatus) {
+        CarbonEnv.getInstance(hiveContext).carbonCatalog.updateCube(schema, false)(hiveContext)
+      }
+    }
 
-        restructureStatus
+    restructureStatus
     //      } finally {
     //        if (molapLock != null) {
     //          if (molapLock.unlock()) {
@@ -539,28 +499,28 @@ object MolapDataRDDFactory extends Logging {
     //          }
     //        }
     //      }
-    }
+  }
 
-   def dropAggregateTable(
-      sc: SparkContext,
+  def dropAggregateTable(
+                          sc: SparkContext,
                           schema: String,
-      cube: String,
-      partitioner: Partitioner) {
+                          cube: String,
+                          partitioner: Partitioner) {
     val kv: KeyVal[MolapKey, MolapValue] = new KeyValImpl()
-     new MolapDropAggregateTableRDD(sc, kv, schema, cube, partitioner).collect
+    new MolapDropAggregateTableRDD(sc, kv, schema, cube, partitioner).collect
   }
 
   def dropCube(
-      sc: SparkContext,
+                sc: SparkContext,
                 schema: String,
-      cube: String,
-      partitioner: Partitioner) {
+                cube: String,
+                partitioner: Partitioner) {
     val kv: KeyVal[MolapKey, MolapValue] = new KeyValImpl()
-     new MolapDropCubeRDD(sc, kv, schema, cube, partitioner).collect
+    new MolapDropCubeRDD(sc, kv, schema, cube, partitioner).collect
   }
 
   def cleanFiles(
-      sc: SparkContext,
+                  sc: SparkContext,
                   molapLoadModel: MolapLoadModel,
                   hdfsStoreLocation: String,
                   partitioner: Partitioner) {
@@ -581,12 +541,12 @@ object MolapDataRDDFactory extends Logging {
       }
     }
     finally {
-        if (molapLock.unlock()) {
-          logInfo("unlock the cube metadata file successfully")
-        } else {
-          logError("Unable to unlock the metadata lock")
-        }
+      if (molapLock.unlock()) {
+        logInfo("unlock the cube metadata file successfully")
+      } else {
+        logError("Unable to unlock the metadata lock")
       }
+    }
   }
 
   //    /**
@@ -644,9 +604,9 @@ object MolapDataRDDFactory extends Logging {
 
   def main(args: Array[String]) {
 
-	    val d = SparkContext.jarOfClass(this.getClass)
-	    val ar = new Array[String](d.size)
-	    var i = 0
+    val d = SparkContext.jarOfClass(this.getClass)
+    val ar = new Array[String](d.size)
+    var i = 0
     d.foreach {
       p => ar(i) = p;
         i = i + 1
@@ -655,34 +615,34 @@ object MolapDataRDDFactory extends Logging {
     //	    val sc = new SparkContext("spark://master:7077", "Big Data Direct App", "/opt/spark-1.0.0-rc3/",ar)
 
 
-	        val confs = new SparkConf()
+    val confs = new SparkConf()
       //      .setMaster("spark://master:7077")
       .setMaster("local")
       .setJars(ar)
       .setAppName("Molap Spark Query")
       .setSparkHome("/opt/spark-1.0.0-rc3/")
       .set("spark.scheduler.mode", "FAIR")
-      val sc = new SparkContext(confs)
+    val sc = new SparkContext(confs)
     //	      val sc = new SparkContext("local", "Big Data App", "G:/spark-1.0.0-rc3",ar)
 
-	    val conf = new Configuration();
+    val conf = new Configuration();
 
     //        val schemaPath = "/opt/ravi/PCC_Java.xml"
     //        val schemaPath = "G:/mavenlib/PCC_Java.xml"
-        val schemaPath = "G:\\bibin issues\\SmokeData\\schema\\steelwheels.molap.xml"
+    val schemaPath = "G:\\bibin issues\\SmokeData\\schema\\steelwheels.molap.xml"
     val olapContext = new OlapContext(sc, schemaPath)
     //        val dataPath = "hdfs://master:54310/opt/ravi/store"
-        val dataPath = "F:/TRPSVN/store"
+    val dataPath = "F:/TRPSVN/store"
 
-        Thread.sleep(5000)
+    Thread.sleep(5000)
 
     //        intializeMolap(sc, schemaPath,dataPath,"ODM","PCC")
-        val schema = MolapSchemaParser.loadXML(schemaPath)
+    val schema = MolapSchemaParser.loadXML(schemaPath)
     intializeMolap(sc, schema, dataPath, "SteelWheelsSales", "MOLAPSteelWheels", null, false)
-	    import olapContext._
+    import olapContext._
 
     val holder = OlapUtil.createBaseRDD(olapContext, MolapMetadata.getInstance().getCubeWithCubeName("SteelWheelsSales", "MOLAPSteelWheels"))
-	//    var dd = holder.rdd.asInstanceOf[DataFrame].select('Territory,'Country,'City,'Quantity).groupBy('Territory,'Country)('Territory,'Country,'City,SumMolap('Quantity).as('Q1))
+    //    var dd = holder.rdd.asInstanceOf[DataFrame].select('Territory,'Country,'City,'Quantity).groupBy('Territory,'Country)('Territory,'Country,'City,SumMolap('Quantity).as('Q1))
     //
     //	    dd = dd.topN(3, 'Country, 'Q1)
 
@@ -702,17 +662,17 @@ object MolapDataRDDFactory extends Logging {
     //	    newMolapDataDirectSqlRDD(sc, sql, conf,schemaPath).foreach(println(_))
 
 
-    }
+  }
 
   def deleteLoadsAndUpdateMetadata(molapLoadModel: MolapLoadModel, cube: Cube, partitioner: Partitioner,
                                    hdfsStoreLocation: String, isForceDeletion: Boolean, currentRestructNumber: Integer) {
     if (LoadMetadataUtil.isLoadDeletionRequired(molapLoadModel)) {
 
       val loadMetadataFilePath = MolapLoaderUtil
-                .extractLoadMetadataFileLocation(molapLoadModel);
+        .extractLoadMetadataFileLocation(molapLoadModel);
 
       val details = MolapUtil
-                .readLoadMetadata(loadMetadataFilePath);
+        .readLoadMetadata(loadMetadataFilePath);
 
       //Delete marked loads
       val isUpdationRequired = DeleteLoadFolders.deleteLoadFoldersFromFileSystem(molapLoadModel, partitioner.partitionCount, hdfsStoreLocation, isForceDeletion, currentRestructNumber, details)
@@ -727,8 +687,6 @@ object MolapDataRDDFactory extends Logging {
 
     }
 
-    MolapDataMergerUtil.cleanUnwantedMergeLoadFolder(molapLoadModel, partitioner.partitionCount, hdfsStoreLocation, isForceDeletion, currentRestructNumber)
-    
   }
 
   def LoadAggregateTabAfterRetention(schemaName: String, cubeName: String, factTableName: String, sqlContext: SQLContext, schema: Schema, list: ListBuffer[LoadMetadataDetails]) {
@@ -742,32 +700,32 @@ object MolapDataRDDFactory extends Logging {
     molapLoadModel.setSchemaName(schemaName)
     val table = relation.cubeMeta.schema.cubes(0).fact.asInstanceOf[MolapDef.Table]
     //    if (table.getName == factTableName) {
-      val aggTables = schema.cubes(0).fact.asInstanceOf[MolapDef.Table].aggTables
-      if (null != aggTables && !aggTables.isEmpty) {
-        molapLoadModel.setRetentionRequest(true)
-        molapLoadModel.setLoadMetadataDetails(list)
-        molapLoadModel.setTableName(table.name)
-        molapLoadModel.setSchema(relation.cubeMeta.schema);
+    val aggTables = schema.cubes(0).fact.asInstanceOf[MolapDef.Table].aggTables
+    if (null != aggTables && !aggTables.isEmpty) {
+      molapLoadModel.setRetentionRequest(true)
+      molapLoadModel.setLoadMetadataDetails(list)
+      molapLoadModel.setTableName(table.name)
+      molapLoadModel.setSchema(relation.cubeMeta.schema);
       //        molapLoadModel.setAggLoadRequest(true)
       var storeLocation = MolapProperties.getInstance.getProperty(MolapCommonConstants.STORE_LOCATION_TEMP_PATH, System.getProperty("java.io.tmpdir"))
-        storeLocation = storeLocation + "/molapstore/" + System.currentTimeMillis()
-        val columinar = sqlContext.getConf("molap.is.columnar.storage", "true").toBoolean
-        var kettleHomePath = sqlContext.getConf("molap.kettle.home", null)
-        if (null == kettleHomePath) {
-          kettleHomePath = MolapProperties.getInstance.getProperty("molap.kettle.home");
-        }
-        if (kettleHomePath == null) sys.error(s"molap.kettle.home is not set")
-        //    val aggTableName = aggTableNames.get(0)
+      storeLocation = storeLocation + "/molapstore/" + System.currentTimeMillis()
+      val columinar = sqlContext.getConf("molap.is.columnar.storage", "true").toBoolean
+      var kettleHomePath = sqlContext.getConf("molap.kettle.home", null)
+      if (null == kettleHomePath) {
+        kettleHomePath = MolapProperties.getInstance.getProperty("molap.kettle.home");
+      }
+      if (kettleHomePath == null) sys.error(s"molap.kettle.home is not set")
+      //    val aggTableName = aggTableNames.get(0)
 
-	        MolapDataRDDFactory.loadMolapData(
-	          sqlContext,
-	          molapLoadModel,
-	          storeLocation,
-	          relation.cubeMeta.dataPath,
-	          kettleHomePath,
-	          relation.cubeMeta.partitioner, columinar, true);
+      MolapDataRDDFactory.loadMolapData(
+        sqlContext,
+        molapLoadModel,
+        storeLocation,
+        relation.cubeMeta.dataPath,
+        kettleHomePath,
+        relation.cubeMeta.partitioner, columinar, true);
 
-      }
+    }
 
     //    }
 
diff --git a/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/rdd/MolapMergerRDD.scala b/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/rdd/MolapMergerRDD.scala
index a7919a6..d9f500f 100644
--- a/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/rdd/MolapMergerRDD.scala
+++ b/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/rdd/MolapMergerRDD.scala
@@ -2,7 +2,6 @@ package com.huawei.datasight.spark.rdd
 
 import java.text.SimpleDateFormat
 import java.util.Date
-import java.util.List
 import org.apache.hadoop.conf.Configuration
 import org.apache.spark.Logging
 import org.apache.spark.Partition
@@ -11,7 +10,7 @@ import org.apache.spark.SparkContext
 import org.apache.spark.TaskContext
 import org.apache.spark.rdd.RDD
 import com.huawei.unibi.molap.engine.executer.MolapQueryExecutorModel
-import com.huawei.datasight.spark.{KeyVal,Result}
+import com.huawei.datasight.spark.KeyVal
 import com.huawei.datasight.molap.spark.util.MolapQueryUtil
 import com.huawei.datasight.molap.spark.splits.TableSplit
 import com.huawei.unibi.molap.util.MolapProperties
@@ -23,171 +22,69 @@ import com.huawei.datasight.molap.load.MolapLoadModel
 import com.huawei.datasight.molap.load.MolapLoaderUtil
 import org.apache.spark.sql.cubemodel.Partitioner
 import com.huawei.datasight.molap.merger.MolapDataMergerUtil
-import com.huawei.unibi.molap.datastorage.store.filesystem.MolapFile
-import com.huawei.datasight.spark.MergeResult
-import com.huawei.unibi.molap.constants.MolapCommonConstants
-import com.huawei.unibi.molap.olap.MolapDef
-import com.huawei.unibi.molap.util.MolapUtil
 
 class MolapMergerRDD[K, V](
-  sc: SparkContext,
-  result: MergeResult[K,V],
-  molapLoadModel: MolapLoadModel,
-  storeLocation: String,
-  hdfsStoreLocation: String,
-  partitioner: Partitioner,
-  currentRestructNumber: Integer,
-  metadataFilePath:String,
-  loadsToMerge:List[String],
-  mergedLoadName:String,
-  kettleHomePath:String,
-  cubeCreationTime:Long)
+                            sc: SparkContext,
+                            keyClass: KeyVal[K, V],
+                            molapLoadModel: MolapLoadModel,
+                            storeLocation: String,
+                            hdfsStoreLocation: String,
+                            partitioner: Partitioner,
+                            currentRestructNumber: Integer)
   extends RDD[(K, V)](sc, Nil)
-  with Logging {
+    with Logging {
 
   sc.setLocalProperty("spark.scheduler.pool", "DDL")
   
   /**
-   * It fires the query of respective co-processor and get the data and form the iterator.So here all the will be present to iterator physically.So
-   * if co-processor returns big data then it may have memory issues.
-   */
+    * It fires the query of respective co-processor and get the data and form the iterator.So here all the will be present to iterator physically.So
+    * if co-processor returns big data then it may have memory issues.
+    */
   override def compute(theSplit: Partition, context: TaskContext) = {
-      val iter = new Iterator[(K, V)] {
-        var dataloadStatus = MolapCommonConstants.STORE_LOADSTATUS_FAILURE
-        val split = theSplit.asInstanceOf[MolapLoadPartition]
-        logInfo("Input split: " + split.serializableHadoopSplit.value)
-        val partitionId = split.serializableHadoopSplit.value.getPartition().getUniqueID()
-        val model = molapLoadModel.getCopyWithPartition(split.serializableHadoopSplit.value.getPartition().getUniqueID())
-        
-        val mergedLoadMetadataDetails = MolapDataMergerUtil.executeMerging(model, storeLocation, hdfsStoreLocation, currentRestructNumber, metadataFilePath,loadsToMerge,mergedLoadName)
-        
-        model.setLoadMetadataDetails(MolapUtil
-                .readLoadMetadata(metadataFilePath).toList);
-        
-        if(mergedLoadMetadataDetails == true)
-        {
-            MolapLoaderUtil.copyMergedLoadToHDFS(model, currentRestructNumber,mergedLoadName)
-            dataloadStatus = checkAndLoadAggregationTable
-            
-        }
-
-        // Register an on-task-completion callback to close the input stream.
-        context.addOnCompleteCallback(() => close())
-        var havePair = false
-        var finished = false
-
-        override def hasNext: Boolean = {
-          if (!finished && !havePair) {
-            finished = !false
-            havePair = !finished
-          }
-          !finished
+    val iter = new Iterator[(K, V)] {
+      val split = theSplit.asInstanceOf[MolapLoadPartition]
+      logInfo("Input split: " + split.serializableHadoopSplit.value)
+      val model = molapLoadModel.getCopyWithPartition(split.serializableHadoopSplit.value.getPartition().getUniqueID())
+      MolapDataMergerUtil.executeMerging(model, storeLocation, hdfsStoreLocation, currentRestructNumber);
+      MolapLoaderUtil.copyCurrentLoadToHDFS(model, currentRestructNumber, null, null, currentRestructNumber);
+
+      // Register an on-task-completion callback to close the input stream.
+      context.addOnCompleteCallback(() => close())
+      var havePair = false
+      var finished = false
+
+      override def hasNext: Boolean = {
+        if (!finished && !havePair) {
+          finished = !false
+          havePair = !finished
         }
+        !finished
+      }
 
-        override def next(): (K, V) = {
-          if (!hasNext) {
-            throw new java.util.NoSuchElementException("End of stream")
-          }
-          havePair = false
-        /*  val row = new MolapKey(null)
-          val value = new MolapValue(null)*/
-          result.getKey(0, mergedLoadMetadataDetails)
+      override def next(): (K, V) = {
+        if (!hasNext) {
+          throw new java.util.NoSuchElementException("End of stream")
         }
+        havePair = false
+        val row = new MolapKey(null)
+        val value = new MolapValue(null)
+        keyClass.getKey(row, value)
+      }
 
-        private def close() {
-          try {
-            //          reader.close()
-          } catch {
-            case e: Exception => logWarning("Exception in RecordReader.close()", e)
-          }
-        }
-        
-          def checkAndLoadAggregationTable():String = {
-          var dataloadStatus = MolapCommonConstants.STORE_LOADSTATUS_SUCCESS
-          val schema = model.getSchema
-          val aggTables = schema.cubes(0).fact.asInstanceOf[MolapDef.Table].aggTables
-          if(null != aggTables && !aggTables.isEmpty)
-          {
-            val details = model.getLoadMetadataDetails.toSeq.toArray
-            val newSlice = MolapCommonConstants.LOAD_FOLDER + mergedLoadName
-            var listOfLoadFolders = MolapLoaderUtil.getListOfValidSlices(details)
-            listOfLoadFolders = MolapLoaderUtil.addNewSliceNameToList(newSlice, listOfLoadFolders);
-            val listOfUpdatedLoadFolders = MolapLoaderUtil.getListOfUpdatedSlices(details)
-            val copyListOfLoadFolders = listOfLoadFolders.toList
-            val copyListOfUpdatedLoadFolders = listOfUpdatedLoadFolders.toList
-            loadCubeSlices(listOfLoadFolders,listOfUpdatedLoadFolders)
-            var loadFolders = Array[String]()
-            val loadFolder = MolapLoaderUtil.getAggLoadFolderLocation(newSlice, model.getSchemaName, model.getCubeName, model.getTableName, hdfsStoreLocation, currentRestructNumber)
-            if (null != loadFolder) {
-              loadFolders :+= loadFolder
-            }
-            dataloadStatus = iterateOverAggTables(aggTables, copyListOfLoadFolders, copyListOfUpdatedLoadFolders, loadFolders)
-            if (MolapCommonConstants.STORE_LOADSTATUS_FAILURE.equals(dataloadStatus)) {
-              // remove the current slice from memory not the cube
-              MolapLoaderUtil.removeSliceFromMemory(model.getSchemaName, model.getCubeName, newSlice)
-              logInfo(s"Aggregate table creation failed")
-            }
-            else {
-              logInfo("Aggregate tables creation successfull")
-            }
-          }
-          return dataloadStatus
-        }
-         
-          
-         def loadCubeSlices(listOfLoadFolders: java.util.List[String], listOfUpdatedLoadFolders: java.util.List[String]) = {
-          MolapProperties.getInstance().addProperty("molap.cache.used", "false");
-          MolapQueryUtil.createDataSource(currentRestructNumber, model.getSchema, null,partitionId, listOfLoadFolders, listOfUpdatedLoadFolders, model.getTableName, hdfsStoreLocation,cubeCreationTime)
-        } 
-          
-         def iterateOverAggTables(aggTables: Array[MolapDef.AggTable], listOfLoadFolders: java.util.List[String], listOfUpdatedLoadFolders: java.util.List[String], loadFolders: Array[String]):String = {
-          model.setAggLoadRequest(true)
-          aggTables.foreach { aggTable =>
-              val aggTableName = MolapLoaderUtil.getAggregateTableName(aggTable)
-              model.setAggTableName(aggTableName)
-              dataloadStatus = loadAggregationTable(listOfLoadFolders, listOfUpdatedLoadFolders, loadFolders)
-              if (MolapCommonConstants.STORE_LOADSTATUS_FAILURE.equals(dataloadStatus)) {
-                logInfo(s"Aggregate table creation failed :: $aggTableName")
-                return MolapCommonConstants.STORE_LOADSTATUS_FAILURE
-              }
-            }
-          return MolapCommonConstants.STORE_LOADSTATUS_SUCCESS
+      private def close() {
+        try {
+          //          reader.close()
+        } catch {
+          case e: Exception => logWarning("Exception in RecordReader.close()", e)
         }
-          
-        def loadAggregationTable(listOfLoadFolders: java.util.List[String], listOfUpdatedLoadFolders: java.util.List[String], loadFolders: Array[String]): String = {
-          loadFolders.foreach { loadFolder =>
-            val restructNumber = MolapUtil.getRestructureNumber(loadFolder, model.getTableName)
-            try {
-              if (MolapLoaderUtil.isSliceValid(loadFolder, listOfLoadFolders, listOfUpdatedLoadFolders, model.getTableName)) {
-                model.setFactStoreLocation(loadFolder)
-                MolapLoaderUtil.executeGraph(model, storeLocation, hdfsStoreLocation, kettleHomePath, restructNumber)
-                dataloadStatus = MolapCommonConstants.STORE_LOADSTATUS_SUCCESS
-              } else {
-                MolapLoaderUtil.createEmptyLoadFolder(model, loadFolder, hdfsStoreLocation, restructNumber)
-              }
-            } catch {
-              case e: Exception => dataloadStatus = MolapCommonConstants.STORE_LOADSTATUS_FAILURE
-            } finally {
-              if (!MolapCommonConstants.STORE_LOADSTATUS_FAILURE.equals(dataloadStatus)) {
-                val loadName = loadFolder.substring(loadFolder.indexOf(MolapCommonConstants.LOAD_FOLDER))
-                MolapLoaderUtil.copyCurrentLoadToHDFS(model, restructNumber, loadName, listOfUpdatedLoadFolders,restructNumber)
-              } else {
-                logInfo(s"Load creation failed :: $loadFolder")
-                return MolapCommonConstants.STORE_LOADSTATUS_FAILURE
-              }
-            }
-          }
-          return MolapCommonConstants.STORE_LOADSTATUS_SUCCESS
-        }  
-        
-        
       }
-      iter
     }
+    iter
+  }
 
   /**
-   * Get the preferred locations where to lauch this task.
-   */
+    * Get the preferred locations where to lauch this task.
+    */
   override def getPreferredLocations(split: Partition): Seq[String] = {
     val theSplit = split.asInstanceOf[MolapLoadPartition]
     val s = theSplit.serializableHadoopSplit.value.getLocations //.filter(_ != "localhost")
@@ -199,20 +96,19 @@ class MolapMergerRDD[K, V](
     val formatter = new SimpleDateFormat("yyyyMMddHHmm")
     formatter.format(new Date())
   }
-  
-  
+
   /**
-   * Create the split for each region server.
-   */
+    * Create the split for each region server.
+    */
   override def getPartitions: Array[Partition] = {
 
-      val splits = MolapQueryUtil.getTableSplits(molapLoadModel.getSchemaName(), molapLoadModel.getCubeName(), null, partitioner)
-      val result = new Array[Partition](splits.length)
-      for (i <- 0 until result.length) {
-        result(i) = new MolapLoadPartition(id, i, splits(i))
-      }
-      result
+    val splits = MolapQueryUtil.getTableSplits(molapLoadModel.getSchemaName(), molapLoadModel.getCubeName(), null, partitioner)
+    val result = new Array[Partition](splits.length)
+    for (i <- 0 until result.length) {
+      result(i) = new MolapLoadPartition(id, i, splits(i))
     }
+    result
+  }
 
   override def checkpoint() {
     // Do nothing. Hadoop RDD should not be checkpointed.
diff --git a/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/rdd/SqlUdfSupport.scala b/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/rdd/SqlUdfSupport.scala
index 4d18d0f..ffac286 100644
--- a/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/rdd/SqlUdfSupport.scala
+++ b/Molap/Molap-Spark-Interface/src/main/scala/com/huawei/datasight/spark/rdd/SqlUdfSupport.scala
@@ -34,7 +34,8 @@ case class SqlUdf(fn: (InternalRow) => Any, exprs: Expression*) extends Expressi
   override def eval(input: InternalRow): Any = {
     val exprEvals = exprs.map {
       _.eval(input) match {
-        case d: MeasureAggregator => d.getValue()
+        //  TODO here we hardcode just for test query
+        case d: MeasureAggregator => d.getDoubleValue()
         case others => others
       }
     }
diff --git a/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/CarbonEnv.scala b/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/CarbonEnv.scala
index fc3650a..f083166 100644
--- a/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/CarbonEnv.scala
+++ b/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/CarbonEnv.scala
@@ -7,7 +7,6 @@ import com.huawei.unibi.molap.metadata.MolapMetadata
 import com.huawei.datasight.molap.load.MolapLoaderUtil
 import com.huawei.unibi.molap.util.MolapUtil
 import com.huawei.unibi.molap.constants.MolapCommonConstants
-import org.apache.hadoop.conf.Configuration
 
 /**
   * Carbon Environment for unified context
@@ -15,8 +14,7 @@ import org.apache.hadoop.conf.Configuration
 class CarbonEnv extends Logging {
   var carbonContext: HiveContext = _
   var carbonCatalog: OlapMetastoreCatalog = _
-  val FS_DEFAULT_FS = "fs.defaultFS"
-  val HDFSURL_PREFIX = "hdfs://"
+
   def init(context: HiveContext): Unit = {
     if (null == carbonContext) {
       carbonContext = context
@@ -27,15 +25,9 @@ class CarbonEnv extends Logging {
   def initCarbonCatalog(context: HiveContext): Unit = {
     if (null == carbonCatalog) {
       var storeLocation = MolapProperties.getInstance().getProperty("carbon.storelocation")
-      var conf:Configuration = new Configuration(true)
-      var hdfsPath:String =conf.get(FS_DEFAULT_FS)
       if (storeLocation == null) {
         storeLocation = context.sparkContext.conf.get("carbon.storelocation", "/opt/carbon/store");
       }
-      if(hdfsPath.startsWith(HDFSURL_PREFIX))
-      {
-        storeLocation=hdfsPath+storeLocation;
-      }
       carbonCatalog = new OlapMetastoreCatalog(context.sparkContext, storeLocation)
       if (MolapProperties.getInstance.getProperty(MolapCommonConstants.LOADCUBE_STARTUP, "false") == "true") {
         val thread = new Thread {
@@ -48,8 +40,6 @@ class CarbonEnv extends Logging {
       }
     }
   }
-
-  
 }
 
 object CarbonEnv {
diff --git a/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/MolapSqlParser.scala b/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/MolapSqlParser.scala
index 3176b93..a45eb10 100644
--- a/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/MolapSqlParser.scala
+++ b/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/MolapSqlParser.scala
@@ -71,7 +71,6 @@ class MolapSqlDDLParser
   protected val AGGREGATE = Keyword("AGGREGATE")
   override protected val AS = Keyword("AS")
   protected val AGGREGATION = Keyword("AGGREGATION")
-  protected val HIGH_CARDINALITY_DIMS = Keyword("HIGH_CARDINALITY_DIMS")
   protected val BEFORE = Keyword("BEFORE")
   override protected val BY = Keyword("BY")
   protected val CARDINALITY = Keyword("CARDINALITY")
@@ -118,12 +117,10 @@ class MolapSqlDDLParser
   protected val MAPPED = Keyword("MAPPED")
   protected val MEASURES = Keyword("MEASURES")
   protected val MULTILINE = Keyword("MULTILINE")
-  protected val COMPLEX_DELIMITER_LEVEL_1 = Keyword("COMPLEX_DELIMITER_LEVEL_1")
-  protected val COMPLEX_DELIMITER_LEVEL_2 = Keyword("COMPLEX_DELIMITER_LEVEL_2")
   protected val NUMERIC = Keyword("NUMERIC")
-  protected val ARRAY = Keyword("ARRAY")
-  protected val STRUCT = Keyword("STRUCT")
+  protected val DECIMAL = Keyword("DECIMAL") // add by ggin
   protected val OPTIONS = Keyword("OPTIONS")
+  protected val BIGINT = Keyword("BIGINT")
   protected val OUTPATH = Keyword("OUTPATH")
   override protected val OVERWRITE = Keyword("OVERWRITE")
   protected val PARTITION_COUNT = Keyword("PARTITION_COUNT")
@@ -263,12 +260,8 @@ class MolapSqlDDLParser
       ((FACT ~> FROM ~ (dbTableIdentifier | stringLit) ~ (colsFilter).? ~ ("," ~> DIMENSION ~> FROM ~> dimRelations).?).?) ~
       (WITH ~ (simpleDimRelations)).?)
 
-      protected lazy val aggOptionsForShowCreate = 
-          (aggregation).? ~ (",".? ~> partitioner).?
   protected lazy val aggOptions =
-    (highcardinalityDims).? ~ (",".? ~> aggregation).? ~ (",".? ~> partitioner).?
-    protected lazy val showcreateCubeOptionDef = 
-        ("(" ~> aggOptionsForShowCreate <~ ")")
+    (aggregation).? ~ (",".? ~> partitioner).?
 
   protected lazy val createCubeOptionDef =
     ("(" ~> aggOptions <~ ")")
@@ -277,8 +270,7 @@ class MolapSqlDDLParser
   protected lazy val showCreateCube: Parser[LogicalPlan] =
     SHOW ~> CREATE ~> CUBE ~> (IF ~> NOT ~> EXISTS).? ~ (ident <~ ".").? ~ ident ~
       showCubeDefinition ~
-    (OPTIONS ~> showcreateCubeOptionDef).? <~ (";").? ^^ 
-    {
+      (OPTIONS ~> createCubeOptionDef).? <~ (";").? ^^ {
       case exists ~ schemaName ~ cubeName ~ cubeDefinition ~ options => {
         val (dimCols, msrCols, fromKeyword, withKeyword, source, factFieldsList, dimRelations, simpleDimRelations) = cubeDefinition match {
           case _ ~ _ ~ Some(_) ~ Some(_) => sys.error("FROM and WITH keywords can not be used together")
@@ -306,9 +298,9 @@ class MolapSqlDDLParser
         }
 
         ShowCreateCubeCommand(CubeModel(exists.isDefined,
-          schemaName.getOrElse("default"), schemaName, cubeName, dimCols.map(f => normalizeType(f)).map(f => addParent(f)),
+          schemaName.getOrElse("default"), schemaName, cubeName, dimCols.map(f => normalizeType(f)),
           msrCols.map(f => normalizeType(f)), fromKeyword, withKeyword, source,
-          factFieldsList, dimRelations, simpleDimRelations,None, aggregation, partitioner))
+          factFieldsList, dimRelations, simpleDimRelations, aggregation, partitioner))
       }
     }
 
@@ -329,16 +321,15 @@ class MolapSqlDDLParser
           }
         }
 
-	      val (highCard, aggregation, partitioner) = options match 
-	      {
-	      		case Some(hc ~ agg ~ part) => (hc.getOrElse(Some(Seq())) , agg.getOrElse(Seq()), part)
-	      		case _ => (Some(Seq()),  Seq(), None)
+        val (aggregation, partitioner) = options match {
+          case Some(aggregation ~ partitioner) => (aggregation.getOrElse(Seq()), partitioner)
+          case _ => (Seq(), None)
         }
 
         CreateCube(CubeModel(exists.isDefined,
-          schemaName.getOrElse("default"), schemaName, cubeName, dimCols.map(f => normalizeType(f)).map(f => addParent(f)),
+          schemaName.getOrElse("default"), schemaName, cubeName, dimCols.map(f => normalizeType(f)),
           msrCols.map(f => normalizeType(f)), "", withKeyword, "",
-          None, Seq(), simpleDimRelations, highCard, aggregation,partitioner))
+          None, Seq(), simpleDimRelations, aggregation, partitioner))
       }
     }
 
@@ -380,7 +371,7 @@ class MolapSqlDDLParser
 
         AlterCube(CubeModel(false, schemaName.getOrElse("default"), schemaName, cubeName, dimCols.map(f => normalizeType(f)),
           msrCols.map(f => normalizeType(f)), "", withKeyword, "",
-              None, Seq(), simpleDimRelations,None,aggregation, None),
+          None, Seq(), simpleDimRelations, aggregation, None),
           dropCols, defaultVals)
       }
 
@@ -421,9 +412,7 @@ class MolapSqlDDLParser
     }
 
   protected lazy val partitionOptions: Parser[(String, String)] =
-    ((DELIMITER ~ stringLit) | (QUOTECHAR ~ stringLit) | (FILEHEADER ~ stringLit) | 
-        (ESCAPECHAR ~ stringLit) | (MULTILINE ~ stringLit) | 
-        (COMPLEX_DELIMITER_LEVEL_1 ~ stringLit) | (COMPLEX_DELIMITER_LEVEL_2 ~ stringLit)) ^^ {
+    ((DELIMITER ~ stringLit) | (QUOTECHAR ~ stringLit) | (FILEHEADER ~ stringLit) | (ESCAPECHAR ~ stringLit) | (MULTILINE ~ stringLit)) ^^ {
       case opt ~ optvalue => (opt, optvalue)
       case _ => ("", "")
     }
@@ -503,45 +492,17 @@ class MolapSqlDDLParser
         DimensionRelation(tableName, "", relation, Some("INCLUDE"), Some(colList))
       }
     }
-  
+
   protected lazy val simpleDimRelations: Parser[Seq[DimensionRelation]] = repsep(simpleDimRelation, ",")
-  
-  protected lazy val dimCol: Parser[Field] = anyFieldDef 
- 
-  protected lazy val  primitiveTypes = STRING | INTEGER | TIMESTAMP | NUMERIC
-  protected lazy val nestedType: Parser[Field]  =  structFieldType | arrayFieldType | primitiveFieldType
-
-  protected lazy val anyFieldDef: Parser[Field]  = 
-    (ident | stringLit) ~ ((":").? ~> nestedType) ^^ {
-     case e1 ~ e2 => {
-    	 Field(e1, e2.dataType, Some(e1), e2.children)
-     }
-  }
-  
-  protected lazy val primitiveFieldType : Parser[Field]  = 
-    (primitiveTypes) ^^ {
-     case e1 => {
-    	 Field("unknown", Some(e1), Some("unknown"), Some(null))
-     } 
-  }
-  
-  protected lazy val arrayFieldType: Parser[Field]  = 
-    (ARRAY ~> "<" ~> nestedType <~ ">") ^^ {
-     case e1 => {
-        Field("unknown", Some("array"), Some("unknown"), Some(List(Field("val", e1.dataType, Some("val"), e1.children))))
-     }
-  }
-  
-  protected lazy val structFieldType: Parser[Field]  = 
-    (STRUCT ~> "<" ~> repsep(anyFieldDef, ",") <~ ">") ^^ {
-     case e1 => {
-    	 Field("unknown", Some("struct"), Some("unknown"), Some(e1))
-     }
-  }
-  
+
+  protected lazy val dimCol: Parser[Field] =
+    (ident | stringLit) ~ (STRING | INTEGER | TIMESTAMP | NUMERIC | BIGINT | DECIMAL).? ~ (AS ~> (ident | stringLit)).? ^^ {
+      case e1 ~ e2 ~ e3 => Field(e1, e2, e3)
+    }
+
   protected lazy val measureCol: Parser[Field] =
-    (ident | stringLit) ~ (INTEGER | NUMERIC).? ~ (AS ~> (ident | stringLit)).? ^^ {
-      case e1 ~ e2 ~ e3 => Field(e1, e2, e3, Some(null))
+    (ident | stringLit) ~ (INTEGER | NUMERIC | BIGINT | DECIMAL).? ~ (AS ~> (ident | stringLit)).? ^^ {
+      case e1 ~ e2 ~ e3 => Field(e1, e2, e3)
     }
 
   protected lazy val dimCols: Parser[Seq[Field]] = rep1sep(dimCol, ",")
@@ -578,14 +539,6 @@ class MolapSqlDDLParser
 
   protected lazy val aggregation: Parser[Seq[Aggregation]] =
     AGGREGATION ~> ("[" ~> aggExpressions <~ "]")
-    protected lazy val highcardinalityDims: Parser[Option[Seq[String]]] = 
-      HIGH_CARDINALITY_DIMS ~> ("(" ~> repsep((ident | stringLit), ",") <~ ")") ^^ {
-        case hc => {
-         Some(hc) 
-        }
-         case _ => None 
-  
-    }
 
   protected lazy val partitioner: Parser[Partitioner] =
     PARTITIONER ~> "[" ~> opt(CLASS ~> "=" ~> stringLit) ~
@@ -648,38 +601,14 @@ class MolapSqlDDLParser
 
   private def normalizeType(field: Field): Field = {
     field.dataType.getOrElse("NIL") match {
-      case "string" => Field(field.column, Some("String"), field.name, Some(null))
-      case "integer" => Field(field.column, Some("Integer"), field.name, Some(null))
-      case "long" => Field(field.column, Some("Long"), field.name, Some(null))
-      case "double" => Field(field.column, Some("Double"), field.name, Some(null))
-      case "timestamp" => Field(field.column, Some("Timestamp"), field.name, Some(null))
-      case "numeric" => Field(field.column, Some("Numeric"), field.name, Some(null))
-      case "array" => Field(field.column, Some("Array"), field.name, field.children.map(f => f.map(normalizeType(_))))
-      case "struct" => Field(field.column, Some("Struct"), field.name, field.children.map(f => f.map(normalizeType(_))))
-      case _ => field
-    }
-  }
-  
-  private def addParent(field: Field): Field = {
-    field.dataType.getOrElse("NIL") match {
-      case "Array" => Field(field.column, Some("Array"), field.name, field.children.map(f => f.map(appendParentForEachChild(_, field.column))))
-      case "Struct" => Field(field.column, Some("Struct"), field.name, field.children.map(f => f.map(appendParentForEachChild(_, field.column))))
-      case _ => field
-    }
-  }
-  
-  private def appendParentForEachChild(field: Field, parentName : String): Field = {
-    field.dataType.getOrElse("NIL") match {
-      case "String" => Field(parentName +"."+ field.column, Some("String"), Some(parentName +"."+ field.name.getOrElse(None)), Some(null), parentName)
-      case "Integer" => Field(parentName +"."+ field.column, Some("Integer"), Some(parentName +"."+ field.name.getOrElse(None)), Some(null), parentName)
-      case "Long" => Field(parentName +"."+ field.column, Some("Long"), Some(parentName +"."+ field.name.getOrElse(None)), Some(null), parentName)
-      case "Double" => Field(parentName +"."+ field.column, Some("Double"), Some(parentName +"."+ field.name.getOrElse(None)), Some(null), parentName)
-      case "Timestamp" => Field(parentName +"."+ field.column, Some("Timestamp"), Some(parentName +"."+ field.name.getOrElse(None)), Some(null), parentName)
-      case "Numeric" => Field(parentName +"."+ field.column, Some("Numeric"), Some(parentName +"."+ field.name.getOrElse(None)), Some(null), parentName)
-      case "Array" => Field(parentName +"."+ field.column, Some("Array"), Some(parentName +"."+ field.name.getOrElse(None)), 
-          field.children.map(f => f.map(appendParentForEachChild(_, parentName +"."+ field.column))), parentName)
-      case "Struct" => Field(parentName +"."+ field.column, Some("Struct"), Some(parentName +"."+ field.name.getOrElse(None)), 
-          field.children.map(f => f.map(appendParentForEachChild(_, parentName +"."+ field.column))), parentName)
+      case "string" => Field(field.column, Some("String"), field.name)
+      case "integer" => Field(field.column, Some("Integer"), field.name)
+      case "long" => Field(field.column, Some("Long"), field.name)
+      case "double" => Field(field.column, Some("Double"), field.name)
+      case "timestamp" => Field(field.column, Some("Timestamp"), field.name)
+      case "numeric" => Field(field.column, Some("Numeric"), field.name)
+      case "bigint" => Field(field.column, Some("BigInt"), field.name)
+      case "decimal" => Field(field.column, Some("Decimal"), field.name)
       case _ => field
     }
   }
diff --git a/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/OlapCatalystOperators.scala b/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/OlapCatalystOperators.scala
index ba74c4d..ca09dd4 100644
--- a/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/OlapCatalystOperators.scala
+++ b/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/OlapCatalystOperators.scala
@@ -121,14 +121,14 @@ case class ShowAggregateTablesCommand(schemaNameOp: Option[String]) extends Logi
 /**
   * Shows cubes in schema
   */
-case class ShowCubeCommand(schemaNameOp: Option[String]) extends LogicalPlan with Command with ControlCommand {
+case class ShowCubeCommand(schemaNameOp: Option[String]) extends LogicalPlan with Command /*with ControlCommand */{
   override def children: Seq[LogicalPlan] = Seq.empty
 
   override def output =
     Seq(AttributeReference("cubeName", StringType, nullable = false)(),
       AttributeReference("isRegisteredWithSpark", BooleanType, nullable = false)())
 
-  override def getControlPrivileges(sqlContext: SQLContext): Set[PrivObject] = {
+  /*override def getControlPrivileges(sqlContext: SQLContext): Set[PrivObject] = {
     //SELECT privilege @ database level // TODO: this privilege is wrong
     Set(new PrivObject(
       ObjectType.DATABASE,
@@ -136,7 +136,7 @@ case class ShowCubeCommand(schemaNameOp: Option[String]) extends LogicalPlan wit
       null,
       null,
       Set(PrivType.SELECT_NOGRANT)))
-  }
+  }*/
 }
 
 
diff --git a/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/OlapContext.scala b/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/OlapContext.scala
index 870ff71..8f93ebb 100644
--- a/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/OlapContext.scala
+++ b/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/OlapContext.scala
@@ -154,7 +154,8 @@ class OlapContext(val sc: SparkContext, metadataPath: String) extends HiveContex
   //  }
 
   @DeveloperApi
-  implicit def toAggregates(aggregate: MeasureAggregator): Double = aggregate.getValue()
+  //  TODO here we hardcode just for test query
+  implicit def toAggregates(aggregate: MeasureAggregator): Double = aggregate.getDoubleValue()
 
   /**
     * Loads a CSV file (according to RFC 4180) and returns the result as a [[SchemaRDD]].
diff --git a/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/OlapMetastoreCatalog.scala b/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/OlapMetastoreCatalog.scala
index 40d8b5c..24bb9f4 100644
--- a/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/OlapMetastoreCatalog.scala
+++ b/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/OlapMetastoreCatalog.scala
@@ -48,7 +48,6 @@ import org.apache.spark.sql.types.ShortType
 import org.apache.spark.sql.types.StringType
 import org.apache.spark.sql.types.StructField
 import org.apache.spark.sql.types.StructType
-import org.apache.spark.sql.types.ArrayType
 import org.apache.spark.sql.types.TimestampType
 import org.apache.spark.sql.cubemodel.AggregateTableAttributes
 import org.eigenbase.xom.XOMUtil
@@ -70,13 +69,10 @@ import com.huawei.datasight.molap.load.MolapLoaderUtil
 import com.huawei.unibi.molap.util.MolapDataProcessorUtil
 import scala.collection.mutable.TreeSet
 import org.apache.spark.SparkContext
-import com.huawei.unibi.molap.datastorage.store.fileperations.AtomicFileOperations
-import com.huawei.unibi.molap.datastorage.store.fileperations.AtomicFileOperationsImpl
-import com.huawei.unibi.molap.datastorage.store.fileperations.FileWriteOperation
 
 /**
- * Created by w00228970 on 2014/5/16.
- */
+  * Created by w00228970 on 2014/5/16.
+  */
 
 case class MetaData(var cubesMeta: ArrayBuffer[CubeMeta])
 
@@ -91,14 +87,14 @@ object OlapMetastoreCatalog {
     new MolapDef.Schema(defin)
   }
 
-      /**
-     * Gets content via Apache VFS and decrypt the content.
-     *  File must exist and have content.
-     *
-     * @param url String
-     * @return Apache VFS FileContent for further processing
-     * @throws FileSystemException
-     */
+  /**
+    * Gets content via Apache VFS and decrypt the content.
+    * File must exist and have content.
+    *
+    * @param url String
+    * @return Apache VFS FileContent for further processing
+    * @throws FileSystemException
+    */
   def readSchema(url: String, encrypted: Boolean): MolapDef.Schema = {
     val fileType = FileFactory.getFileType(url)
     val out = FileFactory.getDataInputStream(url, fileType)
@@ -129,8 +125,8 @@ object OlapMetastoreCatalog {
     catch {
       case s: Exception =>
         throw s
-      }
     }
+  }
 }
 
 class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
@@ -141,18 +137,19 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
 
    val cubeModifiedTimeStore = new HashMap[String, Long]()
    cubeModifiedTimeStore.put("default", System.currentTimeMillis())
+   
+   val metadata = loadMetadata(metadataPath)
   
-  val metadata = loadMetadata(metadataPath)
-  
-  lazy val useUniquePath = if("true".equalsIgnoreCase(MolapProperties.getInstance().
+   lazy val useUniquePath = false
+  /*lazy val useUniquePath = if("true".equalsIgnoreCase(MolapProperties.getInstance().
       getProperty(
                 MolapCommonConstants.CARBON_UNIFIED_STORE_PATH, 
-                MolapCommonConstants.CARBON_UNIFIED_STORE_PATH_DEFAULT))){ true } else { false }
-    
+                MolapCommonConstants.CARBON_UNIFIED_STORE_PATH_DEFAULT))){ true } else { false }*/
+  
   def lookupRelation1(
-      databaseName: Option[String],
-      tableName: String,
-      alias: Option[String] = None)(sqlContext: SQLContext): LogicalPlan = {
+                       databaseName: Option[String],
+                       tableName: String,
+                       alias: Option[String] = None)(sqlContext: SQLContext): LogicalPlan = {
     val db = databaseName match {
       case Some(name) => name
       case _ => null
@@ -198,11 +195,11 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
     val cubeMeta = metadata.cubesMeta.filter(c => (c.schemaName.equalsIgnoreCase(schemaName) && (c.cubeName.equalsIgnoreCase(cubeName))))
     val cubeCreationTime = cubeMeta.head.cubeCreationTime
     cubeCreationTime
-    }
+  }
   
 
-   def lookupRelation2(tableIdentifier: Seq[String],
-                     alias: Option[String] = None)(sqlContext: SQLContext): LogicalPlan = {
+  def lookupRelation2(tableIdentifier: Seq[String],
+                      alias: Option[String] = None)(sqlContext: SQLContext): LogicalPlan = {
     checkSchemasModifiedTimeAndReloadCubes()
     tableIdentifier match {
       case Seq(schemaName, cubeName) =>
@@ -233,9 +230,9 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
     if (db.get == null || db.get == "") {
       cubeExists(Seq(tableName))(sqlContext)
     }
-      else {
-          cubeExists(Seq(db.get, tableName))(sqlContext)
-          }
+    else {
+      cubeExists(Seq(db.get, tableName))(sqlContext)
+    }
   }
 
   def cubeExists(tableIdentifier: Seq[String])(sqlContext: SQLContext): Boolean = {
@@ -323,96 +320,96 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
       try {
           
       if (FileFactory.isFileExist(schemasPath, fileType)) {
-	      val file = FileFactory.getMolapFile(schemasPath, fileType)
-	      val schemaFolders = file.listFiles();
+        val file = FileFactory.getMolapFile(schemasPath, fileType)
+        val schemaFolders = file.listFiles();
 
         schemaFolders.foreach(schemaFolder => {
           if (schemaFolder.isDirectory()) {
-	          val cubeFolders = schemaFolder.listFiles();
+            val cubeFolders = schemaFolder.listFiles();
 
             cubeFolders.foreach(cubeFolder => {
               if (cubeFolder.isDirectory()) {
-	            	val cubeMetadataFile = cubeFolder.getAbsolutePath() + "/metadata"
+                val cubeMetadataFile = cubeFolder.getAbsolutePath() + "/metadata"
 
                 if (FileFactory.isFileExist(cubeMetadataFile, fileType)) {
-		            	//load metadata
-		            	val in = FileFactory.getDataInputStream(cubeMetadataFile, fileType)
-		            	var len = 0
+                  //load metadata
+                  val in = FileFactory.getDataInputStream(cubeMetadataFile, fileType)
+                  var len = 0
                   try {
-		            		len = in.readInt()
-		            	}
+                    len = in.readInt()
+                  }
                   catch {
                     case others: EOFException => len = 0
-		            	}
+                  }
 
                   while (len > 0) {
-		            		val schemaNameBytes = new Array[Byte](len)
-					        in.readFully(schemaNameBytes)
+                    val schemaNameBytes = new Array[Byte](len)
+                    in.readFully(schemaNameBytes)
 
                     val schemaName = new String(schemaNameBytes, "UTF8")
-					        val cubeNameLen = in.readInt()
-					        val cubeNameBytes = new Array[Byte](cubeNameLen)
-					        in.readFully(cubeNameBytes)
+                    val cubeNameLen = in.readInt()
+                    val cubeNameBytes = new Array[Byte](cubeNameLen)
+                    in.readFully(cubeNameBytes)
                     val cubeName = new String(cubeNameBytes, "UTF8")
 
-		            		val dataPathLen = in.readInt()
-					        val dataPathBytes = new Array[Byte](dataPathLen)
-					        in.readFully(dataPathBytes)
+                    val dataPathLen = in.readInt()
+                    val dataPathBytes = new Array[Byte](dataPathLen)
+                    in.readFully(dataPathBytes)
                     val dataPath = new String(dataPathBytes, "UTF8")
 
-		            		val versionLength = in.readInt()
-					        val versionBytes = new Array[Byte](versionLength)
-					        in.readFully(versionBytes)
+                    val versionLength = in.readInt()
+                    val versionBytes = new Array[Byte](versionLength)
+                    in.readFully(versionBytes)
                     val version = new String(versionBytes, "UTF8")
 
-		            		val schemaLen = in.readInt()
-					        val schemaBytes = new Array[Byte](schemaLen)
-					        in.readFully(schemaBytes)
+                    val schemaLen = in.readInt()
+                    val schemaBytes = new Array[Byte](schemaLen)
+                    in.readFully(schemaBytes)
                     val schema = new String(schemaBytes, "UTF8")
 
-		            		val partitionLength = in.readInt()
-					        val partitionBytes = new Array[Byte](partitionLength)
-					        in.readFully(partitionBytes)
-				            val inStream = new ByteArrayInputStream(partitionBytes)
-				            val objStream = new ObjectInputStream(inStream)
-				            val partitioner = objStream.readObject().asInstanceOf[Partitioner]
-				            objStream.close
+                    val partitionLength = in.readInt()
+                    val partitionBytes = new Array[Byte](partitionLength)
+                    in.readFully(partitionBytes)
+                    val inStream = new ByteArrayInputStream(partitionBytes)
+                    val objStream = new ObjectInputStream(inStream)
+                    val partitioner = objStream.readObject().asInstanceOf[Partitioner]
+                    objStream.close
 
                     val cal = new GregorianCalendar(2011, 1, 1)
 				    var cubeCreationTime=cal.getTime().getTime()
                     try {
 				    cubeCreationTime = in.readLong()
-				            	len = in.readInt()
-		            		}
+                    len = in.readInt()
+                    }
                     catch {
                       case others: EOFException => len = 0
-		            		}
-				        	val mondSchema = OlapMetastoreCatalog.parseStringToSchema(schema)
-                  val cubeUniqueName = schemaName + "_" + cubeName
-		            		MolapMetadata.getInstance().loadSchema(mondSchema)
-		            		val cube = MolapMetadata.getInstance().getCube(cubeUniqueName)
+                    }
+                    val mondSchema = OlapMetastoreCatalog.parseStringToSchema(schema)
+                    val cubeUniqueName = schemaName + "_" + cubeName
+                    MolapMetadata.getInstance().loadSchema(mondSchema)
+                    val cube = MolapMetadata.getInstance().getCube(cubeUniqueName)
                     metaDataBuffer += CubeMeta(
-		            				schemaName,
-		            				cubeName,
-		            				dataPath,
-		            				mondSchema,
-		            				cube,
+                      schemaName,
+                      cubeName,
+                      dataPath,
+                      mondSchema,
+                      cube,
 				      updatePartitioner(partitioner, cube),
 				      cubeCreationTime)
-		            	}
-		            	in.close
-	            	}
-	            }
-	          })
-	        }
-	      })
+                  }
+                  in.close
+                }
+              }
+            })
+          }
+        })
       }
       else {
-	      //Create folders and files.
-	      FileFactory.mkdirs(schemasPath, fileType)
-	      //FileFactory.createNewFile(metadataPath+"/"+"metadata", fileType)
+        //Create folders and files.
+        FileFactory.mkdirs(schemasPath, fileType)
+        //FileFactory.createNewFile(metadataPath+"/"+"metadata", fileType)
         
-	    }
+      }
     }
     catch {
       case s: java.io.FileNotFoundException =>
@@ -424,8 +421,8 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
   }
 
   /**
-   * Add schema to the catalog and perisist to the metadata
-   */
+    * Add schema to the catalog and perisist to the metadata
+    */
   def createCube(schemaName: String, cubeName: String, schemaXML: String, partitioner: Partitioner, aggTablesGen: Boolean)
                 (sqlContext: SQLContext) : String =  {
     if (cubeExists(Seq(schemaName, cubeName))(sqlContext))
@@ -448,24 +445,19 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
     } else {
       metadataPath + "/store"
     }
-    
+
     val cubeCreationTime = System.currentTimeMillis()
     val cubeMeta = CubeMeta(
-        schemaName,
-        cubeName,
+      schemaName,
+      cubeName,
       dataPath,
-        schema,
-        cube,
+      schema,
+      cube,
         updatePartitioner(partitioner, cube),
         cubeCreationTime)
 
     val fileType = FileFactory.getFileType(metadataPath)
-    //Debug code to print complexTypes
-//    val relation = CarbonEnv.getInstance(sqlContext).carbonCatalog.
-//    	lookupRelation2(Seq(cubeMeta.schemaName, cubeMeta.cubeName))(sqlContext).asInstanceOf[OlapRelation]
-//    val complexTypes = cubeMeta.schema.cubes(0).dimensions.filter(aDim => aDim.asInstanceOf[MolapDef.Dimension].hierarchies(0).levels.length > 1).map(dim => dim.name)
-//    val complexTypeStrings = relation.output.filter(attr => complexTypes.contains(attr.name)).map(attr => (attr.name, attr.dataType.simpleString))
-//    complexTypeStrings.map(a => println(a._1 +" "+a._2))
+
     if (!FileFactory.isFileExist(cubeMetaDataPath, fileType)) {
       FileFactory.mkdirs(cubeMetaDataPath, fileType)
     }
@@ -474,34 +466,34 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
 
     val out = FileFactory.getDataOutputStream(cubeMetaDataPath + "/" + "metadata", fileType)
 
-      val schemaNameBytes = cubeMeta.schemaName.getBytes()
-      val cubeNameBytes = cubeMeta.cubeName.getBytes()
-      val dataPathBytes = cubeMeta.dataPath.getBytes()
-      val schemaArray = cubeMeta.schema.toXML.getBytes()
-      val outStream = new ByteArrayOutputStream
-      val objStream = new ObjectOutputStream(outStream)
-      objStream.writeObject(cubeMeta.partitioner);
-      objStream.close
-      val partitionArray = outStream.toByteArray()
-      val partitionClass = cubeMeta.partitioner.partitionClass.getBytes()
+    val schemaNameBytes = cubeMeta.schemaName.getBytes()
+    val cubeNameBytes = cubeMeta.cubeName.getBytes()
+    val dataPathBytes = cubeMeta.dataPath.getBytes()
+    val schemaArray = cubeMeta.schema.toXML.getBytes()
+    val outStream = new ByteArrayOutputStream
+    val objStream = new ObjectOutputStream(outStream)
+    objStream.writeObject(cubeMeta.partitioner);
+    objStream.close
+    val partitionArray = outStream.toByteArray()
+    val partitionClass = cubeMeta.partitioner.partitionClass.getBytes()
     val versionNoBytes = MolapVersion.getCubeVersion().getBytes()
-      out.writeInt(schemaNameBytes.length)
-      out.write(schemaNameBytes)
-      out.writeInt(cubeNameBytes.length)
-      out.write(cubeNameBytes)
-      out.writeInt(dataPathBytes.length)
-      out.write(dataPathBytes)
-      out.writeInt(versionNoBytes.length)
-      out.write(versionNoBytes)
-      out.writeInt(schemaArray.length)
-      out.write(schemaArray)
-      out.writeInt(partitionArray.length)
-      out.write(partitionArray)
+    out.writeInt(schemaNameBytes.length)
+    out.write(schemaNameBytes)
+    out.writeInt(cubeNameBytes.length)
+    out.write(cubeNameBytes)
+    out.writeInt(dataPathBytes.length)
+    out.write(dataPathBytes)
+    out.writeInt(versionNoBytes.length)
+    out.write(versionNoBytes)
+    out.writeInt(schemaArray.length)
+    out.write(schemaArray)
+    out.writeInt(partitionArray.length)
+    out.write(partitionArray)
       out.writeLong(cubeCreationTime)
-      out.close
+    out.close
 
-      metadata.cubesMeta += cubeMeta
-      logInfo(s"Cube $cubeName for schema $schemaName created successfully.")
+    metadata.cubesMeta += cubeMeta
+    logInfo(s"Cube $cubeName for schema $schemaName created successfully.")
     LOGGER.info(MolapEngineLogEvent.UNIBI_MOLAPENGINE_MSG, "Cube " + cubeName + " for schema " + schemaName + " created successfully.")
     updateSchemasUpdatedTime(schemaName, cubeName)
     metadataPath + "/" + schemaName + "/" + cubeName
@@ -541,54 +533,54 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
   //}
   /*
    * This method will return the list of executers in the cluster.
- * For this we take the  memory status of all node with getExecutorMemoryStatus
+   * For this we take the  memory status of all node with getExecutorMemoryStatus
    * and extract the keys. getExecutorMemoryStatus also returns the driver memory also
- * In client mode driver will run in the localhost
+   * In client mode driver will run in the localhost
    * There can be executor spawn in same drive node. So we can remove first occurance of
- * localhost for retriving executor list
- */
+   * localhost for retriving executor list
+   */
   def getNodeList(): Array[String] = {
 
     val arr =
       sparkContext.getExecutorMemoryStatus.map {
         kv =>
-	    	  kv._1.split(":")(0)
-	    	//val addr = InetAddress.getByName( (kv._1.split(":")(0)) )
-	    	//addr.getHostName()
-		}.toSeq
+          kv._1.split(":")(0)
+        //val addr = InetAddress.getByName( (kv._1.split(":")(0)) )
+        //addr.getHostName()
+      }.toSeq
     val localhostIPs = getLocalhostIPs
- //   val ipcheck: List[(String,Boolean)] = localhostIPs.map( x=> (x,arr.contains(x))).filter()
+    //   val ipcheck: List[(String,Boolean)] = localhostIPs.map( x=> (x,arr.contains(x))).filter()
 
     val selectedLocalIPList = localhostIPs.filter(arr.contains(_))
 
     val nodelist: List[String] = withoutDriverIP(arr.toList)(selectedLocalIPList.contains(_))
-	val masterMode = sparkContext.getConf.get("spark.master")
+    val masterMode = sparkContext.getConf.get("spark.master")
     if (nodelist.length > 0) {
       //Specific for Yarn Mode
       if ("yarn-cluster".equals(masterMode) || "yarn-client".equals(masterMode)) {
         val nodeNames = nodelist.map { x =>
-				val addr = InetAddress.getByName(x)
-				addr.getHostName()
-		 	}
-			nodeNames.toSeq.toArray
-	    }
+          val addr = InetAddress.getByName(x)
+          addr.getHostName()
+        }
+        nodeNames.toSeq.toArray
+      }
       else {
-	      //For Standalone cluster, node IPs will be returned.
-	    	nodelist.toArray
-	}
+        //For Standalone cluster, node IPs will be returned.
+        nodelist.toArray
+      }
     }
-	else
-		Seq(InetAddress.getLocalHost().getHostName()).toArray
+    else
+      Seq(InetAddress.getLocalHost().getHostName()).toArray
   }
 
   def getLocalhostIPs() = {
-     val iface = NetworkInterface.getNetworkInterfaces()
+    val iface = NetworkInterface.getNetworkInterfaces()
     var addresses: List[InterfaceAddress] = List.empty
     while (iface.hasMoreElements()) {
-     	addresses = iface.nextElement().getInterfaceAddresses().toList ++ addresses
-     }
-     val inets = addresses.map(_.getAddress().getHostAddress())
-     inets
+      addresses = iface.nextElement().getInterfaceAddresses().toList ++ addresses
+    }
+    val inets = addresses.map(_.getAddress().getHostAddress())
+    inets
   }
 
   /*
@@ -598,36 +590,36 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
  * The resulting List containt List(slave1,Master,slave2,slave3)  
  *  
  */
-   def withoutDriverIP[A](xs: List[A])(p: A => Boolean): List[A] = xs.toList match {
-  	case x :: rest =>  if (p(x)) rest else x :: withoutDriverIP(rest)(p)
-  	case _ => Nil
+  def withoutDriverIP[A](xs: List[A])(p: A => Boolean): List[A] = xs.toList match {
+    case x :: rest => if (p(x)) rest else x :: withoutDriverIP(rest)(p)
+    case _ => Nil
   }
 
- /* def getLocalhosts() = {
-    val iface = NetworkInterface.getNetworkInterfaces()
-    val ifaces_list = new scala.collection.JavaConversions.JEnumerationWrapper(iface)
-    val ips = ifaces_list.toSeq.map(x=>new JEnumerationWrapper(x.getInetAddresses).map(_.getAddress()))
+  /* def getLocalhosts() = {
+     val iface = NetworkInterface.getNetworkInterfaces()
+     val ifaces_list = new scala.collection.JavaConversions.JEnumerationWrapper(iface)
+     val ips = ifaces_list.toSeq.map(x=>new JEnumerationWrapper(x.getInetAddresses).map(_.getAddress()))
 
-  }
+   }
    *
-  */
-	/*
-	val set = new TreeSet[String]
+   */
+  /*
+  val set = new TreeSet[String]
     olap.sparkContext.getExecutorMemoryStatus.foreach{kv=>
       set.add(kv._1.split(":")(0))
     }
-	if(set.size>0)
-	{
-	    if(!olap.sparkContext.getConf.get("spark.executor.at.driver","true").toBoolean) {
-	      val curHostName = InetAddress.getLocalHost().getHostName()
-	      set.filterNot(_.equalsIgnoreCase(curHostName)).toArray
-	    } else {
+  if(set.size>0)
+  {
+      if(!olap.sparkContext.getConf.get("spark.executor.at.driver","true").toBoolean) {
+        val curHostName = InetAddress.getLocalHost().getHostName()
+        set.filterNot(_.equalsIgnoreCase(curHostName)).toArray
+      } else {
         set.toArray
-	    }
-	} else {
-	  Seq("localhost").toArray
-	}
-	* */
+      }
+  } else {
+    Seq("localhost").toArray
+  }
+  * */
 
 
   def loadCube(schemaPath: String, encrypted: Boolean, aggTablesGen: Boolean, partitioner: Partitioner)(sqlContext: SQLContext) {
@@ -676,7 +668,7 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
       if (null != cube.getMeasure(cube.getFactTableName(), colName)) sys.error(s"Measure must be provided along with aggregate function :: $colName")
       if (null == cube.getDimensionByLevelName(colName, colName, colName, cube.getFactTableName())) sys.error(s"Invalid column name. Cannot create an aggregate table :: $colName")
       if (dimArray.contains(colName)) {
-         sys.error(s"Duplicate column name. Cannot create an aggregate table :: $colName")
+        sys.error(s"Duplicate column name. Cannot create an aggregate table :: $colName")
       }
       dimArray :+= colName
     }
@@ -765,13 +757,13 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
     return newAggregateTableName
   }
 
-  def  updateCube(schema: MolapDef.Schema, aggTablesGen: Boolean)(sqlContext: SQLContext) {
+  def updateCube(schema: MolapDef.Schema, aggTablesGen: Boolean)(sqlContext: SQLContext) {
     val schemaName = schema.name
     val cubeName = schema.cubes(0).name
     val schemaXML: String = schema.toXML
     if (!cubeExists(Seq(schemaName, cubeName))(sqlContext)) {
-       sys.error(s"Cube does not exist with $schemaName and $cubeName to update")
-     }
+      sys.error(s"Cube does not exist with $schemaName and $cubeName to update")
+    }
     val schemaNew = OlapMetastoreCatalog.parseStringToSchema(schemaXML)
     //if(aggTablesGen) schemaNew = GenerateAggTables(schemaNew).apply
     //Remove the cube and load again for aggregates.
@@ -790,7 +782,7 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
     {
       oldMetadataFile.delete()
     }*/
-    val fileOperation = new AtomicFileOperationsImpl(metadataFilePath, FileFactory.getFileType(metadataFilePath))
+
     val tempMetadataFilePath = metadataFilePath + MolapCommonConstants.UPDATING_METADATA
 
     if (FileFactory.isFileExist(tempMetadataFilePath, fileType)) {
@@ -804,7 +796,7 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
     metadata.cubesMeta.map { c =>
       if (c.schemaName.equalsIgnoreCase(schemaName) && c.cubeName.equalsIgnoreCase(cubeName)) {
         val cubeMeta = CubeMeta(schemaName, cubeName, metadataPath+"/store", schemaNew, cube, updatePartitioner(c.partitioner, cube),c.cubeCreationTime)
-        val out = fileOperation.openForWrite(FileWriteOperation.OVERWRITE)
+        val out = FileFactory.getDataOutputStream(tempMetadataFilePath, fileType)
 
         val schemaNameBytes = c.schemaName.getBytes()
         val cubeNameBytes = c.cubeName.getBytes()
@@ -826,14 +818,13 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
         out.write(dataPathBytes)
         out.writeInt(versionNoBytes.length)
         out.write(versionNoBytes)
-      	out.writeInt(schemaArray.length)
-      	out.write(schemaArray)
-      	out.writeInt(partitionArray.length)
-      	out.write(partitionArray)
+        out.writeInt(schemaArray.length)
+        out.write(schemaArray)
+        out.writeInt(partitionArray.length)
+        out.write(partitionArray)
         out.writeLong(c.cubeCreationTime)
-      	fileOperation.close()
-//      	out.close
-//      	tempMetadataFile.renameForce(oldMetadataFile.getAbsolutePath())
+        out.close
+        tempMetadataFile.renameForce(oldMetadataFile.getAbsolutePath())
       }
 
 
@@ -851,8 +842,8 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
   }
 
   /**
-   * Shows all schemas which has schema name like
-   */
+    * Shows all schemas which has schema name like
+    */
   def showSchemas(schemaLike: Option[String]): Seq[String] = {
     checkSchemasModifiedTimeAndReloadCubes()
     metadata.cubesMeta.map { c =>
@@ -866,9 +857,9 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
   }
 
   /**
-   * Shows all cubes for given schema.
-   */
- def getCubes(databaseName: Option[String])(sqlContext: SQLContext): Seq[(String, Boolean)] = {
+    * Shows all cubes for given schema.
+    */
+  def getCubes(databaseName: Option[String])(sqlContext: SQLContext): Seq[(String, Boolean)] = {
 
     val schemaName = databaseName.getOrElse(sqlContext.asInstanceOf[HiveContext].catalog.client.currentDatabase)
     checkSchemasModifiedTimeAndReloadCubes()
@@ -877,10 +868,10 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
     }.map { c => (c.cubeName, false) }
   }
 
- /**
-   * Shows all cubes in all schemas.
-   */
- def getAllCubes()(sqlContext: SQLContext): Seq[(String, String)] = {
+  /**
+    * Shows all cubes in all schemas.
+    */
+  def getAllCubes()(sqlContext: SQLContext): Seq[(String, String)] = {
     checkSchemasModifiedTimeAndReloadCubes()
     metadata.cubesMeta.map { c => (c.schemaName, c.cubeName) }
   }
@@ -894,26 +885,26 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
     val cube = MolapMetadata.getInstance().getCube(schemaName + '_' + cubeName)
 
     if (null != cube) {
-    	val metadatFilePath = MolapMetadata.getInstance().getCube(schemaName + '_' + cubeName).getMetaDataFilepath()
-    	val fileType = FileFactory.getFileType(metadatFilePath)
+      val metadatFilePath = MolapMetadata.getInstance().getCube(schemaName + '_' + cubeName).getMetaDataFilepath()
+      val fileType = FileFactory.getFileType(metadatFilePath)
 
       if (FileFactory.isFileExist(metadatFilePath, fileType)) {
-    	    val file = FileFactory.getMolapFile(metadatFilePath, fileType)
-          MolapUtil.renameCubeForDeletion(partitionCount, storePath, schemaName, cubeName)
-    	    MolapUtil.deleteFoldersAndFilesSilent(file)
-    	}
+        val file = FileFactory.getMolapFile(metadatFilePath, fileType)
+        MolapUtil.renameCubeForDeletion(partitionCount, storePath, schemaName, cubeName)
+        MolapUtil.deleteFoldersAndFilesSilent(file)
+      }
 
-    	val partitionLocation = storePath + File.separator + "partition" + File.separator + schemaName + File.separator + cubeName
-    	val partitionFileType = FileFactory.getFileType(partitionLocation)
+      val partitionLocation = storePath + File.separator + "partition" + File.separator + schemaName + File.separator + cubeName
+      val partitionFileType = FileFactory.getFileType(partitionLocation)
       if (FileFactory.isFileExist(partitionLocation, partitionFileType)) {
-    	   MolapUtil.deleteFoldersAndFiles(FileFactory.getMolapFile(partitionLocation, partitionFileType))
-    	}
+        MolapUtil.deleteFoldersAndFiles(FileFactory.getMolapFile(partitionLocation, partitionFileType))
+      }
     }
 
     try {
-          sqlContext.sql(s"DROP TABLE $schemaName.$cubeName").collect()
+      sqlContext.sql(s"DROP TABLE $schemaName.$cubeName").collect()
     } catch {
-        case e: Exception =>
+      case e: Exception =>
         LOGGER.audit(s"Error While deleting the table $schemaName.$cubeName during drop cube" + e.getMessage)
     }
 
@@ -929,14 +920,14 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
     var timestampFile =  if(useUniquePath)
     {
        metadataPath + "/" + schemaName + "/" + cubeName + "/schemas/" + MolapCommonConstants.SCHEMAS_MODIFIED_TIME_FILE
-  }
+    }
     else
     {
        metadataPath + "/schemas/" + MolapCommonConstants.SCHEMAS_MODIFIED_TIME_FILE
     }
-  
-      val timestampFileType = FileFactory.getFileType(timestampFile)
-      (timestampFile, timestampFileType)
+    
+    val timestampFileType = FileFactory.getFileType(timestampFile)
+    (timestampFile, timestampFileType)
   }
 
   def updateSchemasUpdatedTime(schemaName : String, cubeName : String) {
@@ -948,21 +939,21 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
     }
 
     touchSchemasTimestampFile(schemaName, cubeName)
-  
+    
     if(useUniquePath)
-  {
+    {
       cubeModifiedTimeStore.put(schemaName + '_' + cubeName, FileFactory.getMolapFile(timestampFile, timestampFileType).getLastModifiedTime())
     }
     else
-	  {
+    {
       cubeModifiedTimeStore.put("default", FileFactory.getMolapFile(timestampFile, timestampFileType).getLastModifiedTime())
-	  }
-	  
+    }
+    
   }
 
   def touchSchemasTimestampFile(schemaName : String, cubeName : String) {
    val (timestampFile, timestampFileType) = getTimestampFileAndType(schemaName, cubeName)
-	  FileFactory.getMolapFile(timestampFile, timestampFileType).setLastModifiedTime(System.currentTimeMillis())
+    FileFactory.getMolapFile(timestampFile, timestampFileType).setLastModifiedTime(System.currentTimeMillis())
   }
 
   def checkSchemasModifiedTimeAndReloadCubes() {
@@ -972,9 +963,9 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
 
         if (FileFactory.isFileExist(timestampFile, timestampFileType)) {
           if (!(FileFactory.getMolapFile(timestampFile, timestampFileType).getLastModifiedTime() == cubeModifiedTimeStore.get(c.schemaName + "_" + c.cubeName))) {
-		    refreshCache
-		  }
-	  }
+            refreshCache
+          }
+        }
       })
     } else {
       val (timestampFile, timestampFileType) = getTimestampFileAndType("", "")
@@ -982,7 +973,7 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
         if (!(FileFactory.getMolapFile(timestampFile, timestampFileType).
           getLastModifiedTime() == cubeModifiedTimeStore.get("default"))) {
           refreshCache
-  }
+        }
       }
     }
   }
@@ -1001,26 +992,26 @@ class OlapMetastoreCatalog(sparkContext: SparkContext, val metadataPath: String)
   }
 
   private def loadCubeFromMetaData(
-    fileType: com.huawei.unibi.molap.datastorage.store.impl.FileFactory.FileType,
-    buffer: scala.collection.mutable.ArrayBuffer[org.apache.spark.sql.CubeMeta],
-    cubeFolder: com.huawei.unibi.molap.datastorage.store.filesystem.MolapFile): Unit = {
-        if (cubeFolder.isDirectory()) {
+                                    fileType: com.huawei.unibi.molap.datastorage.store.impl.FileFactory.FileType,
+                                    buffer: scala.collection.mutable.ArrayBuffer[org.apache.spark.sql.CubeMeta],
+                                    cubeFolder: com.huawei.unibi.molap.datastorage.store.filesystem.MolapFile): Unit = {
+    if (cubeFolder.isDirectory()) {
 
          val (schemaName,cubeName,dataPath,schema,partitioner,cubeCreationTime) = readCubeMetaDataFile(cubeFolder,fileType)
 
-            val mondSchema = OlapMetastoreCatalog.parseStringToSchema(schema)
-            val cubeUniqueName = schemaName + "_" + cubeName
-            MolapMetadata.getInstance().loadSchema(mondSchema)
-            val cube = MolapMetadata.getInstance().getCube(cubeUniqueName)
-            buffer += CubeMeta(
-                schemaName,
-                cubeName,
-                dataPath,
-                mondSchema,
-                cube,
+      val mondSchema = OlapMetastoreCatalog.parseStringToSchema(schema)
+      val cubeUniqueName = schemaName + "_" + cubeName
+      MolapMetadata.getInstance().loadSchema(mondSchema)
+      val cube = MolapMetadata.getInstance().getCube(cubeUniqueName)
+      buffer += CubeMeta(
+        schemaName,
+        cubeName,
+        dataPath,
+        mondSchema,
+        cube,
                 updatePartitioner(partitioner, cube),cubeCreationTime)
-          }
-        }
+    }
+  }
 
   def readCubeMetaDataFile(cubeFolder: com.huawei.unibi.molap.datastorage.store.filesystem.MolapFile, fileType: com.huawei.unibi.molap.datastorage.store.impl.FileFactory.FileType): (String, String, String, String, Partitioner, Long) = {
     val cubeMetadataFile = cubeFolder.getAbsolutePath() + "/metadata"
@@ -1104,14 +1095,13 @@ object OlapMetastoreTypes extends RegexParsers {
       "bigint" ^^^ LongType |
       "binary" ^^^ BinaryType |
       "boolean" ^^^ BooleanType |
-      "decimal" ^^^ DecimalType() |
+//      "decimal" ^^^ DecimalType() |
+      "decimal" ^^^ "decimal" ^^^ DecimalType(17, 2) |     //mod by ggin
       "varchar\\((\\d+)\\)".r ^^^ StringType |
       "timestamp" ^^^ TimestampType
 
-    protected lazy val arrayType: Parser[DataType] =
-      "array" ~> "<" ~> dataType<~ ">" ^^ {
-        case tpe => ArrayType(tpe)
-    }
+  //  protected lazy val arrayType: Parser[DataType] =
+  //    "array" ~> "<" ~> dataType <~ ">" ^^ ArrayType
 
   protected lazy val mapType: Parser[DataType] =
     "map" ~> "<" ~> dataType ~ "," ~ dataType <~ ">" ^^ {
@@ -1123,15 +1113,13 @@ object OlapMetastoreTypes extends RegexParsers {
       case name ~ _ ~ tpe => StructField(name, tpe, nullable = true)
     }
 
-    protected lazy val structType: Parser[DataType] =
-      "struct" ~> "<" ~> repsep(structField,",") <~ ">" ^^ {
-        case fields => StructType(fields)
-    }
+  //  protected lazy val structType: Parser[DataType] =
+  //    "struct" ~> "<" ~> repsep(structField,",") <~ ">" ^^ StructType
 
   protected lazy val dataType: Parser[DataType] =
-      arrayType |
-      mapType |
-      structType |
+  //    arrayType |
+    mapType |
+      //      structType |
       primitiveType
 
   def toDataType(metastoreType: String): DataType = parseAll(dataType, metastoreType) match {
@@ -1140,7 +1128,7 @@ object OlapMetastoreTypes extends RegexParsers {
   }
 
   def toMetastoreType(dt: DataType): String = dt match {
-    case ArrayType(elementType, _) => s"array<${toMetastoreType(elementType)}>"
+    //    case ArrayType(elementType) => s"array<${toMetastoreType(elementType)}>"
     case StructType(fields) =>
       s"struct<${fields.map(f => s"${f.name}:${toMetastoreType(f.dataType)}").mkString(",")}>"
     //    case MapType(keyType, valueType) =>
@@ -1154,9 +1142,7 @@ object OlapMetastoreTypes extends RegexParsers {
     case BinaryType => "binary"
     case BooleanType => "boolean"
     case DecimalType() => "decimal"
-    case TimestampType => "timestamp"
   }
-  
 }
 
 case class OlapMetaData(dims: Seq[String], msrs: Seq[String], cube: Cube)
diff --git a/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/OlapRelation.scala b/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/OlapRelation.scala
index 3acab92..eb52471 100644
--- a/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/OlapRelation.scala
+++ b/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/OlapRelation.scala
@@ -15,9 +15,6 @@ import scala.collection.JavaConversions.seqAsJavaList
 import scala.language.implicitConversions
 import java.util.LinkedHashSet
 import org.apache.spark.sql.types.StructType
-import java.util.HashMap
-import org.apache.spark.sql.types.DataType
-import org.apache.spark.sql.types.StringType
 
 
 /**
@@ -82,36 +79,6 @@ case class OlapRelation(schemaName: String,
 
   def tableName = cubeName
 
-  def recursiveMethod(dimName: String) : String = {
-	metaData.cube.getChildren(dimName).map(childDim => {
-		childDim.getDataType().toString.toLowerCase match {
-			case "array" => s"array<${getArrayChildren(childDim.getColName)}>"
-			case "struct" => s"struct<${getStructChildren(childDim.getColName)}>"
-			case dType => s"${childDim.getColName()}:${dType}"
-		}
-	}).mkString(",")
-  }
-  
-  def getArrayChildren(dimName: String) : String = {
-	metaData.cube.getChildren(dimName).map(childDim => {
-		childDim.getDataType().toString.toLowerCase match {
-		    case "array" => s"array<${getArrayChildren(childDim.getColName())}>"
-			case "struct" => s"struct<${getStructChildren(childDim.getColName())}>"
-			case dType => dType
-		}
-	}).mkString(",")
-  }
-  
-  def getStructChildren(dimName: String) : String = {
-    metaData.cube.getChildren(dimName).map(childDim => {
-		childDim.getDataType().toString.toLowerCase match {
-		    case "array" => s"${childDim.getColName().substring(childDim.getParentName.length()+1)}:array<${getArrayChildren(childDim.getColName())}>"
-			case "struct" => s"struct<${metaData.cube.getChildren(childDim.getColName).map(f => s"${recursiveMethod(f.getColName)}")}>"
-			case dType => s"${childDim.getColName.substring(childDim.getParentName.length()+1)}:${dType}"
-		}
-	}).mkString(",")
-  }
-  
   //  def getSchemaPath = schemaPath
   override def newInstance() = OlapRelation(schemaName, cubeName, metaData, cubeMeta, alias)(sqlContext).asInstanceOf[this.type]
 
@@ -119,32 +86,23 @@ case class OlapRelation(schemaName: String,
     val filteredDimAttr = cubeMeta.schema.cubes(0).dimensions.filter { aDim => (null == aDim.asInstanceOf[MolapDef.Dimension].hierarchies(0).levels(0).visible) ||
       (aDim.asInstanceOf[MolapDef.Dimension].hierarchies(0).levels(0).visible)
     }
-    
-     
     val sett = new LinkedHashSet(filteredDimAttr.toSeq)
-    sett.toSeq.map(dim => 
-    {
-    	val output: DataType = metaData.cube.getDimension(dim.name).getDataType().toString.toLowerCase match {
-    	  case "array" => OlapMetastoreTypes.toDataType(s"array<${getArrayChildren(dim.name)}>")
-    	  case "struct" => OlapMetastoreTypes.toDataType(s"struct<${getStructChildren(dim.name)}>")
-    	  case dType => OlapMetastoreTypes.toDataType(dType)
-    	}
-    	
-//          println(OlapMetastoreTypes.toMetastoreType(output))
-    	  AttributeReference(
-    		  dim.name,
-//    		  OlapMetastoreTypes.toDataType(metaData.cube.getDimension(dim.name).getDataType().toString.toLowerCase),
-    		  output,
-    		  nullable = true)(qualifiers = tableName +: alias.toSeq)
-      }
-    )
+    sett.toSeq.map(x => AttributeReference(
+      x.name,
+      OlapMetastoreTypes.toDataType(metaData.cube.getDimension(x.name).getDataType().toString.toLowerCase),
+      nullable = true)(qualifiers = tableName +: alias.toSeq))
   }
 
   val measureAttr = {
     val filteredMeasureAttr = cubeMeta.schema.cubes(0).measures.filter { aMsr => (null == aMsr.visible) || (aMsr.visible) }
     new LinkedHashSet(filteredMeasureAttr.toSeq).toSeq.map(x => AttributeReference(
       x.name,
-      OlapMetastoreTypes.toDataType("double"),
+//      OlapMetastoreTypes.toDataType("double"),
+      OlapMetastoreTypes.toDataType(metaData.cube.getMeasure(x.name).getDataType().toString.toLowerCase match
+      {
+        case "int" => "double"
+        case _ => metaData.cube.getMeasure(x.name).getDataType().toString.toLowerCase
+      }),
       nullable = true)(qualifiers = tableName +: alias.toSeq))
   }
 
diff --git a/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/SparkUnknownMolapAggregator.scala b/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/SparkUnknownMolapAggregator.scala
index 9e00e8f..c41e266 100644
--- a/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/SparkUnknownMolapAggregator.scala
+++ b/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/SparkUnknownMolapAggregator.scala
@@ -25,6 +25,7 @@ import com.huawei.unibi.molap.engine.molapfilterinterface.RowIntf
 import com.huawei.unibi.molap.engine.expression.ColumnExpression
 import org.apache.spark.sql.catalyst.expressions.GenericMutableRow
 import java.util.ArrayList
+import com.huawei.unibi.molap.datastorage.store.dataholder.MolapReadDataHolder
 
 
 /**
@@ -51,23 +52,35 @@ class SparkUnknownMolapAggregator(partialAggregate: AggregateExpression1) extend
 
   var isRowsAggregated: Boolean = false
 
-  override def agg(newVal: Double, key: Array[Byte], offset: Int, length: Int) = {
+  override def agg(newVal: Double) = {
 
-    throw new UnsupportedOperationException("agg(double, byte[],int,int) is not a valid method for aggregation");
+    throw new UnsupportedOperationException("agg(double) is not a valid method for aggregation");
   }
 
-  override def agg(newVal: Any, key: Array[Byte], offset: Int, length: Int) = {
-    throw new UnsupportedOperationException("agg(Object, .byte[],int,int) is not a valid method for aggregation");
+  override def agg(newVal: Any) = {
+    throw new UnsupportedOperationException("agg(Object) is not a valid method for aggregation");
+  }
+
+  override def agg(newVal: MolapReadDataHolder, index: Int) = {
+    throw new UnsupportedOperationException("agg(MolapReadDataHolder, int) is not a valid method for aggregation");
   }
 
   override def getByteArray(): Array[Byte] = {
     throw new UnsupportedOperationException("getByteArray  is not implemented yet");
   }
 
-  override def getValue(): Double = {
+  override def getDoubleValue(): java.lang.Double = {
     throw new UnsupportedOperationException("getValue() is not a valid method for result");
   }
 
+  override def getLongValue(): java.lang.Long = {
+    throw new UnsupportedOperationException("getLongValue() is not a valid method for result");
+  }
+
+  override def getBigDecimalValue(): java.math.BigDecimal = {
+    throw new UnsupportedOperationException("getBigDecimalValue() is not a valid method for result");
+  }
+
   override def getValueObject(): Object = {
 
     result.iterator.foreach(v => getPartialFunction.update(v))
@@ -154,13 +167,13 @@ class SparkUnknownMolapAggregator(partialAggregate: AggregateExpression1) extend
     return new SparkUnknownMolapAggregator(partialAggregate)
   }
 
-  override def setNewValue(newValue: Double) = {
+  override def setNewValue(newVal: Object) = {
 
   }
 
-  override def agg(newVal: Double, factCount: Double) {
-    throw new UnsupportedOperationException("agg(Double, Double) is not a valid method for aggregation");
-  }
+//  override def agg(newVal: Double, factCount: Double) {
+//    throw new UnsupportedOperationException("agg(Double, Double) is not a valid method for aggregation");
+//  }
 
   override def getColumns() = {
     if (allColumns == null) {
diff --git a/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/cubemodel/cubeSchema.scala b/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/cubemodel/cubeSchema.scala
index 8aad313..bec4d7d 100644
--- a/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/cubemodel/cubeSchema.scala
+++ b/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/cubemodel/cubeSchema.scala
@@ -89,25 +89,16 @@ case class CubeModel(
                       factFieldsList: Option[FilterCols],
                       dimRelations: Seq[DimensionRelation],
                       simpleDimRelations: Seq[DimensionRelation],
-    highcardinalitydims:Option[Seq[String]],
                       aggregation: Seq[Aggregation],
                       partitioner: Option[Partitioner])
 
 
-case class Field(column: String, dataType: Option[String], name: Option[String], children : Option[List[Field]], parent: String = null)
-
-case class ArrayDataType(dataType: String)
-
-case class StructDataType(dataTypes: List[String])
-
-case class StructField(column: String, dataType: String)
+case class Field(column: String, dataType: Option[String], name: Option[String])
 
 case class FieldMapping(levelName: String, columnName: String)
 
 case class HierarchyMapping(hierName: String, hierType: String, levels: Seq[String])
 
-case class ComplexField(complexType: String, primitiveField: Option[Field], complexField: Option[ComplexField])
-
 case class Cardinality(levelName: String, cardinality: Int)
 
 case class Aggregation(msrName: String, aggType: String)
@@ -120,13 +111,13 @@ case class DimensionRelation(tableName: String, dimSource: Object, relation: Rel
 
 case class Relation(leftColumn: String, rightColumn: String)
 
-case class Level(name: String, val column: String, cardinality: Int, dataType: String, parent: String = null, levelType: String = "Regular")
+case class Level(name: String, val column: String, cardinality: Int, dataType: String, levelType: String = "Regular")
 
 case class Measure(name: String, column: String, dataType: String, aggregator: String = "SUM", visible: Boolean = true)
 
 case class Hierarchy(name: String, primaryKey: Option[String], levels: Seq[Level], tableName: Option[String], normalized: Boolean = false)
 
-case class Dimension(name: String, hierarchies: Seq[Hierarchy], foreignKey: Option[String], dimType: String = "StandardDimension", visible: Boolean = true,var highCardinality: Boolean = false)
+case class Dimension(name: String, hierarchies: Seq[Hierarchy], foreignKey: Option[String], dimType: String = "StandardDimension", visible: Boolean = true, highCardinality: Boolean = false)
 
 case class FilterCols(includeKey: String, fieldList: Seq[String])
 
@@ -146,21 +137,6 @@ class CubeProcessor(cm: CubeModel, sqlContext: SQLContext) {
   val timeDims = Seq("TimeYears", "TimeMonths", "TimeDays", "TimeHours", "TimeMinutes")
   val numericTypes = Seq(MolapCommonConstants.INTEGER_TYPE, MolapCommonConstants.DOUBLE_TYPE, MolapCommonConstants.LONG_TYPE, MolapCommonConstants.FLOAT_TYPE)
 
-  def getAllChildren(fieldChildren : Option[List[Field]]) : Seq[Level]  = {
-      var levels: Seq[Level] = Seq[Level]()
-	   fieldChildren.map(fields => {
-	        fields.map(field => {
-	        	  if(field.parent != null)
-		    		 levels ++= Seq(Level(field.name.getOrElse(field.column), field.column, Int.MaxValue, field.dataType.getOrElse(MolapCommonConstants.STRING), field.parent))
-		    	 else
-		    		 levels ++= Seq(Level(field.name.getOrElse(field.column), field.column, Int.MaxValue, field.dataType.getOrElse(MolapCommonConstants.STRING)))
-	        	  if(field.children.get != null)
-	        		  levels ++= getAllChildren(field.children)
-	      	})
-	   })
-	   levels
-  }
-  
   def process(): Cube = {
 
     var levels = Seq[Level]()
@@ -169,16 +145,7 @@ class CubeProcessor(cm: CubeModel, sqlContext: SQLContext) {
     val LOGGER = LogServiceFactory.getLogService(CubeProcessor.getClass().getName())
 
     // Create Cube DDL with Schema defination
-//    levels = 
-      cm.dimCols.map(field =>
-      {
-    	 if(field.parent != null)
-    		 levels ++= Seq(Level(field.name.getOrElse(field.column), field.column, Int.MaxValue, field.dataType.getOrElse(MolapCommonConstants.STRING), field.parent))
-    	 else
-    		 levels ++= Seq(Level(field.name.getOrElse(field.column), field.column, Int.MaxValue, field.dataType.getOrElse(MolapCommonConstants.STRING)))
-    	 if(field.children.get != null)
-    		 levels ++= getAllChildren(field.children)
-      })
+    levels = cm.dimCols.map(field => Level(field.name.getOrElse(field.column), field.column, Int.MaxValue, field.dataType.getOrElse(MolapCommonConstants.STRING)))
     measures = cm.msrCols.map(field => Measure(field.name.getOrElse(field.column), field.column, field.dataType.getOrElse(MolapCommonConstants.NUMERIC)))
 
     if (cm.withKeyword.equalsIgnoreCase(MolapCommonConstants.WITH) && cm.simpleDimRelations.size > 0) {
@@ -255,53 +222,12 @@ class CubeProcessor(cm: CubeModel, sqlContext: SQLContext) {
         })
       })
     })
-    
-//    val hierarchies = levels.map(field => Hierarchy(field.name, None, Seq(field), None))
-    
-//    val hierarchies = levels.groupBy(
-//        _.name.split('.')(0)
-//        ).map(
-//        fields => 
-//          Hierarchy(fields._1, None, fields._2, None)
-//        ).toSeq
-    
-    val groupedSeq = levels.groupBy(_.name.split('.')(0))
-    val hierarchies = levels.filter(level => !level.name.contains(".")).map(parentLevel => Hierarchy(parentLevel.name, None, groupedSeq.get(parentLevel.name).get, None))
+
+    val hierarchies = levels.map(field => Hierarchy(field.name, None, Seq(field), None))
     var dimensions = hierarchies.map(field => Dimension(field.name, Seq(field), None))
 
     dimensions = dimensions ++ dimSrcDimensions
-//    val highCardinalityDims=cm.highcardinalitydims.get
-    val highCardinalityDims=cm.highcardinalitydims.getOrElse(Seq())
-    for(dimension <- dimensions)
-    {
-      
-      if(highCardinalityDims.contains(dimension.name))
-      {
-        dimension.highCardinality=true
-      }
-      
-    }
-    
-    var newOrderedDims = scala.collection.mutable.ListBuffer[Dimension]()
-    val highCardDims = scala.collection.mutable.ListBuffer[Dimension]()
-     for(dimension <- dimensions)
-    {
-      if(highCardinalityDims.contains(dimension.name))
-      {
-       // dimension.highCardinality=true
-        highCardDims.add(dimension)
-      }
-      else      
-      {
-       newOrderedDims.add(dimension)
-      }
-      
-    }
-    
-    newOrderedDims = newOrderedDims ++ highCardDims
 
-    dimensions = newOrderedDims
-    
     if (measures.length <= 0) {
       measures = measures ++ Seq(Measure(MolapCommonConstants.DEFAULT_INVISIBLE_DUMMY_MEASURE, MolapCommonConstants.DEFAULT_INVISIBLE_DUMMY_MEASURE, MolapCommonConstants.NUMERIC, MolapCommonConstants.SUM, false))
     }
@@ -437,15 +363,7 @@ private[sql] case class ShowCreateCube(cm: CubeModel, override val output: Seq[A
         specifiedCols = cols.map(_._1)
         cols
       } else {
-        df.dtypes.map(f => 
-          if(f._2.startsWith("ArrayType") || f._2.startsWith("StructType"))
-          {
-        	  val fieldIndex = df.schema.getFieldIndex(f._1).get
-        	  (f._1.trim(), df.schema.fields(fieldIndex).dataType.simpleString)
-          }
-          else
-        	  (f._1.trim(), f._2))
-        
+        df.dtypes.map(f => (f._1.trim(), f._2))
       }
 
       val columns = rawColumns.filter(c => !c._2.equalsIgnoreCase(MolapCommonConstants.BINARY_TYPE))
@@ -525,12 +443,7 @@ private[sql] case class ShowCreateCube(cm: CubeModel, override val output: Seq[A
           levels = levels.dropWhile(p => p.column.equalsIgnoreCase(relationEntry.relation.leftColumn) && !specifiedCols.map(x => x.toLowerCase()).contains(p.column.toLowerCase()))
           measures = measures.dropWhile(p => p.column.equalsIgnoreCase(relationEntry.relation.leftColumn) && !specifiedCols.map(x => x.toLowerCase()).contains(p.column.toLowerCase()))
 
-          var dimFileLevels: Seq[Level] = Seq[Level]() 
-            relColumns.map(field => {
-//            		dimFileLevels ++ = MolapScalaUtil.convertSparkColumnToMolapLevel(field)
-            		Level(field._1, field._1, Int.MaxValue, MolapScalaUtil.convertSparkToMolapSchemaDataType(field._2))
-            	}
-              )
+          val dimFileLevels = relColumns.map(field => Level(field._1, field._1, Int.MaxValue, MolapScalaUtil.convertSparkToMolapSchemaDataType(field._2)))
           val dimFileHierarchies = dimFileLevels.map(field => Hierarchy(relationEntry.tableName, Some(dimFileLevels.find(dl => dl.name.equalsIgnoreCase(relationEntry.relation.rightColumn)).get.column), Seq(field), Some(relationEntry.tableName)))
           dimFileDimensions = dimFileDimensions ++ dimFileHierarchies.map(field => Dimension(field.levels.head.name, Seq(field), Some(relationEntry.relation.leftColumn)))
 
@@ -679,7 +592,7 @@ private[sql] case class ShowCreateCube(cm: CubeModel, override val output: Seq[A
 
       case None =>
     }
-//    println(command.toString)
+
     Seq(Row(command.toString))
   }
 
@@ -1380,8 +1293,6 @@ private[sql] case class CreateCube(cm: CubeModel) extends RunnableCommand with C
             levelXml.name = level.name
             levelXml.column = level.column
             levelXml.levelType = level.levelType
-            if(level.parent != null)
-              levelXml.parentname = level.parent
             //TODO: find away to assign type in scala
             //levelXml.type = level.dataType
             setV(levelXml, "type", level.dataType)
@@ -1394,7 +1305,6 @@ private[sql] case class CreateCube(cm: CubeModel) extends RunnableCommand with C
 
       //val schemaWithAggs = GenerateAggTables(schema).apply
       //println(schemaWithAggs.toXML())
-//      println(schema.toXML())
 
       //Add schema to catalog and persist
       val catalog = CarbonEnv.getInstance(sqlContext).carbonCatalog
@@ -1673,24 +1583,10 @@ private[sql] case class LoadCube(
       val fileHeader = partionValues.getOrElse("fileheader", "")
       val escapeChar = partionValues.getOrElse("escapechar", "")
       val multiLine = partionValues.getOrElse("multiline", false)
-      val complex_delimiter_level_1 = partionValues.getOrElse("complex_delimiter_level_1", "\\$")
-      val complex_delimiter_level_2 = partionValues.getOrElse("complex_delimiter_level_2", "\\:")
       var booleanValForMultiLine = false
       if (multiLine.equals("true")) {
         booleanValForMultiLine = true
       }
-      
-      if(delimiter.equalsIgnoreCase(complex_delimiter_level_1) || 
-          complex_delimiter_level_1.equalsIgnoreCase(complex_delimiter_level_2) ||
-          delimiter.equalsIgnoreCase(complex_delimiter_level_2))
-      {
-    	  sys.error(s"Field Delimiter & Complex types delimiter are same")
-      }
-      else
-      {
-    	  molapLoadModel.setComplexDelimiterLevel1(MolapUtil.escapeComplexDelimiterChar(complex_delimiter_level_1))
-    	  molapLoadModel.setComplexDelimiterLevel2(MolapUtil.escapeComplexDelimiterChar(complex_delimiter_level_2))
-      }
 
       var partitionStatus = MolapCommonConstants.STORE_LOADSTATUS_SUCCESS
       try {
diff --git a/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/olapOperators.scala b/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/olapOperators.scala
index 7f9e7d2..77f6b17 100644
--- a/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/olapOperators.scala
+++ b/Molap/Molap-Spark-Interface/src/main/scala/org/apache/spark/sql/olapOperators.scala
@@ -36,7 +36,6 @@ import com.huawei.datasight.spark.processors.MolapScalaUtil
 import com.huawei.datasight.spark.processors.SparkTopNProcessor
 import com.huawei.datasight.spark.rdd.MolapDataRDD
 import com.huawei.unibi.molap.engine.aggregator.MeasureAggregator
-import com.huawei.unibi.molap.engine.aggregator.impl.SumAggregator
 import com.huawei.unibi.molap.engine.executer.impl.topn.TopNModel.MolapTopNType
 import com.huawei.unibi.molap.engine.expression.{ColumnExpression => MolapColumnExpression}
 import com.huawei.unibi.molap.engine.expression.{Expression => MolapExpression}
diff --git a/Molap/molap.properties.template b/Molap/molap.properties.template
index e9b6594..04da445 100644
--- a/Molap/molap.properties.template
+++ b/Molap/molap.properties.template
@@ -92,3 +92,4 @@ molap.kettle.home=<SPARK_HOME>/lib/molapplugins
 #carbon.auditlog.max.file.size=10MB
 #carbon.auditlog.max.backup.files=10
 #carbon.logging.level=INFO
+######
\ No newline at end of file
