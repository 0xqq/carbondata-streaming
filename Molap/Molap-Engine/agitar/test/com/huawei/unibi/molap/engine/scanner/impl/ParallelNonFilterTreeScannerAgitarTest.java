/**
 * Generated by Agitar build: AgitarOne Version 5.3.0.000022 (Build date: Jan 04, 2012) [5.3.0.000022]
 * JDK Version: 1.6.0_14
 *
 * Generated on 29 Jul, 2013 5:08:21 PM
 * Time to generate: 00:21.978 seconds
 *
 */

package com.huawei.unibi.molap.engine.scanner.impl;

import com.agitar.lib.junit.AgitarTestCase;
import com.agitar.lib.mockingbird.Mockingbird;
import com.huawei.unibi.molap.datastorage.store.FileHolder;
import com.huawei.unibi.molap.datastorage.store.impl.FileHolderImpl;
import com.huawei.unibi.molap.engine.datastorage.DataStoreBlock;
import com.huawei.unibi.molap.engine.datastorage.tree.CSBInternalNode;
import com.huawei.unibi.molap.engine.datastorage.tree.CSBTree;
import com.huawei.unibi.molap.engine.datastorage.tree.CSBTreeLeafNode;
import com.huawei.unibi.molap.engine.scanner.BTreeScanner;
import com.huawei.unibi.molap.keygenerator.KeyGenerator;
import com.huawei.unibi.molap.keygenerator.mdkey.MultiDimKeyVarLengthGenerator;

public class ParallelNonFilterTreeScannerAgitarTest extends AgitarTestCase {
    
    public Class getTargetClass()  {
        return ParallelNonFilterTreeScanner.class;
    }
    
    public void testConstructor() throws Throwable {
        byte[] endKey = new byte[0];
        byte[] startKey = new byte[1];
        int[] msrs = new int[0];
        KeyValue currKey = new KeyValue();
        FileHolder fileHolder = new FileHolderImpl(100);
        int[] lens = new int[0];
        KeyGenerator keyGenerator = new MultiDimKeyVarLengthGenerator(lens);
        ParallelNonFilterTreeScanner parallelNonFilterTreeScanner = new ParallelNonFilterTreeScanner(startKey, endKey, keyGenerator, 100L, currKey, msrs, fileHolder);
        assertSame("currKey.getMsrCols()", msrs, currKey.getMsrCols());
        assertEquals("parallelNonFilterTreeScanner.getNumOfNodesToCompare()", 100L, parallelNonFilterTreeScanner.getNumOfNodesToCompare().longValue());
        assertSame("parallelNonFilterTreeScanner.getFileHolder()", fileHolder, parallelNonFilterTreeScanner.getFileHolder());
        assertEquals("parallelNonFilterTreeScanner.blockKeys", 0, ((Number) getPrivateField(parallelNonFilterTreeScanner, "blockKeys")).intValue());
        assertSame("parallelNonFilterTreeScanner.getNext()", currKey, parallelNonFilterTreeScanner.getNext());
        assertSame("parallelNonFilterTreeScanner.msrs", msrs, getPrivateField(parallelNonFilterTreeScanner, "msrs"));
        assertEquals("parallelNonFilterTreeScanner.index", -1, ((Number) getPrivateField(parallelNonFilterTreeScanner, "index")).intValue());
        assertSame("parallelNonFilterTreeScanner.endKey", endKey, getPrivateField(parallelNonFilterTreeScanner, "endKey"));
        assertSame("parallelNonFilterTreeScanner.keyGenerator", keyGenerator, getPrivateField(parallelNonFilterTreeScanner, "keyGenerator"));
    }
    
    public void testGetNumOfNodesToCompare() throws Throwable {
        byte[] startKey = new byte[0];
        byte[] endKey = new byte[2];
        int[] msrs = new int[3];
        int[] lens = new int[0];
        ParallelNonFilterTreeScanner parallelNonFilterTreeScanner = new ParallelNonFilterTreeScanner(startKey, endKey, new MultiDimKeyVarLengthGenerator(lens), 100L, new KeyValue(), msrs, new FileHolderImpl(100));
        Long result = parallelNonFilterTreeScanner.getNumOfNodesToCompare();
        assertEquals("result", 100L, result.longValue());
    }
    
    public void testGetNumOfNodesToCompare1() throws Throwable {
        byte[] startKey = new byte[2];
        byte[] endKey = new byte[2];
        int[] msrs = new int[3];
        int[] lens = new int[0];
        ParallelNonFilterTreeScanner parallelNonFilterTreeScanner = new ParallelNonFilterTreeScanner(startKey, endKey, new MultiDimKeyVarLengthGenerator(lens), 0L, new KeyValue(), msrs, new FileHolderImpl());
        Long result = parallelNonFilterTreeScanner.getNumOfNodesToCompare();
        assertEquals("result", 0L, result.longValue());
    }
    
    public void testHasNext() throws Throwable {
        int[] lens = new int[1];
        DataStoreBlock block = new CSBInternalNode(100, 1000, "testParallelNonFilterTreeScannerTableName");
        byte[] startKey = new byte[0];
        byte[] endKey = new byte[1];
        int[] msrs = new int[3];
        ParallelNonFilterTreeScanner parallelNonFilterTreeScanner = new ParallelNonFilterTreeScanner(startKey, endKey, new MultiDimKeyVarLengthGenerator(lens), 100L, new KeyValue(), msrs, new FileHolderImpl());
        parallelNonFilterTreeScanner.setDataStore(new CSBTree(100, 1000, 0), block, 100);
        boolean result = parallelNonFilterTreeScanner.hasNext();
        assertFalse("result", result);
        assertEquals("parallelNonFilterTreeScanner.currentNumOfNodes", 0L, ((Number) getPrivateField(parallelNonFilterTreeScanner, "currentNumOfNodes")).longValue());
        assertEquals("parallelNonFilterTreeScanner.index", 0, ((Number) getPrivateField(parallelNonFilterTreeScanner, "index")).intValue());
        assertNull("parallelNonFilterTreeScanner.block", getPrivateField(parallelNonFilterTreeScanner, "block"));
    }
    
    public void testHasNext1() throws Throwable {
        int[] lens = new int[3];
        int[] msrs = new int[0];
        byte[] startKey = new byte[1];
        byte[] endKey = new byte[0];
        ParallelNonFilterTreeScanner parallelNonFilterTreeScanner = new ParallelNonFilterTreeScanner(startKey, endKey, new MultiDimKeyVarLengthGenerator(lens), 100L, new KeyValue(), msrs, new FileHolderImpl());
        boolean result = parallelNonFilterTreeScanner.hasNext();
        assertFalse("result", result);
        assertEquals("parallelNonFilterTreeScanner.currentNumOfNodes", 0L, ((Number) getPrivateField(parallelNonFilterTreeScanner, "currentNumOfNodes")).longValue());
    }
    
    public void testHasNext2() throws Throwable {
        int[] lens = new int[0];
        FileHolder fileHolder = new FileHolderImpl(100);
        KeyValue currKey = new KeyValue();
        byte[] startKey = new byte[2];
        byte[] endKey = new byte[0];
        int[] msrs = new int[3];
        ParallelNonFilterTreeScanner parallelNonFilterTreeScanner = new ParallelNonFilterTreeScanner(startKey, endKey, new MultiDimKeyVarLengthGenerator(lens), 100L, currKey, msrs, fileHolder);
        parallelNonFilterTreeScanner.setDataStore(null, new CSBInternalNode(100, 1000, "testParallelNonFilterTreeScannerTableName"), -1);
        boolean result = parallelNonFilterTreeScanner.hasNext();
        assertEquals("parallelNonFilterTreeScanner.currentNumOfNodes", 1L, ((Number) getPrivateField(parallelNonFilterTreeScanner, "currentNumOfNodes")).longValue());
        assertTrue("result", result);
        assertSame("parallelNonFilterTreeScanner.getNext()", currKey, parallelNonFilterTreeScanner.getNext());
        assertEquals("parallelNonFilterTreeScanner.index", 0, ((Number) getPrivateField(parallelNonFilterTreeScanner, "index")).intValue());
    }
    
    public void testHasNext3() throws Throwable {
        int[] lens = new int[0];
        KeyValue currKey = new KeyValue();
        DataStoreBlock block = new CSBTreeLeafNode(100, 1000, 0, false);
        byte[] startKey = new byte[2];
        byte[] endKey = new byte[2];
        int[] msrs = new int[1];
        ParallelNonFilterTreeScanner parallelNonFilterTreeScanner = new ParallelNonFilterTreeScanner(startKey, endKey, new MultiDimKeyVarLengthGenerator(lens), 0L, currKey, msrs, new FileHolderImpl());
        parallelNonFilterTreeScanner.setDataStore(new CSBTree(100, 1000, 0), block, -1);
        boolean result = parallelNonFilterTreeScanner.hasNext();
        assertFalse("result", result);
        assertEquals("parallelNonFilterTreeScanner.currentNumOfNodes", 0L, ((Number) getPrivateField(parallelNonFilterTreeScanner, "currentNumOfNodes")).longValue());
        assertSame("parallelNonFilterTreeScanner.getNext()", currKey, parallelNonFilterTreeScanner.getNext());
        assertEquals("parallelNonFilterTreeScanner.index", 0, ((Number) getPrivateField(parallelNonFilterTreeScanner, "index")).intValue());
    }
    
    public void testHasNextWithAggressiveMocks() throws Throwable {
        ParallelNonFilterTreeScanner parallelNonFilterTreeScanner = (ParallelNonFilterTreeScanner) Mockingbird.getProxyObject(ParallelNonFilterTreeScanner.class, true);
        KeyValue keyValue = (KeyValue) Mockingbird.getProxyObject(KeyValue.class);
        setPrivateField(parallelNonFilterTreeScanner, "block", Mockingbird.getProxyObject(DataStoreBlock.class));
        setPrivateField(parallelNonFilterTreeScanner, "blockKeys", new Integer(0));
        setPrivateField(parallelNonFilterTreeScanner, "currKey", keyValue);
        setPrivateField(parallelNonFilterTreeScanner, "index", new Integer(0));
        setPrivateField(parallelNonFilterTreeScanner, "numOfNodesToCompare", new Long(0L));
        setPrivateField(parallelNonFilterTreeScanner, "currentNumOfNodes", new Long(0L));
        keyValue.setReset(false);
        Mockingbird.enterRecordingMode();
        keyValue.increment();
        Mockingbird.setNormalReturnForVoid();
        Mockingbird.enterTestMode(ParallelNonFilterTreeScanner.class);
        boolean result = parallelNonFilterTreeScanner.hasNext();
        assertFalse("result", result);
        assertEquals("parallelNonFilterTreeScanner.currentNumOfNodes", 0L, ((Number) getPrivateField(parallelNonFilterTreeScanner, "currentNumOfNodes")).longValue());
        assertNull("parallelNonFilterTreeScanner.getNext().getArray()", parallelNonFilterTreeScanner.getNext().getArray());
        assertEquals("parallelNonFilterTreeScanner.blockKeys", 0, ((Number) getPrivateField(parallelNonFilterTreeScanner, "blockKeys")).intValue());
        assertEquals("parallelNonFilterTreeScanner.index", 1, ((Number) getPrivateField(parallelNonFilterTreeScanner, "index")).intValue());
        assertNotNull("parallelNonFilterTreeScanner.block", getPrivateField(parallelNonFilterTreeScanner, "block"));
    }
    
    public void testHasNextWithAggressiveMocks1() throws Throwable {
        ParallelNonFilterTreeScanner parallelNonFilterTreeScanner = (ParallelNonFilterTreeScanner) Mockingbird.getProxyObject(ParallelNonFilterTreeScanner.class, true);
        DataStoreBlock dataStoreBlock = (DataStoreBlock) Mockingbird.getProxyObject(DataStoreBlock.class);
        KeyValue keyValue = (KeyValue) Mockingbird.getProxyObject(KeyValue.class);
        DataStoreBlock dataStoreBlock2 = (DataStoreBlock) Mockingbird.getProxyObject(DataStoreBlock.class);
        setPrivateField(parallelNonFilterTreeScanner, "index", new Integer(1));
        setPrivateField(parallelNonFilterTreeScanner, "blockKeys", new Integer(0));
        setPrivateField(parallelNonFilterTreeScanner, "block", dataStoreBlock);
        setPrivateField(parallelNonFilterTreeScanner, "currentNumOfNodes", new Long(0L));
        setPrivateField(parallelNonFilterTreeScanner, "numOfNodesToCompare", new Long(0L));
        setPrivateField(parallelNonFilterTreeScanner, "currKey", keyValue);
        setPrivateField(parallelNonFilterTreeScanner, "fileHolder", null);
        Mockingbird.enterRecordingMode();
        Mockingbird.setReturnValue(dataStoreBlock.getNext(), dataStoreBlock2);
        Mockingbird.setReturnValue(dataStoreBlock2.getnKeys(), 1);
        Mockingbird.setReturnValue(false, keyValue, "setBlock", "(com.huawei.unibi.molap.engine.datastorage.DataStoreBlock,com.huawei.unibi.molap.datastorage.store.FileHolder)void", null, 1);
        Mockingbird.setReturnValue(false, keyValue, "resetOffsets", "()void", null, 1);
        Mockingbird.enterTestMode(ParallelNonFilterTreeScanner.class);
        boolean result = parallelNonFilterTreeScanner.hasNext();
        assertFalse("result", result);
        assertEquals("parallelNonFilterTreeScanner.currentNumOfNodes", 0L, ((Number) getPrivateField(parallelNonFilterTreeScanner, "currentNumOfNodes")).longValue());
        assertNull("parallelNonFilterTreeScanner.getNext().getArray()", parallelNonFilterTreeScanner.getNext().getArray());
        assertEquals("parallelNonFilterTreeScanner.blockKeys", 0, ((Number) getPrivateField(parallelNonFilterTreeScanner, "blockKeys")).intValue());
        assertEquals("parallelNonFilterTreeScanner.index", 1, ((Number) getPrivateField(parallelNonFilterTreeScanner, "index")).intValue());
        assertNotNull("parallelNonFilterTreeScanner.block", getPrivateField(parallelNonFilterTreeScanner, "block"));
    }
    
    public void testConstructorThrowsNullPointerException() throws Throwable {
        byte[] endKey = new byte[1];
        KeyValue currKey = new KeyValue();
        byte[] startKey = new byte[1];
        int[] msrs = new int[3];
        try {
            new ParallelNonFilterTreeScanner(startKey, endKey, null, 100L, currKey, msrs, new FileHolderImpl());
            fail("Expected NullPointerException to be thrown");
        } catch (NullPointerException ex) {
            assertNull("ex.getMessage()", ex.getMessage());
            assertThrownBy(BTreeScanner.class, ex);
        }
    }
}

