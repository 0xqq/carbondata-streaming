/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Generated by Agitar build: AgitarOne Version 5.3.0.000022 (Build date: Jan 04, 2012) [5.3.0.000022]
 * JDK Version: 1.6.0_14
 *
 * Generated on 29 Jul, 2013 4:48:56 PM
 * Time to generate: 00:20.821 seconds
 *
 */

package com.huawei.unibi.molap.engine.scanner;

import com.agitar.lib.junit.AgitarTestCase;
import com.agitar.lib.mockingbird.Mockingbird;
import com.huawei.unibi.molap.datastorage.store.FileHolder;
import com.huawei.unibi.molap.datastorage.store.compression.ValueCompressionModel;
import com.huawei.unibi.molap.datastorage.store.compression.ValueCompressionUtil;
import com.huawei.unibi.molap.datastorage.store.impl.FileHolderImpl;
import com.huawei.unibi.molap.datastorage.store.impl.data.compressed.HeavyCompressedDoubleArrayDataFileStore;
import com.huawei.unibi.molap.engine.datastorage.DataStore;
import com.huawei.unibi.molap.engine.datastorage.DataStoreBlock;
import com.huawei.unibi.molap.engine.datastorage.tree.CSBTree;
import com.huawei.unibi.molap.engine.datastorage.tree.CSBTreeLeafNode;
import com.huawei.unibi.molap.engine.datastorage.tree.HierarchyBtreeStore;
import com.huawei.unibi.molap.engine.scanner.impl.FilterTreeScanner;
import com.huawei.unibi.molap.engine.scanner.impl.KeyValue;
import com.huawei.unibi.molap.engine.scanner.impl.NonFilterTreeScanner;
import com.huawei.unibi.molap.keygenerator.mdkey.MultiDimKeyVarLengthGenerator;
import com.huawei.unibi.molap.metadata.LeafNodeInfo;

public class BTreeScannerAgitarTest extends AgitarTestCase {
    
    public Class getTargetClass()  {
        return BTreeScanner.class;
    }
    
    public void testGetFileHolder() throws Throwable {
        int[] lens = new int[0];
        FileHolder fileHolder = new FileHolderImpl();
        byte[] startKey = new byte[0];
        byte[] endKey = new byte[2];
        int[] msrs = new int[3];
        BTreeScanner filterTreeScanner = new FilterTreeScanner(startKey, endKey, new MultiDimKeyVarLengthGenerator(lens), new KeyValue(), msrs, fileHolder);
        FileHolder result = filterTreeScanner.getFileHolder();
        assertSame("result", fileHolder, result);
    }
    
    public void testGetFileHolder1() throws Throwable {
        byte[] startKey = new byte[0];
        byte[] endKey = new byte[3];
        int[] msrs = new int[1];
        int[] lens = new int[1];
        BTreeScanner filterTreeScanner = new FilterTreeScanner(startKey, endKey, new MultiDimKeyVarLengthGenerator(lens), new KeyValue(), msrs, null);
        FileHolder result = filterTreeScanner.getFileHolder();
        assertNull("result", result);
    }
    
    public void testGetNext() throws Throwable {
        byte[] startKey = new byte[3];
        byte[] endKey = new byte[3];
        int[] lens = new int[3];
        KeyValue currKey = new KeyValue();
        BTreeScanner nonFilterTreeScanner = new NonFilterTreeScanner(startKey, endKey, new MultiDimKeyVarLengthGenerator(lens), currKey, lens, new FileHolderImpl());
        KeyValue result = nonFilterTreeScanner.getNext();
        assertSame("result", currKey, result);
    }
    
    public void testIsDone() throws Throwable {
        int[] lens = new int[3];
        DataStore dataStore = new CSBTree(100, 1000, 0);
        byte[] startKey = new byte[1];
        byte[] endKey = new byte[2];
        int[] msrs = new int[0];
        BTreeScanner filterTreeScanner = new FilterTreeScanner(startKey, endKey, new MultiDimKeyVarLengthGenerator(lens), new KeyValue(), msrs, new FileHolderImpl());
        filterTreeScanner.setDataStore(dataStore, new CSBTreeLeafNode(100, 1000, 0, false), 100);
        boolean result = filterTreeScanner.isDone();
        assertTrue("result", result);
    }
    
    public void testIsDone1() throws Throwable {
        byte[] startKey = new byte[3];
        byte[] endKey = new byte[3];
        int[] lens = new int[3];
        BTreeScanner nonFilterTreeScanner = new NonFilterTreeScanner(startKey, endKey, new MultiDimKeyVarLengthGenerator(lens), new KeyValue(), lens, new FileHolderImpl());
        nonFilterTreeScanner.setDataStore(new HierarchyBtreeStore(null), new CSBTreeLeafNode(100, 1000, 0, false), -1);
        boolean result = nonFilterTreeScanner.isDone();
        assertFalse("result", result);
    }
    
    public void testSetDataStore() throws Throwable {
        int[] lens = new int[0];
        byte[] startKey = new byte[0];
        byte[] endKey = new byte[2];
        int[] msrs = new int[3];
        BTreeScanner filterTreeScanner = new FilterTreeScanner(startKey, endKey, new MultiDimKeyVarLengthGenerator(lens), new KeyValue(), msrs, new FileHolderImpl());
        DataStore dataStore = new CSBTree(100, 1000, 0);
        filterTreeScanner.setDataStore(dataStore, null, 100);
        assertEquals("(FilterTreeScanner) filterTreeScanner.index", 100, ((FilterTreeScanner) filterTreeScanner).index);
        assertSame("(FilterTreeScanner) filterTreeScanner.store", dataStore, ((FilterTreeScanner) filterTreeScanner).store);
        assertNull("(FilterTreeScanner) filterTreeScanner.block", ((FilterTreeScanner) filterTreeScanner).block);
    }
    
    public void testSetDataStore1() throws Throwable {
        byte[] startKey = new byte[3];
        byte[] endKey = new byte[3];
        int[] lens = new int[3];
        KeyValue currKey = new KeyValue();
        BTreeScanner nonFilterTreeScanner = new NonFilterTreeScanner(startKey, endKey, new MultiDimKeyVarLengthGenerator(lens), currKey, lens, new FileHolderImpl());
        DataStoreBlock block = new CSBTreeLeafNode(100, 1000, 0, false);
        DataStore dataStore = new CSBTree(100, 1000, 0);
        nonFilterTreeScanner.setDataStore(dataStore, block, 100);
        assertSame("(NonFilterTreeScanner) nonFilterTreeScanner.currKey", currKey, ((NonFilterTreeScanner) nonFilterTreeScanner).currKey);
        assertEquals("(NonFilterTreeScanner) nonFilterTreeScanner.blockKeys", -1, ((NonFilterTreeScanner) nonFilterTreeScanner).blockKeys);
        assertEquals("(NonFilterTreeScanner) nonFilterTreeScanner.index", 100, ((NonFilterTreeScanner) nonFilterTreeScanner).index);
        assertSame("(NonFilterTreeScanner) nonFilterTreeScanner.store", dataStore, ((NonFilterTreeScanner) nonFilterTreeScanner).store);
        assertSame("(NonFilterTreeScanner) nonFilterTreeScanner.block", block, ((NonFilterTreeScanner) nonFilterTreeScanner).block);
    }
    
    public void testSetDataStoreThrowsArrayIndexOutOfBoundsException() throws Throwable {
        int[] lens = new int[0];
        KeyValue currKey = new KeyValue();
        FileHolder fileHolder = new FileHolderImpl();
        byte[] startKey = new byte[0];
        byte[] endKey = new byte[2];
        int[] msrs = new int[3];
        BTreeScanner filterTreeScanner = new FilterTreeScanner(startKey, endKey, new MultiDimKeyVarLengthGenerator(lens), currKey, msrs, fileHolder);
        ValueCompressionModel compressionModel = ValueCompressionUtil.getValueCompressionModel("testBTreeScannerMeasureMetaDataFileLocation", 100);
        LeafNodeInfo leafNodeInfo = new LeafNodeInfo();
        int[] measureLength = new int[1];
        leafNodeInfo.setMeasureLength(measureLength);
        int[] lens2 = new int[0];
        DataStore dataStore = new HierarchyBtreeStore(new MultiDimKeyVarLengthGenerator(lens2));
        DataStoreBlock block = new CSBTreeLeafNode(100, 1000, true, new FileHolderImpl(), leafNodeInfo, compressionModel);
        Mockingbird.enterRecordingMode();
        currKey.setBlock(block, fileHolder);
        Mockingbird.setExceptionForVoid((Throwable) Mockingbird.getProxyObject(ArrayIndexOutOfBoundsException.class));
        Mockingbird.enterTestMode(BTreeScanner.class);
        try {
            filterTreeScanner.setDataStore(dataStore, block, 100);
            fail("Expected ArrayIndexOutOfBoundsException to be thrown");
        } catch (ArrayIndexOutOfBoundsException ex) {
            assertSame("(FilterTreeScanner) filterTreeScanner.currKey", currKey, ((FilterTreeScanner) filterTreeScanner).currKey);
            assertEquals("(FilterTreeScanner) filterTreeScanner.blockKeys", -1, ((FilterTreeScanner) filterTreeScanner).blockKeys);
            assertSame("(FilterTreeScanner) filterTreeScanner.store", dataStore, ((FilterTreeScanner) filterTreeScanner).store);
            assertSame("(FilterTreeScanner) filterTreeScanner.block", block, ((FilterTreeScanner) filterTreeScanner).block);
            assertEquals("(FilterTreeScanner) filterTreeScanner.index", -1, ((FilterTreeScanner) filterTreeScanner).index);
            assertEquals("(CSBTreeLeafNode) block.getnKeys()", 0, ((CSBTreeLeafNode) block).getnKeys());
        }
    }
    
    public void testSetDataStoreThrowsNullPointerException() throws Throwable {
        DataStore dataStore = new CSBTree(100, 1000, 0);
        ValueCompressionModel compressionModel = ValueCompressionUtil.getValueCompressionModel("testBTreeScannerMeasureMetaDataFileLocation", 100);
        int[] measureLength = new int[2];
        LeafNodeInfo leafNodeInfo = new LeafNodeInfo();
        leafNodeInfo.setMeasureLength(measureLength);
        int[] lens = new int[1];
        int[] msrs = new int[3];
        byte[] startKey = new byte[2];
        byte[] endKey = new byte[0];
        KeyValue currKey = new KeyValue();
        BTreeScanner nonFilterTreeScanner = new NonFilterTreeScanner(startKey, endKey, new MultiDimKeyVarLengthGenerator(lens), currKey, msrs, new FileHolderImpl(100));
        DataStoreBlock block = new CSBTreeLeafNode(100, 1000, true, null, leafNodeInfo, compressionModel);
        try {
            nonFilterTreeScanner.setDataStore(dataStore, block, 100);
            fail("Expected NullPointerException to be thrown");
        } catch (NullPointerException ex) {
            assertNull("ex.getMessage()", ex.getMessage());
            assertThrownBy(HeavyCompressedDoubleArrayDataFileStore.class, ex);
            assertSame("(NonFilterTreeScanner) nonFilterTreeScanner.currKey", currKey, ((NonFilterTreeScanner) nonFilterTreeScanner).currKey);
            assertEquals("(NonFilterTreeScanner) nonFilterTreeScanner.blockKeys", -1, ((NonFilterTreeScanner) nonFilterTreeScanner).blockKeys);
            assertSame("(NonFilterTreeScanner) nonFilterTreeScanner.store", dataStore, ((NonFilterTreeScanner) nonFilterTreeScanner).store);
            assertSame("(NonFilterTreeScanner) nonFilterTreeScanner.block", block, ((NonFilterTreeScanner) nonFilterTreeScanner).block);
            assertEquals("(NonFilterTreeScanner) nonFilterTreeScanner.index", -1, ((NonFilterTreeScanner) nonFilterTreeScanner).index);
            assertEquals("(CSBTreeLeafNode) block.getnKeys()", 0, ((CSBTreeLeafNode) block).getnKeys());
        }
    }
}

